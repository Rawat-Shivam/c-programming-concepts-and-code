



we cant use sizeof operator to be used to tell the size of an array passed to a function.
passing an array to a function is exactly the saem as passing a pointer to the first element.

so u can pass the size as argument,

compiler can genrate good code for pointers than for subscripts.

===============================================================

memcpy(dest,source, MAX);

===============================================================
void func(char *str[])
{
	while (*str)
		printf("%c",*str++);
	
}
like this u can check the end of string (NUL whose ascii is 0)

===============================================================
arrName : it is the pointer to the first element in the array;
	  &arr[0]

&arrName : it is the pointer to the array as whole;
	   
===============================================================

char arr[ (sizeof( struct A))* MAX];

===============================================================

c strings always end with NUL

char a[]="hello";
it is char array not string...therefore no NUL characters

===============================================================
strcpy() works with srirngs and stops when the terminating null character has been moved . so it include null.

memcpy() is designed for any data type. since all data type does not end with string so we must specify the no of bytes. u can use it with structures.

===============================================================
if u want to remove spaces at the end of string ...u will move till the last charcter and when u first encounter the blank space " " u will put NUL \0  at that position

no if the there are leading spaces..so u will first reverse string and do same as above and then again reverse.


===============================================================
c library have (int float long)format  to string conversion. and vice versa

itoa(), ltoa(), ultoa()...but these are not ANSI compatible ..and another way is sprintf(), fcvt():float to string , ecvt(),gcvt().

atoi(), atof(), atol(), 

strtod(), strtoul() 

===============================================================

strcmp(), strncmp() strnicmp() stricmp() strcmpi()

printf can be used to print the part of the string with help of 
width option in printf(%format)  %widthprecissinlengthflagFormat

===============================================================

char *str="hello, world";
        char *str1="hello, world";
        if(strcmp(str,str1))
                printf("equal\n");
        else
                printf("unequal\n");

//output: unequal

bassically it strings are same ...but strcmp when equal gives zero
and if(0) means execute the else part

===============================================================
 char *str="hello";
        char *str1[5];
        strcpy(str,str1);
        printf("%s\n",str1);

//segmentation fault


xyz.c: In function ‘main’:
xyz.c:13:13: warning: passing argument 2 of ‘strcpy’ from incompatible pointer type [-Wincompatible-pointer-types]
  strcpy(str,str1);
             ^~~~
In file included from xyz.c:6:0:
/usr/include/string.h:121:14: note: expected ‘const char * restrict’ but argument is of type ‘char **’
 extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
              ^~~~~~
xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘char **’ [-Wformat=]
  printf("%s\n",str1);
          ~^    ~~~~


===============================================================

       char *str     ="hello, world";
       char str1[15] ="hello wo 9";

       strcpy(str, str1);

       printf("%s", str1);

// it compile all fine
// but gives segmentation fault

===============================================================

if u remeber 13 memory issue project 303

when u print a string it will keep priting till it see the nul \0 character. 

===============================================================

int main()
{
        char *str ="hello, world";
        char str1[9];
        strncpy(str1,str,9);
        printf("%s %ld\n",str1,strlen(str1));
}

//output: hello, wo`@ 12
it is undefined

so we could say these copy between *str and str1[] are undefined.
===============================================================
	
char *str ="hello, world\n";
      char str1[]="hello, world\n";
      printf("%ld %ld\n", strlen(str), strlen(str1) );

//output: 13 13


===============================================================

        char *str ="hello, world\n";
        char str1[]="hello, world\n";
        printf("%ld %ld\n", strlen(str), strlen(str1) );
        printf("%ld %ld\n", sizeof(str), sizeof(str1) );
//output:
13 13
8 14
  
===============================================================

        char *str ="hello, world";
        char str1[]="hello, world";
        printf("%ld %ld\n", strlen(str), strlen(str1) );
        printf("%ld %ld\n", sizeof(str), sizeof(str1) );
//output:
12 12
8 13

===============================================================

        char str[]="hello";
        char *str1 ="world";
        strcat(str,str1);
        printf("%s %d",str,str[10]);

//output: helloworld 0

===============================================================

char str[5]="hello";
        char *str1 ="world";
        strcat(str,str1);
        printf("%s %d",str,str[10]);
//output:hello@world 114
undefined behaviour.

===============================================================
 char str[10]="hello";
 printf(":%s:\n%d",str,str[10]);

//output:

:hello:
-80

===============================================================

        char str[10]="hello";
        char *str1 ="world";
        strncat(str,str1,2);
        printf(":%s:\n",str);

//output
:hellowo:
===============================================================

        char str[10]="hello";
        char *str1 ="world";
        strncat(str,str1,15);
        printf(":%s:\n",str);

//output
:helloworld:
---

strncat(str,str1,5);
:helloworld:

strncat(str,str1,9);
:helloworld:



===============================================================

strcat(), strcmp(), strcpy(), strlen() rely on presence of NULL character

       strchr, strrchr, strchrnul - locate character in string
       strcasecmp, strncasecmp - compare two strings ignoring case
       strstr, strcasestr - locate a substring
       memchr, memrchr, rawmemchr - scan memory for a character

//look in mapages for more functions
===============================================================

int var=strcmp("Hello", "World");

var will be -1(negative)
check man page
===============================================================

The  strchr()  function  returns  a  pointer to the first
       occurrence of the character c in the string s.

The strrchr() function returns  a  pointer  to  the  last
       occurrence of the character c in the string s.

The  strchrnul() function is like strchr() except that if
       c is not found in s, then it returns  a  pointer  to  the
       null byte at the end of s, rather than NULL.

===============================================================

#include<ctype.h>
int main()
{
        char i=9;
        char i1='9';
        int j=9;
        int j1='9';

        if(isdigit(i))
                printf("--- i\n");

        if(isdigit(i1))
                printf("--- i1\n");

        if(isdigit(j))
                printf("--- j\n");

        if(isdigit(j1))
                printf("--- j1\n");

}

--- i1
--- j1

===============================================================

 if(isspace('\n'))
                printf("+++++ space \\n \n");
//output:
+++++ space \n 

===============================================================

if(isspace(' '))
                printf("+++++ space ' ' \n");


//output:
+++++ space ' ' 

===============================================================

if(isspace('\t'))
                printf("+++++ space \\t \n");

//output:
+++++ space \t 

//similarly \v,\r

//but not \b,\a
===============================================================

fgetc, fgets, getc, getchar, ungetc - input of characters and strings

       int ungetc(int c, FILE *stream);
 ungetc() pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations.   Pushed-back
       characters will be returned in reverse order; only one pushback is guaranteed.

===============================================================
       fgetwc, getwc - read a wide character from a FILE stream
===============================================================

u do scanf a integer ,then do ungetc, then scanf ,then printf

so it will print the integer u typed first time.

=============================================================

using static  before function restricts its access to the file where they are declared .

static functions  should be decclared and definedd in the same file.

===============================================================
prototype helps compiler in ensuring the correct argument type

===============================================================
int x[10];//array

funcall(x)//passing address of array

funcallreceived(int i[])//as they array is passed by value an exact copy of the array is made and placed on the stack. the the fucntion receives copy of this array. modifing the int i[] will have no effect on the int x[]....since it is the copy of the array.

//this is inefficient ...as it copies and take time and memory

//therefore insted of passing arraya by value
we should pass by refrence.

to do so ... declare pointer to the data type in the functions prototype


function(cont int *)

int x[10];
funccall(x);//now it receives the array by refrence 


//adn it receive it as const ..therefore no change
//and inside the functionreceived(const int *i) 
// you can traverse it by *(i+ index_var);


===============================================================

atexit - register a function to be called at normal process termination

       #include <stdlib.h>

       int atexit(void (*function)(void));


so if u want to execute the code when program exits u can....cleanup code ..and they functions are executed in LIFO manner if u have called atexit(func1) ...atexit(func2)...multiple time


===============================================================
generaly fucntion parameters are passed right to left...but in PASCAL convetion it is from left ot right..

it means in the stack the rightmost is stored in first for C language.


the functions using PASCAL convention are more efficient than regular C functions.
int PASCAL func();
===============================================================

return ; it goes back to the calling function

exit ; program is closed and control goes back to OS

===============================================================
int main()
{
        void foo(),f();
        f();

}

void foo()
{
        printf("2");
}

void f()
{
        printf("1");
        foo();
}

//output: 1 2

===============================================================

int main()
{
        void foo();
        void f()
        {
                printf("1");
                foo();
        }
        f();
}

void foo()
{
        printf("2");
}
//output: 1 2
it could be language and comiler dependent

===============================================================
u can write prototype multiple time anywhere 
but only one defination.

no multiple defination is allowed ...even though they are exact saem defination.

===============================================================

        void foo();
        void foo(int);
int main()
{


        foo(5);
}

void foo(int i)
{
        printf("222222 %d",i);
}

//output: 222222 5

// in c function overloading is not allowed ...
//only one prototype ..no multiple prototype
//no multiple defiantion

but u can have a an empty argument prototype adn as well as a prototype with some arguments.
===============================================================

void foo(void);
void foo(int);
int main()
{


        foo(5);
}

void foo(int i)
{
        printf("222222 %d",i);
}


xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo(int i)
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
      ^~~


//so u can only have a empty prototype
===============================================================

        void foo(void);
        void foo(int);
int main()
{


        foo(5);
}

void foo()
{
        printf("222222 ");
}




xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo()
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~

===============================================================

void foo(void);
        void foo(int);
int main()
{


        foo();
}

void foo()
{
        printf("222222 ");
}


xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c: In function ‘main’:
xyz.c:14:2: error: too few arguments to function ‘foo’
  foo();
  ^~~
xyz.c:9:7: note: declared here
  void foo(int);
       ^~~
xyz.c: At top level:
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo()
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~


===============================================================

 sqrt, sqrtf, sqrtl - square root function

       #include <math.h>

       double sqrt(double x);
       float sqrtf(float x);
       long double sqrtl(long double x);

       Link with -lm.

============================================================

       csqrt, csqrtf, csqrtl - complex square root

       #include <complex.h>

       double complex csqrt(double complex z);
       float complex csqrtf(float complex z);
       long double complex csqrtl(long double complex z);

       Link with -lm.
===============================================================

void foo(void);

int main()
{
        int k= foo();
        printf("%d\n",k);
}

void foo()
{
        printf("1234567890");
}


xyz.c: In function ‘main’:
xyz.c:11:9: error: void value not ignored as it ought to be
  int k= foo();
         ^~~
===============================================================


int foo(void);
int main()
{
        int k= foo();
        printf("%d\n",k);
}
int foo()
{
      printf("1234567890");
}

xyz.c: In function ‘foo’:
xyz.c:18:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
===============================================================

int* foo()
{
        int *p=5;

        return p;

}

int main()
{
        int *k= foo();
        printf("%d\n",k);
}

//output:5




xyz.c: In function ‘foo’:
xyz.c:10:9: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  int *p=5;
         ^
xyz.c: In function ‘main’:
xyz.c:19:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat=]
  printf("%d\n",k);
          ~^
          %ls


The %ls format specifier represents a wide string

===============================================================

int* foo()
{
        int arr[]={5,8};
        return arr;

}
int main()
{
        int *k= foo();
        printf("%d\n",k[0]);
}
//output: segmentation fault

xyz.c: In function ‘foo’:
xyz.c:11:9: warning: function returns address of local variable [-Wreturn-local-addr]
  return arr;
        ^~~
===============================================================

int foo()
{
        int arr[]={5,8};
        return arr[1];

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}
//output: 8

===============================================================

int * foo()
{
        int arr[]={5,8};
        return arr;

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}

// output: 0(but i can varry)

xyz.c: In function ‘foo’:
xyz.c:12:9: warning: function returns address of local variable [-Wreturn-local-addr]
  return arr;
         ^~~
xyz.c: In function ‘main’:
xyz.c:17:9: warning: initialization makes integer from pointer without a cast [-Wint-conversion]
  int k= foo();
         ^~~

===============================================================

foo()
{
        return 'A';

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}
//output: 65 

xyz.c:9:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 foo()
 ^~~

===============================================================

double foo();

foo()
{
        return 2;

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}



xyz.c:10:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 foo()
 ^~~
xyz.c:10:1: error: conflicting types for ‘foo’
xyz.c:8:8: note: previous declaration of ‘foo’ was here
 double foo();
        ^~~


===============================================================

enum m{ A , B , C , D};

enum m  foo();

int foo()
{
        return D;

}

int main()
{
        enum m i = foo();
        printf("%d\n",i);
}



xyz.c:12:5: error: conflicting types for ‘foo’
 int foo()
     ^~~
xyz.c:10:9: note: previous declaration of ‘foo’ was here
 enum m  foo();
         ^~~

===============================================================


enum m{ A , B , C , D};

enum m  foo();

enum m foo()
{
        return D;

}

int main()
{
        enum m i = foo();
        printf("%d\n",i);
}

//output: 3

it works..fine....

===============================================================


enum m{ A , B , C , D};

enum m  foo();

enum m foo()
{
        return D;

}

int main()
{
        enum m = foo();
        printf("%d\n",m);
}


xyz.c: In function ‘main’:
xyz.c:20:9: error: expected identifier or ‘(’ before ‘=’ token
  enum m = foo();
         ^
xyz.c:21:16: error: ‘m’ undeclared (first use in this function)
  printf("%d\n",m);
                ^
xyz.c:21:16: note: each undeclared identifier is reported only once for each function it appears in

===============================================================


       stdarg, va_start, va_arg, va_end, va_copy - variable argument lists


       #include <stdarg.h>

       void va_start(va_list ap, last);
       type va_arg(va_list ap, type);
       void va_end(va_list ap);
       void va_copy(va_list dest, va_list src);

===============================================================

int x[5]={1,2,3,4,5};

int y[5];
y=x; // it is wrong..  we cant treat arrar as lvalue 
//because it consist of many elements... and x does not mean anuthing ...its array element which means.

but,
if u want to copy the elements at once..
memcpy(x,y,5);


but, 
if u have struture u can treat it a Lvalue,
ie....you can assign the variables
struct_var1=struct_var2;

===============================================================
Lvalues are on left and Rvalues are on right of the assignment

Rvalue is mostly a expression, or a constant

x=1; 
//x is lvalue
// 1 is rvalue (constant)

a assignment statement must have L and R values.

int x;
x=void_returning_func();
//if the function call had returned something ...it would have been ok
//but here r value misssing;

Rvalue evaluates into something that can be put into Lvalue.

===============================================================

int *p;

'p' can be used as lvalue since it can be indirected to store

but a pointer to the constant is not a lvalue because to the point which it is point to is constan.

==============================================================

NULL is macro in <stddef.h>

NULL is literal zero cast to void* or char* , but int* might not work . so we need something that points to zero after conversion

NULL pointers are also used as errors.
NULL pointers are also used to stop imdirection (like in link list)
NULL pointers are also used as sentinel value( as last value for variable arguments.... execl)


===============================================================
void pointer... the compiler has no idea to which kind of object it points.
for int* pointer ...compiler knows it will point to an integer type.

void is used when working for raw data or an unspecified type.

valaue of NULL pointer is equall to zero, but it is not stored as same as zero.
(cast NULL to other types ..and print it. you can also use debugger to see the value.)

===============================================================

qsort()
void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(const void *, const void *));



===============================================================
compilers for PC compatibiles uses two kind of pointer.

near pointer: 16 bit long..and can address a 64KB range.
far pointers: are 32 bit long and can address a 1MB

near pointers operate within a 64KB segment. far pointers have 16 bit base and a 16 bit offset.

before we compile our code , you must tell the compilers which memeory model to use. far pointers are little slower

sometimes things which do not fit into data segment and code segments..then u use far pointers


===============================================================

int main()
{
        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fprintf(stderr,":%d + %d:",95,95);
        fprintf(fp,":%d - %d:",45,45);

        return 0;
}

//output: :95 + 95::45 - 45::45 - 45:


===============================================================

int main()
{
        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:\n",45,45);
        fprintf(stderr,":%d + %d:\n",95,95);
        fprintf(fp,":%d - %d:\n",45,45);

        return 0;
}

//output:
:45 - 45:
:95 + 95:
:45 - 45:

===============================================================

FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fflush(stdout);
        fprintf(stderr,":%d + %d:",95,95);
        fprintf(fp,":%d - %d:",45,45);

        return 0;

//output:
:45 - 45::95 + 95::45 - 45:

===============================================================

        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fflush(stdout);
        fprintf(fp,":%d - %d:",45,45);
        fprintf(stderr,":%d + %d:",95,95);

        return 0;
//output:
:45 - 45::95 + 95::45 - 45:

===============================================================


errno is a global variable . mostly used by c libraries to store the error value of the functions failed but many times it is not updated by the functions .

so it is not a good idea to use it, insted use the value returned from the fucntion to check for errors.

===============================================================

stream is the continous series of bytes.... that flows in or out of our program. 

input and output from the devices are handled as streams....ie byte by byte. streams appears as logical files(not physically).

stdin - keyboard
stdout - screen
stderr - screen
 

stdout stream can be redirected to file in disk.
stdin can be redirected to the file in disk.

to redirect stream in your program use freopen()
u can use fdopen() and dup() // see man page 

===============================================================
streams can be text stream or byte stream. 
===============================================================
use low level IO fnctions when accessing shared files.

but when accessing non shared files use the buffered stream functions (fopen(), fread(), fwrite()....) 

===============================================================

char *envPathString;

envPathString=getenv("PATH");
if(envPathString != NULL)
printf("path:=%s",envPathString);

===============================================================

sopen(), u can open file in shared mode andd expilicitly deny reading and writing permissions to any other programs but yours (SH_DENYWR flag).

===============================================================

bit feilds are not portable. because the number of bits in a machine word is different on different machine, a particular program using bit feilds might not even compile on a particular machine

int a:30;
int b:2;
this will work for machine having integer value in 32 bits 

but if we go to an architecture that uses 16 bits to store integer vlaue it will not even compile..it will result in error.

===============================================================

u may do bit shift or do multiplication by 2
it doesnt matter..it works same inside....

so it is advised to use technique ...where it is more readable.
===============================================================

bit masking means which bit you want to SET and which bit you want to CLEAR

to __examine__ some bits of a byte, 

the byte is bitwised 'ANDed' with a mask that is a number consisting only of those bits of interests:  " num & 1" will be used to examin the rightmost digit .if it is high(1) the resultant will be oen. similarly u want to check/examine the 3rd last digit of a number 'num': " num & (1<<3) " OR " num & 8" ..if u get resultant as 8, it means it is set.

 

to __SET__ a bit
 set the rightmost bit :num | 1
 set 3rd last bit : " num | (1<<3) " or " num | 8 "


to __CLEAR__ a bit

bitwise AND the number with the one's complement of the bit mask.
clearing the last bit(rightmost): num = num & ~1
clearing the 3rd last bit from right : "num & ~8 " or " num & ~(1<<3) "


===============================================================
the array in the second argument of command line argumnts is the' int **argv'....ie jagged array or array of array.

A jagged array is an array whose elements are arrays. The elements of a jagged array can be of different dimensions and sizes. A jagged array is sometimes called an "array of arrays."
===============================================================

printf(" %s\n", argv[argc]);
notice the subscript operator argv[argc].

it will print null, because array index start from zero

===============================================================

xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
  printf("%s\n",argc);
          ~^
          %d
===============================================================

        printf("%d\n",argc);

//output:
[root@localhost rawat]# ./a.out hello hi 5 10 bye
6


[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL \0
8
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0'
8
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0' (void*)0
-bash: syntax error near unexpected token `('
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0' "(void*)0"
9
[root@localhost rawat]# 

===============================================================

        printf("-----------------\n");

        printf("%c \n",*(*(argv+0)+0) );
        printf("%c \n",*(*(argv+0)+1) );
        printf("%c \n",*(*(argv+0)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+1)+0) );
        printf("%c \n",*(*(argv+1)+1) );
        printf("%c \n",*(*(argv+1)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+2)+0) );
        printf("%c \n",*(*(argv+2)+1) );
        printf("%c \n",*(*(argv+2)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+3)+0) );
        printf("%c \n",*(*(argv+3)+1) );
        printf("%c \n",*(*(argv+3)+2) );


[root@localhost rawat]# ./a.out ABCDEF abcdef 12345 UVWXYZ uvwxyz
-----------------
. 
/ 
a 
-----------------

A 
B 
C 
-----------------

a 
b 
c 
-----------------

1 
2 
3 
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# ./a.out ABCDEF uv
-----------------
. 
/ 
a 
-----------------

A 
B 
C 
-----------------

u 
v 
 
-----------------

Segmentation fault (core dumped)
[root@localhost rawat]# vim xyz.c 

[root@localhost rawat]# ./a.out 12345 UVWXYZ uvwxyz
-----------------
. 
/ 
a 
-----------------

1 
2 
3 
-----------------

U 
V 
W 
-----------------

u 
v 
w 
[root@localhost rawat]# 




===============================================================

        printf("%s\n",argv[0]);
        printf("%s\n",argv[1]);
        printf("%s\n",argv[2]);
        printf("%s\n",argv[3]);
        printf("%s\n",argv[4]);

[root@localhost rawat]# ./a.out 4 hi bye 5 
./a.out
4
hi
bye
5
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 4 hi bye 5 hello ok
./a.out
4
hi
bye
5
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 4 hi 
./a.out
4
hi
Segmentation fault (core dumped)
[root@localhost rawat]# 
===============================================================



        printf("%c\n",argv[0][0]);
        printf("%c\n",argv[1][0]);
        printf("%c\n",argv[2][0]);
        printf("%c\n",argv[3][0]);
        printf("%c\n",argv[4][0]);



[root@localhost rawat]# ./a.out 65 hi zz abc xyz
.
6
h
z
a
[root@localhost rawat]# 



===============================================================
  printf("%s\n",*argv+1);
        printf("%s\n",*argv+2);
        printf("%s\n",*argv+3);


[root@localhost rawat]# ./a.out 65 hi zz abc xyz
/a.out
a.out
.out
[root@localhost rawat]# 


===============================================================
        printf("%s\n",*(argv));
        printf("%s\n",*(argv+1));
        printf("%s\n",*(argv+2));
        printf("%s\n",*(argv+3));

[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
./a.out
p65
hi99
z8z
[root@localhost rawat]# 



===============================================================


        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));

[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
./a.out
p65
hi99
z8z
[root@localhost rawat]# 



===============================================================
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
.
p
h
z
[root@localhost rawat]# 


===============================================================

        printf("%c\n",**(argv+0));
        printf("%c\n",**(argv+1));
        printf("%c\n",**(argv+2));
        printf("%c\n",**(argv+3));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
.
p
h
z
[root@localhost rawat]# 


===============================================================

        printf("%s\n",((*argv)+1));
        printf("%s\n",((*argv)+2));
        printf("%s\n",((*argv)+3));

OR

        printf("%s\n",(*(argv)+1));
        printf("%s\n",(*(argv)+2));
        printf("%s\n",(*(argv)+3));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
/a.out
a.out
.out
[root@localhost rawat]# 



===============================================================


        printf("%s\n",*(argv+1)+0);
        printf("%s\n",*(argv+2)+0);



[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
p65
hi99
[root@localhost rawat]# 


===============================================================
        printf("%s\n", *((argv+1)+2) );
        printf("%s\n", *((argv+2)+2));

[root@localhost rawat]# ./a.out p656p hi9ih z8z ab10c xyz
z8z
ab10c
[root@localhost rawat]#


===============================================================

===============================================================
===============================================================

        printf("%s\n",argv[1][0]);

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g
xyz.c: In function ‘main’:
xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
  printf("%s\n",argv[1][0]);
          ~^    ~~~~~~~~~~
          %d


===============================================================
        printf("%d\n",argv[1][0]);

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)

===============================================================

        printf("%d\n",argv[0][0]);
        printf("%d\n",argv[0][1]);
        printf("%d\n",argv[0][2]);
        printf("%d\n",argv[0][3]);
        printf("%d\n",argv[0][4]);
        printf("%d\n",argv[1][0]);



[root@localhost rawat]# ./a.out hello 5 hi 
46
47
97
46
111
104




===============================================================

        printf("%d\n",argv[0]);

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g
xyz.c: In function ‘main’:
xyz.c:14:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[0]);
          ~^    ~~~~~~~
          %s
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[1]);
          ~^    ~~~~~~~
          %s
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[2]);
          ~^    ~~~~~~~
          %s
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[3]);
          ~^    ~~~~~~~
          %s
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[4]);
          ~^    ~~~~~~~
          %s



===============================================================
======	new concepts in char **argv	=======================


int main(  int argc, char **argv)
{

        while(*argv++ != NULL)
                printf("%s\n",*argv);

        return 0;
}

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)


[root@localhost rawat]# ./a.out hii
hii
Segmentation fault (core dumped)
[root@localhost rawat]# ./a.out hii byee
hii
byee
Segmentation fault (core dumped)
[root@localhost rawat]# ./a.out hii byee but-why
hii
byee
but-why
Segmentation fault (core dumped)
[root@localhost rawat]# 

===============================================================

int main(  int argc, char **argv)
{

        while(*++argv != NULL)
                printf("%s\n",*argv);

        return 0;
}


[root@localhost rawat]# ./a.out 
[root@localhost rawat]# ./a.out hii byee
hii
byee
[root@localhost rawat]# 

===============================================================
while(*argv != NULL)
                printf("%s\n",*argv++);

[root@localhost rawat]# ./a.out 
./a.out
[root@localhost rawat]# ./a.out  helllo 0
./a.out
helllo
0
[root@localhost rawat]# 




===============================================================

while(*argv != NULL)
        {
                printf("%s\n",*(argv++));
        }


[root@localhost rawat]# ./a.out  helllo 0
./a.out
helllo
0
[root@localhost rawat]# 



===============================================================

 while(*argv != NULL)
        {
                printf("%s\n",(*argv)++);
                sleep(2);
        }



[root@localhost rawat]# ./a.out
./a.out
/a.out
a.out
.out
out
ut
t

LS_COLORS=rs=0:di=38;5;33:ln=38;5;51:mh=00:pi=40;38;5;11:so=38;5;13:do=38;5;5:bd=48;5;232;38;5;11:cd=48;5;232;38;5;3:or=48;5;232;38;5;9:mi=01;05;37;41:su=48;5;196;38;5;15:sg=48;5;11;38;5;16:ca=48;5;196;38;5;226:tw=48;5;10;38;5;16:ow=48;5;10;38;5;21:st=48;5;21;38;5;15:ex=38;5;40:*.tar=38;5;9:*.tgz=38;5;9:*.arc=38;5;9:*.arj=38;5;9:*.taz=38;5;9:*.lha=38;5;9:*.lz4=38;5;9:*.lzh=38;5;9:*.lzma=38;5;9:*.tlz=38;5;9:*.txz=38;5;9:*.tzo=38;5;9:*.t7z=38;5;9:*.zip=38;5;9:*.z=38;5;9:*.Z=38;5;9:*.dz=38;5;9:*.gz=3
_____SEGFAULT______

===============================================================




===============================================================




===============================================================

Originally Answered: Why are one's complement and two's complement systems used in computer systems?
Ones’ complement is simply the value obtained by inverting all of the bits in a binary number (swapping 1’s and 0’s).

So 1 in binary (using 8-bit numbers) is 00000001, or 0x01 in hexadecimal, and the ones’ complement, or -1, would be 11111110, 0r 0xFE.

When adding two numbers, if a carry results then it must be added back in (known as an end around carry). This happens for example in the following example where a negative number is added to a positive one (subtraction):

example: 33 - 7:

  00100001  or 0x21 (33) 
  11111000  or 0xF9 (two’s complement of 7) 
  ======== 
1 00011001 
         1  add end-around carry 
  ======== 
  00011010 or 0x1A (26) 
The main disadvantage of ones’ complement, is that there are two valid representations for 0: all 0’s, and all 1’s.

This is 0: 00000000 and so is this: 11111111.

When in grad school, we did all of our assignments on a large mainframe called the Univac 1108, which used ones’ complement arithmetic, and had to deal with the two kinds of zero when programming in assembly language.

Two’s complement, on the other hand, is defined as the one’s complement of a number, plus one (unsigned). So again 1 is 00000001, 0x01, and the two’s complement, or -1, would be 11111110 + 1, or 11111111, or 0xFF.

Even though it takes an extra step to form the two’s complement of a number, two’s complement is pretty much universally used in today’s computer systems. It makes addition of a positive and negative number (i.e. subtraction) simpler: just add them as if they were both unsigned:

example: 33 - 7:

  00100001  or 0x21 (33) 
  11111001  or 0xFA (two’s complement of 7) 
  ======== 
  00011010  or 0x1A (26) 
The carry is ignored.


===============================================================

Ones and two complements have two very useful property :

You can store a one or two’s complement of a value in memory without needing extra flags etc.
if you want to say do a-b, then if you convert b to it’s complement version - call it b’ , you can do a + b’ and still get the right answer. Since you already have a twos complement converter in your CPU (so that you can store negative numbers), you now also only need an adder circuit to do both addition and subtraction.

===============================================================

The primary advantage of two's complement over one's complement is that two's complement only has one value for zero.

One's complement has a "positive" zero and a "negative" zero, thereby increasing memory usage.

our main theme is we have to use less memory and should get most affective output

hence we get more effective output in 2’s complement


===============================================================

when you press the key 'A', your keyboard sends a combination of 1s and 0s through a bundle of 7 wires.

Okay now what actually happens when you press the key 'A' ?
Our computer has a standard code for each character, like 'A', so when you press the key 'A', its standard code '1000001' is sent to the computer by your keyboard(send electrical current). There are Seven wires for your keyboard. The standard code of 'A' is '1000001'. Your keyboard sends an electrical current through the first wire(that represents 1), then no current at all through the second, third, fourth, fifth and sixth wire (which represents 0) and then, an electrical current again through the seventh wire.

Now the question is how does your computer understand the code you just sent?


As I said earlier, computer has many many circuits built inside it, when you send the electrical signals, they are directed to these circuits. Computer can not understand us but, they can understand that 'so-in-so' circuit has current passing through it. So when your keyboard sends the electrical signals, at that time, computer does not get the code. Your computer says, "Okay, circuit number one received an electrical current, so that means one. Circuit Number two did not receive any current therefore, it must be zero........and circuit number seven received an electrical current so that means 1. Now, its 1, 0, 0, 0, 0, 0, 1. That means the user is trying to send me this code.

Hope you understood practically how computer work also.

===============================================================

2's Complement - Only applicable for binary representation.

Step 1. Convert into Binary
Step 2. Take 2's Complement

Binary Conversion
Step 1a. 45 = 101101
45/2 = 22 R -> 1
22/2 = 11 R -> 0
11/2 = 05 R -> 1
05/2 = 02 R -> 1
02/2 = 01 R -> 0
01/02= 00 R -> 1
reading upwards 101101

Step 1b. 0.75 = 0.11
0.75x2 = 1.50 C -> 1
0.50x2 = 1.00 C -> 1
reading downwards 0.11

45.75 = 101101.11

2's Complement (we need to know how many bits are used for representing the number)
For positive numbers, 2's complement is the same.
For negative numbers reverse all digits and add 1.
+45.75 = 0000101101.11 (12 bits for mantisa and 4 bits for exponent - just assuming !)
-45.75 = 1111010010.01


===============================================================

With 2's complement, only one set of instructions is needed to perform both signed and unsigned arithmetic.

For example, if you add 1011 to 0111, you'll get 0010 whether the numbers are interpreted as signed numbers (–5 plus 7) or unsigned (11 plus 7 is 18 with overflow).

If you use a sign-bit representation, that's –3 plus 7, and you'll need a different instruction to add them to get the right answer 4.

With 1's complement, a representation that was once used in some computers, only one set of instructions was needed, but there were two different representations of 0: positive 0 was all 0's, negative 0 was all 1's. That could be seen as a minor inconvenience although in some circumstances it can be a minor advantage.



Because it allows the same methods for performing addition, subtraction and multiplication for signed numbers as for unsigned numbers (and also the same circuitry? The same adder in the ALU can do both addition and subtraction) . If you use the sign-magnitude representation for representing signed numbers, you will need different set of rules for the basic arithmetic operations for signed numbers and also specialized circuitry.

===============================================================

Storing it as 2's compliment has many advantages.

If you use the same bit sequence with a prefixed sign bit, there will be 2 representations for zero : 00000000 and 10000000 (assuming integer is 8 bit).

Now that wastes 2 representations for the same value and you can store only (127x2 + 1 = ) 255 values.

But if you use 2's complement method, the same 8 bit integer can represent numbers from -128 to +127 which makes 256 possible values.

===============================================================
Advantages of Two’s Complement number system

Negative integers : 2's complement makes sense to be used for negative integers. 1's complement is just a computation technique which might be helpful to evaluate 2's complement. The real (defeated) rival of 2's complement was the sign-magnitude representation for negative integers.

No overflow : 1's complement has no special usage for negative integers. 2's complement makes sense because it can be used in natural addition and subtraction arithmetic without any need to change the bits. Providing that no overflow occurs, the sign bit of the result is just the right value. The bit number promotion in this notation is straight forward, for example, to promote an 8-bit signed integer to 16, we could simply repeat the sign bit of integer value in the high byte of it.

Sign magnitude : On the contrary, the sign-magnitude notation is just the way that human uses to represent negative integers. The bit number promotion and addition subtraction arithmetic is a bit mess with this notation.

The primary advantage of two's complement over one's complement is that two's complement only has one value for zero. One's complement has a "positive" zero and a "negative" zero.
Next, to add numbers using one's complement you have to first do binary addition, then add in an end-around carry value.
Two's complement has only one value for zero, and doesn't require carry values.



===============================================================
No, sign-magnitude is a way of representing a signed binary number with the use of its first (most significant) bit. Sign-magnitude has the problem of having both a positive and negative zero


===============================================================

The CPU “knows” you’re using a specific negative integer representation because that “knowledge” is built into the instructions that deal with these values (i.e., the add instructions, the subtract instructions, etc.). More specifically, it’s built into the hardware (or in some cases, it’s built into the microcode) that implements the specific instructions that might have to deal with negative integers.

Most modern mainstream CPUs are designed to use two’s complement representation for negative integer values, but during my lengthy career, I have run into a few CPUs and I/O devices that have used one’s complement (along with 6-bit bytes, 60-bit words, and other things now considered oddities). In a microcoded CPU, where sets of very low-level microinstructions implement the CPU instructions that developers would see, it’s possible to configure the CPU instructions to use a different negative representation (e.g., one’s complement) by changing the microcode.

The compiler and/or assembler you’re using needs to have the knowledge of the negative integer representation used in the target CPU, so that when you use a constant such as -42, the correct representation of that negative value is encoded properly.

For floating-point values, if you have an FPU (floating-point unit), the fact that you’re using IEEE 754 representation or some other representation is also built into the hardware’s floating-point instructions (or into the microcode that implements those instructions). If you don’t have an FPU (e.g., back in the days of the Intel i386, in a modern micrcontroller that has no hardware floating-point support, etc.), and floating point is completely implemented in software, then any representation might be chosen, theoretically.



===============================================================

The nice thing about this is if adding a normal integer to a 1’s or 2’s complement of another turns it into a subtraction instead. Thus there’s no extra hardware needed to make a subtraction, the normal addition can be used with just a toggling circuit to turn one of the numbers into a 1’s or 2’s complement.


===============================================================
A callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time 

In simple language, If a reference of a function is passed to another function as an argument to call it, then it will be called as a Callback function.

In C, a callback function is a function that is called through a function pointer.


// A simple C program to demonstrate callback 
#include<stdio.h> 
  
void A() 
{ 
    printf("I am function A\n"); 
} 
  
// callback function 
void B(void (*ptr)()) 
{ 
    (*ptr) (); // callback to A 
} 
  
int main() 
{ 
    void (*ptr)() = &A; 
      
    // calling function B and passing 
    // address of the function A as argument 
    B(ptr); 
  
   return 0; 
}



There is no "callback" in C - not more than any other generic programming concept.

They're implemented using function pointers. Here's an example:

void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}

int getNextRandomValue(void)
{
    return rand();
}

int main(void)
{
    int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);
    ...
}

Following are some interesting facts about function pointers.

 
1) Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code.
2) Unlike normal pointers, we do not allocate de-allocate memory using function pointers.
3) A function’s name can also be used to get functions’ address. 


For example, in the below program, we have removed address operator ‘&’ in assignment. We have also changed function call by removing *, the program still works.

#include <stdio.h> 
// A normal function with an int parameter 
// and void return type 
void fun(int a) 
{ 
    printf("Value of a is %d\n", a); 
} 
  
int main() 
{  
    void (*fun_ptr)(int) = fun;  // & removed 
  
    fun_ptr(10);  // * removed 
  
    return 0; 
}


4) Like normal pointers, we can have an array of function pointers. Below example in point 5 shows syntax for array of pointers.

 
5) Function pointer can be used in place of switch case. For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.

#include <stdio.h> 
void add(int a, int b) 
{ 
    printf("Addition is %d\n", a+b); 
} 
void subtract(int a, int b) 
{ 
    printf("Subtraction is %d\n", a-b); 
} 
void multiply(int a, int b) 
{ 
    printf("Multiplication is %d\n", a*b); 
} 
  
int main() 
{ 
    // fun_ptr_arr is an array of function pointers 
    void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; 
    unsigned int ch, a = 15, b = 10; 
  
    printf("Enter Choice: 0 for add, 1 for subtract and 2 "
            "for multiply\n"); 
    scanf("%d", &ch); 
  
    if (ch > 2) return 0; 
  
    (*fun_ptr_arr[ch])(a, b); 
  
    return 0; 
} 
Enter Choice: 0 for add, 1 for subtract and 2 for multiply
2
Multiplication is 150 


6) Like normal data pointers, a function pointer can be passed as an argument and can also be returned from a function.
For example, consider the following C program where wrapper() receives a void fun() as parameter and calls the passed function.

// A simple C program to show function pointers as parameter 
#include <stdio.h> 
  
// Two simple functions 
void fun1() { printf("Fun1\n"); } 
void fun2() { printf("Fun2\n"); } 
  
// A function that receives a simple function 
// as parameter and calls the function 
void wrapper(void (*fun)()) 
{ 
    fun(); 
} 
  
int main() 
{ 
    wrapper(fun1); 
    wrapper(fun2); 
    return 0; 
}
This point in particular is very useful in C. In C, we can use function pointers to avoid code redundancy. 
===============================================================
Q. Where are enum members stored in memory? How does the compiler generate code for enumerations? —  Ashwin Karanth

Enumerations are just named constants. For this reason, the initialisation value of enumerations should be “constant expressions”. A C/C++ compiler replaces them with their equivalent values during compilation. So enumerations don’t have any role to play when the program executes.

===============================================================

In your machine, maybe the sizes of int and long are the same. That need not be the case for all machines. Having two types, int and long, becomes very useful when these sizes are different.

===============================================================
The format %X is for printing an unsigned integer value in hexadecimal format. So, it should not be used for floating point values. We cannot predict the behaviour of the program if we do so. When I tried printf("%X", 1.1f);, the program received signal 8; the signal name is SIGFPE, which stands for
signal — floating point exception”.

===============================================================

In older versions of C, there was no ‘double’ — it was just ‘long float’ type — and that is the reason why it has the format specifier ‘%lf‘ (‘%d‘ was already in use to indicate signed decimal values). Later, double type was added to indicate that the floating point type might be of ‘double precision’ (IEEE format, 64-bit value). So a format specifier for long float and double was kept the same.

===============================================================

For example, in (a && b == c && d), == has higher precedence than &&. So it is interpreted as, (a && (b == c) && d)

===============================================================

The a.out stands for ‘assembler.output’ file

===============================================================

The network layer is where the term packet is used for the first time. Common protocols at this layer are IP (Internet Protocol), ICMP (Internet Control Message Protocol), IGMP (Internet Group Management Protocol) and IPsec (a protocol suite for securing IP). The transport layer’s protocols include TCP (Transmission Control Protocol), a connection-oriented protocol; UDP (User Datagram Protocol), a connection-less protocol; and SCTP (Stream Control Transmission Protocol), which has features of both TCP and UDP. The application layer has many protocols that are commonly used, like HTTP, FTP, IMAP, SMTP and more.


===============================================================

 int i = 90;
        printf("%f\n",sin(i));

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g -lm
[root@localhost rawat]# ./a.out 
0.893997
[root@localhost rawat]#

//here 90 is taken in radians not in degree
===============================================================
#include <stdlib.h>

       int rand(void);

       int rand_r(unsigned int *seedp);

       void srand(unsigned int seed);
The rand() function returns a pseudo-random integer in the  range
       0   to   RAND_MAX   inclusive   (i.e.,   the  mathematical  range
       [0, RAND_MAX]).

       The srand() function sets its argument as  the  seed  for  a  new
       sequence  of  pseudo-random  integers  to  be returned by rand().
       These sequences are repeatable by calling srand() with  the  same
       seed value.

       If  no  seed  value is provided, the rand() function is automati‐
       cally seeded with a value of 1.



#include <stdlib.h>

       long int random(void);

       void srandom(unsigned int seed);

       char *initstate(unsigned int seed, char *state, size_t n);
       char *setstate(char *state);



===============================================================
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:16:12: warning: format ‘%lu’ expects argument of type ‘long unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
          ~~^
xyz.c:16:15: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 3 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
              ~^
xyz.c:16:19: warning: format ‘%lf’ expects argument of type ‘double’, but argument 4 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
                 ~~^

===============================================================
xyz.c:17:17: warning: format ‘%d’ expects argument of type ‘int’, but argument 4 has type ‘double’ [-Wformat=]
  printf("%u %p %d\n",ptr,ptr,*ptr);
                ~^            ~~~~
                %f
===============================================================
xyz.c:17:12: warning: format ‘%lf’ expects argument of type ‘double’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%lf %p %f\n",ptr,ptr,*ptr);
          ~~^
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%x’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%x %p %f\n",ptr,ptr,*ptr);
          ~^
===============================================================
int main()
{

        double *ptr =(double*)100;
        printf("%p %f\n",ptr,*ptr);
        ptr=ptr+2;
        printf("%p %f\n",ptr,*ptr);

        return 0;
}

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 

===============================================================

        double *ptr =(double*)100;
        printf("%p \n",ptr);
        ptr=ptr+2;
        printf("%p \n",ptr);

[root@localhost rawat]# ./a.out 
0x64 
0x74 
[root@localhost rawat]# 

===============================================================

        double *ptr =(double*)100;
        printf("%u \n",ptr);
        ptr=ptr+2;
        printf("%u \n",ptr);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%u \n",ptr);
          ~^
xyz.c:17:11: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%u \n",ptr);
          ~^
[root@localhost rawat]# ./a.out 
100 
116 
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)3;
        int x;

        x= (a != b );
        x= (a & b);
        x= (a | b);

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:19:8: error: invalid operands to binary & (have ‘int *’ and ‘int *’)
  x= (a & b);
        ^
xyz.c:20:8: error: invalid operands to binary | (have ‘int *’ and ‘int *’)
  x= (a | b);
        ^
xyz.c:17:6: warning: variable ‘x’ set but not used [-Wunused-but-set-variable]
  int x;
      ^
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)3;

        int x;

        x= (a != b );
        printf("%d\n",x);
        return 0;


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)2;

        int x;

        x= (a != b );
        printf("%d\n",x);
        return 0;


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
0
[root@localhost rawat]# 


===============================================================

        char *s ="hello";
        char *p=s;

        printf("%c\t%c\t%c\n",*(p+1),*p+1,s[1]);


[root@localhost rawat]# ./a.out 
e	i	e
[root@localhost rawat]# 


===============================================================

        char *s ="hello";
        char *p=s+2;
        printf("%c\t%c\n",*p,s[1]);

[root@localhost rawat]# ./a.out 
l	e
[root@localhost rawat]# vim xyz.c 

===============================================================


        void *p;
        int a[4]={1,2,3,8};
        p = &a[3];

        int *ptr=&a[2];
        int n= p - ptr;

        printf("%d\n",n);


xyz.c: In function ‘main’:
xyz.c:18:11: error: invalid operands to binary - (have ‘void *’ and ‘int *’)
  int n= p - ptr;
           ^
===============================================================

        void *p;
        int a[4]={1,2,3,8};
        p = &a[3];

        int *ptr=&a[2];
        int n= p - ptr;

        printf("%d\n",n);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================

        int a[4]={1,2,3,8};
        int b[4]={1,2,3,8};

        int n=&b[3] - &a[2];

        printf("%d\n",n);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
-3
[root@localhost rawat]# 

//- indicate stack growing downwards...
//but why it gives 3 ...it has  4 integer elements in between.
// do analysis..

===============================================================

void foo(int *);
int main()
{
        int i=10;
        foo((&i)++);
}
void foo(int *p)
{
        printf("%d\n",*p);
}

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:10: error: lvalue required as increment operand
  foo((&i)++);
          ^~


===============================================================
void foo(int);
int main()
{
        int i=10;
        foo(i++);       
}
void foo(int p)
{
        printf("%d\n",p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
10


===============================================================


void foo(float *);
int main()
{
        int i=10, *p=&i;
        foo(&i);
}
void foo(float *p)
{
        printf("%f\n",*p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:6: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]
  foo(&i);
      ^
xyz.c:11:6: note: expected ‘float *’ but argument is of type ‘int *’
 void foo(float *);
      ^~~
xyz.c:14:13: warning: unused variable ‘p’ [-Wunused-variable]
  int i=10, *p=&i;
             ^
[root@localhost rawat]# ./a.out 
0.000000
[root@localhost rawat]# 

//here it is showing zero because the binary representation of integer 10 had different meaning for a float value...as float value are represented in binary by their own rule(mantissa part. exponential part) 


===============================================================


void foo(int**);
int main()
{
        int i=97, *p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int **p)
{
        int j=2;
        *p=&j;

        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
[root@localhost rawat]# 


===============================================================

void foo(int*const*);
int main()
{
        int i=11, *p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int *const*p)
{
        int j=10;
        *p=&j;
        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘foo’:
xyz.c:21:4: error: assignment of read-only location ‘*p’
  *p=&j;
    ^
[root@localhost rawat]# 

===============================================================


void foo(int**const);

int main()
{
        int i=10, *p=&i;
        foo(&p);
        printf("%d\n",*p);
        printf("%d\n",*p);
}

void foo(int **const p)
{
        int j=11;
        *p=&j;
        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
11
11
11

===============================================================

void foo(int**);
int main()
{
        int i=10, *const p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int **p)
{
        int j=11;
        *p=&j;
        printf("%d\n",**p);
}


xyz.c: In function ‘main’:
xyz.c:15:6: warning: passing argument 1 of ‘foo’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
  foo(&p);
      ^
xyz.c:11:6: note: expected ‘int **’ but argument is of type ‘int * const*’
 void foo(int**);
      ^~~
[root@localhost rawat]# ./a.out 
11
11
[root@localhost rawat]# 

===============================================================

//cross check it
structures and variables can be sent by call-by-value?
but not arrays

==============================================================

        const int ary[4]={1,2,3,4};
        int *p;
        p=ary+3;
        *p=5;
        printf("%d\n",ary[3]);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:3: warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
  p=ary+3;
   ^
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# ./a.out 
5
[root@localhost rawat]# 


===============================================================

int a[10]={};

//all elements are initialized to zero

===============================================================

        int s=5;
        int a[s]={1,2,3};

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:14:2: error: variable-sized object may not be initialized
  int a[s]={1,2,3};
  ^~~
xyz.c:14:12: warning: excess elements in array initializer
  int a[s]={1,2,3};
            ^
xyz.c:14:12: note: (near initialization for ‘a’)
xyz.c:14:14: warning: excess elements in array initializer
  int a[s]={1,2,3};
              ^
xyz.c:14:14: note: (near initialization for ‘a’)
xyz.c:14:16: warning: excess elements in array initializer
  int a[s]={1,2,3};
                ^
xyz.c:14:16: note: (near initialization for ‘a’)
xyz.c:14:6: warning: unused variable ‘a’ [-Wunused-variable]
  int a[s]={1,2,3};
      ^
[root@localhost rawat]# 


===============================================================

int *a1[8];
int *(a2[8]);

both are the array of pointers

==============================================================

we can declare a 3D array using pointer like this : char *a[][];

but declarations like ***ptr is a triple pointer..u cant say a 3D array (we know internally 3D array is implemented as ***ptr).

or declaration like **a[]..this is double pointer to an 1D array.

===============================================================

char *a={"p","r","o","g","r","a","m"};
printf("%s\n",a);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 
p
[root@localhost rawat]# 




===============================================================

        char *a={'p','r','o','g','r','a','m'};
        printf("%s\n",a);

see the warning ...and then at last output.

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:11: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  char *a={'p','r','o','g','r','a','m'};
           ^~~
xyz.c:13:11: note: (near initialization for ‘a’)
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
[root@localhost rawat]# 



[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 









===============================================================

char *a={'p','r','o','g','r','a','m'};
        printf("%c\n",a);

but we write %c : then it will give warning as %s expected
but it runs....

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:11: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  char *a={'p','r','o','g','r','a','m'};
           ^~~
xyz.c:13:11: note: (near initialization for ‘a’)
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
xyz.c:14:11: warning: format ‘%c’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%c\n",a);
          ~^
          %s




[root@localhost rawat]# ./a.out 
p
[root@localhost rawat]# 


===============================================================


char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *(a[i]) );
        }



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:17:12: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
   printf("%s\n", *(a[i]) );
           ~^     ~~~~~~~
           %d
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================

        char *a[10]={"hi", "Hello", "wow"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%c\n", *(a[i]) );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
h
H
w
Segmentation fault (core dumped)
[root@localhost rawat]# 






[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:17:12: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
   printf("%s\n", (*a)[i] );
           ~^     ~~~~~~~
           %d
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


===============================================================

char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *a+i );
        }



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hi
i

hello
ello
llo
lo
o

how
[root@localhost rawat]# 



===============================================================


 char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *(a+i) );
        }




[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hi
hello
how
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================


        char *a[10]={"hi", "Hello", "wow"};
        a[0]="bae";

        int i=0;
        for(i=0 ;i<10 ;i++)
        {
                printf("%s\n", a[i] );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
bae
Hello
wow
Segmentation fault (core dumped)
[root@localhost rawat]# 





        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        int i=0;
        for( i=0; i<10; i++)
        {
                printf("%s", a[i] );
        }

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hiHellooooooooooooooowow(null)(null)(null)(null)(null)(null)(null)[root@localhost rawat]# 








        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        int i=0;
        for( i=0; i<10; i++)
        {
                printf("%s\n", a[i] );
        }



[root@localhost rawat]# ./a.out 
hi
Hellooooooooooooooo
wow
Segmentation fault (core dumped)
[root@localhost rawat]# 




===============================================================


        char *a[10]={"hi", "Hello", "wow"};
        a[0]="bae";

        int i=0;
        for(i=0 ;i<10 ;i++)
        {
                printf("%s\n", *a+i );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
bae
ae
e




;0
;0
;0
[root@localhost rawat]#

===============================================================

        char *a[10]={"hi", "Hello", "wow"};
        printf("%d\n", sizeof(a) );



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
80
[root@localhost rawat]# 


here 10 elements of pointer type ...so it is 8*10=80
===============================================================
	
	
	char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        printf("%d\n", sizeof(a[0]) );
        printf("%d\n", sizeof(a[2]) );
        printf("%d\n", sizeof(a[4]) );
        printf("%d\n", sizeof(a[9]) );
 
	
	
	

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[0]) );
          ~^
          %ld
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[2]) );
          ~^
          %ld
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[4]) );
          ~^
          %ld
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[9]) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
8
8
8
8
[root@localhost rawat]# 



===============================================================



        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        printf("%d\n", sizeof(a[01]) );
        printf("%d\n", sizeof(a[20]) );
        printf("%d\n", sizeof(a[40]) );
        printf("%d\n", sizeof(a[111]) );


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[01]) );
          ~^
          %ld
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[20]) );
          ~^
          %ld
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[40]) );
          ~^
          %ld
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[111]) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
8
8
8
8
[root@localhost rawat]# 





===============================================================


        int i=2, j=9;
        int *a[]={&i, &j};

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
[root@localhost rawat]# 




===============================================================

        int i=2, j=9;
        int *a[]={&i, &j};

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);

        printf("------------------\n");

        printf("%d\n", *a[1]);
        printf("%d\n", (*a)[1]);



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
------------------
9
4195776
[root@localhost rawat]# 



===============================================================
%d expects int.
%x expects unsigned int
%ls expects int*



===============================================================

        int i=2, j=9, k=7;
        int *a[]={&i, &j, &k};

        printf("%p\t%p\t%p\n",&i,&j,&k);
        //printf("%ls\t%ls\t%ls\n",&i,&j,&k);//it is not printing
        printf("%d\t%d\t%d\n",&i,&j,&k);
        printf("------------------\n");

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);

        printf("------------------\n");

        printf("%d\n", *a[1]);
        printf("%d\n", (*a)[1]);

        printf("------------------\n");

        printf("%d\n", *a[2]);
        printf("%d\n", (*a)[2]);

[root@localhost rawat]# ./a.out 
0x7ffd515bf86c	0x7ffd515bf868	0x7ffd515bf864
1364981868	1364981864	1364981860
------------------
2
2
------------------
9
4195920
------------------
7
0
[root@localhost rawat]# 



===============================================================


int a[10][20];

"20*row + column" is the formula


===============================================================
char a[10][5] = { "hi","hello"," fellows"};
printf("%s",a[2]);


output: fello
===============================================================



        char a[10][7]={ "hi", "hello", "fellows"};
        printf("%ld \n",sizeof(a[1]));
        printf("%ld \n",sizeof(a));
        printf("%ld \n",sizeof(a[5]));
        printf("%ld \n",sizeof(a[6][1]));
        printf("%ld \n",sizeof(a[6]));




[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
7 
70 
7 
1 
7 
[root@localhost rawat]# 


===============================================================

        char a[1][5]={"hello"};
        printf("%s\n",a[0]);
        printf("%s",a[0]);
output will be hello+garbage ...because printf %s prints till null character

but if u make char a[1][6]... the 6th character will be \0...therefore it will print only hello   with out any garbage

===============================================================


        char a[2][5]={"hello","bye"};
        printf("%s\n", *a+1);
        printf("%s", *a+1);
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
ellobye
ellobye[root@localhost rawat]# 



===============================================================
        char a[2][6]={"hello","bye"};
        printf("%s\n", *a+1);
        printf("%s", *a+1);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
ello
ello[root@localhost rawat]# 




===============================================================


char *a[2]={"hello", "hi"};
printf("%s",*(a+1));


output: hi


===============================================================

int *a[]={{1,2,3},{4,5,6}};

this declaration will give warning ...extra elements

===============================================================

u can compare the function pointer 
u can return it also


===============================================================

use of FUNCTION POINTER: to call a function defined at runtime

===============================================================

int (*(*y)())[2];
y is pointer to a function which returns pointer to integer array

===============================================================

macros provide mechanism for token replacement

createdd with help of #define

they make program readable 

no overhead or jump in macrco asa it becomes part of your code

no type checking


#define CUBE (x) (x*x*x)
there must be space between macroName and arguments..also enclose macro in parenthesis

===============================================================

stringizing operator#
concatenation operator##


===============================================================

        union n
        {
                int a;
                float b;
                char c;
        };
        union n var={31999 , 45.95f , 'a'};

        printf("%d\n",var.a);
        printf("%f\n",var.b);
        printf("%c\n",var.c);

        return 0;

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:19:23: warning: excess elements in union initializer
  union n var={31999 , 45.95f , 'a'};
                       ^~~~~~
xyz.c:19:23: note: (near initialization for ‘var’)
xyz.c:19:32: warning: excess elements in union initializer
  union n var={31999 , 45.95f , 'a'};
                                ^~~
xyz.c:19:32: note: (near initialization for ‘var’)
[root@localhost rawat]# ./a.out 
31999
0.000000
�

// if u change value ,output will change behaviour..ie undefined

===============================================================

void (*(f)())(int, float);
typedef void (*(*x)())(int, float);

void foo(int i, float f);

int main()
{
        x=f;
        x();
}
void (*(f)())(int,float)
{
        return foo;
}

void foo(int i, float f)
{
        printf("%d %f\n",i,f);
}


xyz.c: In function ‘main’:
xyz.c:18:3: error: expected identifier or ‘(’ before ‘=’ token
  x=f;
   ^
xyz.c:19:4: error: expected identifier or ‘(’ before ‘)’ token
  x();
    ^

===============================================================

void (*(f)())(int, float);
typedef void (*(*x)())(int, float);

void foo(int i, float f);

int main()
{
        x p =f;
        p();
}
void (*(f)())(int,float)
{
        return foo;
}

void foo(int i, float f)
{
        printf("%d %f\n",i,f);
}


[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
[root@localhost rawat]# 

//no output, but it runs fine

===============================================================

int *(*ptr[3])();
ptr is array with 3 elements of pointer to function returning pointer of int

===============================================================

int* ((*x)())[2];

===============================================================
sizeof('a');
// it will be 4bytes because the a is a character but it is stored as an integer ascii value.

===============================================================
int a[10];
sizeof(a); 

//it will give size of aaray of 10 integers....40bytes


===============================================================
sizeof(void);
// on 32 bit machine it is 1byte

===============================================================

sizeof() return unsigned int values

we can use functions,pointers, macros inside the sizeof()...the result will depend upon thier return alue to sizeof().
===============================================================

#define PI 3.184
#define PIF 3.184f
#define PII 3
int main()
{
        printf("PI :%ld\n",sizeof(PI));
        printf("PI float:%ld\n",sizeof(PIF));
        printf("PI integer :%ld\n",sizeof(PII));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
PI :8
PI float:4
PI integer :4
[root@localhost rawat]# 


===============================================================

conditional compilation is the preprocessor facility to produce different executables codes for different platforms

===============================================================
preprocessors have compiler specific features...for ex: #pragma

===============================================================

#define foo(m,n) m * n = 10
so, u can write anything in #define preprocessor.
because preprocessor just replaces whatever is given compiler then checks for error at the replaced part of the code...
but if dont use that macro...so nothing will happen...

and it compiles fine...as preprocessor did nothing in the code.


===============================================================


#pragma exit is used for running a function upon exitting the program.

===============================================================

u must include #include<stdio.h> before the use of printf/scanf other wise it will give warning

but using it before main gives readability


===============================================================
<> angular brackets search file on standard paths and then current directory
it first look into C:compiler include , then in S:source headers, then in Current Directory where the program is saved

//confirm it once before speaking

===============================================================
#define foo(m,n) "m ## n"

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
m ## n



===============================================================

#define foo(m,n) m ## n

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:14:20: error: ‘kl’ undeclared (first use in this function)
  printf("%s\n",foo(k,l));
                    ^
xyz.c:9:18: note: in definition of macro ‘foo’
 #define foo(m,n) m ## n
                  ^
xyz.c:14:20: note: each undeclared identifier is reported only once for each function it appears in
  printf("%s\n",foo(k,l));
                    ^
xyz.c:9:18: note: in definition of macro ‘foo’
 #define foo(m,n) m ## n
                  ^
[root@localhost rawat]# 

===============================================================

#define foo(m,n) #m #n

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
kl
[root@localhost rawat]#

===============================================================


# define max 
#include <stdio.h>
int main()
{
        max;

        printf("hii\n");
        printf("%d\n",max);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:17:19: error: expected expression before ‘)’ token
  printf("%d\n",max);
                   ^
[root@localhost rawat]# 


===============================================================

# define max 
#include <stdio.h>
int main()
{
        max;

        printf("hii\n");
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii
[root@localhost rawat]# 

===============================================================

# define  A 1 + 2
# define  B 3 + 4

#include <stdio.h>

int main()
{


        printf("hii: %d\n" , (A*B) );
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii: 11
[root@localhost rawat]# vim xyz.c 



===============================================================

u cant #define a preprocessor

#define A #define
A VAL 30

// check it and confirm it....

===============================================================


#define max 30);
#include <stdio.h>

int main()
{


        printf("hii: %d\n" , max
}

//this works fine.....
===============================================================


#define max 30);
#include <stdio.h>

int main()
{
        printf("hii: %d\n" , max);
}
//it will be ERROR....

===============================================================

you cannot use the pointer to #define...

#define can  not be made externally available

they dont obey scope rules

===============================================================

function definations can be present in hearder files

===============================================================

#define max(m,n) m ## n
#include <stdio.h>

int main()
{


        printf("hii: %d\n" , max(2,3));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii: 23
[root@localhost rawat]# vim xyz.c 


===============================================================


#define max(m,n) "  m ## n "
#include <stdio.h>

int main()
{


        printf("hii: %s\n" , max(2,3));
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:17:16: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("hii: %d\n" , max(2,3));
               ~^
               %s
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii:   m ## n 
[root@localhost rawat]# 


===============================================================

#define IO_HEADER
#include IO_HEADER

these two lines are equivalent to : #include 
since IO_HEADER is replaced by   (nothing , empty)


===============================================================

#define c
#include <stdio.h>
int main()
{
        int a=2;

#ifdef c
        a=1;

        printf("%d",c);
}

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:19:15: error: expected expression before ‘)’ token
  printf("%d",c);
               ^
xyz.c:14:6: warning: variable ‘a’ set but not used [-Wunused-but-set-variable]
  int a=2;
      ^
xyz.c: At top level:
xyz.c:16:0: error: unterminated #ifdef
 #ifdef c
 
[root@localhost rawat]# 


===============================================================

#define c
#include <stdio.h>
int main()
{
        int a=2;

#ifdef c
        printf("COLD\t");
#undef c
#endif

#ifdef c
        printf("HOT\t");
#endif
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:14:6: warning: unused variable ‘a’ [-Wunused-variable]
  int a=2;
      ^
[root@localhost rawat]# ./a.out 
COLD	[root@localhost rawat]# 




===============================================================
u cant do consecutive
#if
#if
//try before u speak


===============================================================


#include <stdio.h>

#define MIN 0
#if defined(MIN) + define(MAX)
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:26: error: missing binary operator before token "("
 #if defined(MIN) + define(MAX)
                          ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in
[root@localhost rawat]# 


===============================================================

#include <stdio.h>

#define MIN 0
#if defined(MIN) - (!define(MAX))
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:28: error: missing binary operator before token "("
 #if defined(MIN) - (!define(MAX))
                            ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in

===============================================================

#include <stdio.h>

#define MIN 0
#ifdef(MIN)
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:7: error: macro names must be identifiers
 #ifdef(MIN)
       ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in


===============================================================

struct temp s;
struct temp{};
#include <stdio.h>

int main()
{
return 0;

}

..u can write structure variable before struture defination 


===============================================================

#include <stdio.h>
struct temp
{

        int no;
        char name[20];

};



int main()
{
        struct temp s;
        s.no=8;
        printf("hello\n");
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:21:1: error: expected ‘;’, identifier or ‘(’ before ‘int’
 int main()
 ^~~
xyz.c: In function ‘main’:
xyz.c:23:14: warning: variable ‘s’ set but not used [-Wunused-but-set-variable]
  struct temp s;
              ^

// structure declaration must end with semicolon(;)

===============================================================

#include <stdio.h>
struct temp
{

        int no;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        s.no=8;
        printf("hello %d %d\n",s.no,temp);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hello 8 99





===============================================================



#include <stdio.h>
struct temp
{

        int no;
        int age;
        float height;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
return 0;

}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %s %d\n",s.no,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:26:46: warning: ‘s.height’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
                                             ~^~~~~~~
xyz.c:26:2: warning: ‘s.age’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
xyz.c:26:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
[root@localhost rawat]# ./a.out 
hello 4195616 0 0.000000  99
[root@localhost rawat]# 


//so its warning to use uninitialized struture. and the character array is showing nothing.



#include <stdio.h>
struct temp
{

        int no;
        int age;
        float height;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        s.name[0]='s';
        printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
return 0;

}

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:27:46: warning: ‘s.height’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
                                             ~^~~~~~~
xyz.c:27:2: warning: ‘s.age’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
xyz.c:27:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
[root@localhost rawat]# ./a.out 
hello 4195616 0 0.000000 s 99

===============================================================

#include <stdio.h>
struct temp
{
        char name[20];
};

int temp=99;

int main()
{
        struct temp s;
        s.name="hello";
        printf("hello %s %d\n",s.name,temp);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:26:8: error: assignment to expression with array type
  s.name="hello";
        ^

===============================================================



#include <stdio.h>
struct temp t;
struct temp
{
        char *name;
};
struct temp func(void)
{
        t.name = "newton";
        printf("%s\n",t.name);
        t.name = "alan";
        return t;
}
/*
struct temp
{
        char *name;
};
*/
// if u will not put structure defination before its use so in above function it will show undefined data type t
int temp=99;

//struct temp t;
//if u will declare it here ..it will be error ,as this t will be undeclared in func()

int main()
{
        struct temp q=func();

        printf("%s\n",q.name);
        q.name = "turing";

        printf("%s\n",t.name);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
newton
alan
alan
[root@localhost rawat]# 

// so assigning one structure variable to another will make a seprate copy
// a seprate copy ... and changing one variavble will not effect other...as both have their own memeory

===============================================================

#include <stdio.h>
struct temp
{
        int a;
}s;
void func(struct temp)
{
        s.a=10;
        printf("%d \t",s.a);
}
int main()
{
        func(s);
        printf("%d\t",s.a);
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘func’:
xyz.c:15:18: error: parameter name omitted
 void func(struct temp)
                  ^~~~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>
struct temp
{
        int a;
}s;
void func(struct temp zz)
{
        s.a=10;
        printf("%d \t",s.a);
}
int main()
{
        func(s);
        printf("%d\t",s.a);
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘func’:
xyz.c:15:23: warning: unused parameter ‘zz’ [-Wunused-parameter]
 void func(struct temp zz)
                       ^~
[root@localhost rawat]# ./a.out 
10 	10	[root@localhost rawat]# 

===============================================================

xyz.c: In function ‘main’:
xyz.c:24:4: error: incompatible types when assigning to type ‘struct temp’ from type ‘struct temp *’
  s1=&s2;
    ^
===============================================================

#include <stdio.h>

struct temp
{
        char *a;
};

struct temp func(void)
{
        struct temp s;
        s.a="alan";
        return s;
}

int main()
{
        struct temp s1=func();
        s.a="turing";

        printf("%s\t",s1.a);

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:27:2: error: ‘s’ undeclared (first use in this function); did you mean ‘s1’?
  s.a="turing";
  ^
  s1
xyz.c:27:2: note: each undeclared identifier is reported only once for each function it appears in
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        int i;
        int j;
};

int main()
{
        struct temp t1={1};
        struct temp t2={1};
        if(t1==t2)
                printf("equal\n");
        else
                printf("not equal\n");

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘j’ of ‘struct temp’ [-Wmissing-field-initializers]
  struct temp t1={1};
         ^~~~
xyz.c:15:6: note: ‘j’ declared here
  int j;
      ^
xyz.c:21:9: warning: missing initializer for field ‘j’ of ‘struct temp’ [-Wmissing-field-initializers]
  struct temp t2={1};
         ^~~~
xyz.c:15:6: note: ‘j’ declared here
  int j;
      ^
xyz.c:22:7: error: invalid operands to binary == (have ‘struct temp’ and ‘struct temp’)
  if(t1==t2)
       ^~
[root@localhost rawat]# 


===============================================================

u cant assign one structure variable to different structure variable.
even though they have same kind of members

===============================================================


#include <stdio.h>
struct zemp
{
        int k;
        int d;
};

void foo(struct zemp*);

int main()
{
        struct zemp t2={1,5};
        foo(&t2);
        return 0;
}


void foo(struct zemp *p)
{
        printf("%d\n",*p.x++);
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:29:18: error: ‘p’ is a pointer; did you mean to use ‘->’?
  printf("%d\n",*p.x++);
                  ^
                  ->
xyz.c:27:23: warning: parameter ‘p’ set but not used [-Wunused-but-set-parameter]
 void foo(struct zemp *p)
                       ^
[root@localhost rawat]# 


===============================================================



#include <stdio.h>
struct student fun(void)
{
        struct student
        {
                char *name;
        };
        struct student s;
        s.name = "alan";
        return s;
}
int main()
{
        struct student m=fun();
        printf("%s",m.name);
returni 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:11:16: error: return type is an incomplete type
 struct student fun(void)
                ^~~
xyz.c: In function ‘fun’:
xyz.c:19:9: warning: ‘return’ with a value, in function returning void
  return s;
         ^
xyz.c:11:16: note: declared here
 struct student fun(void)
                ^~~
xyz.c: In function ‘main’:
xyz.c:23:9: error: variable ‘m’ has initializer but incomplete type
  struct student m=fun();
         ^~~~~~~
xyz.c:23:17: error: storage size of ‘m’ isn’t known
  struct student m=fun();
                 ^
xyz.c:25:1: error: ‘returni’ undeclared (first use in this function)
 returni 0;
 ^~~~~~~
xyz.c:25:1: note: each undeclared identifier is reported only once for each function it appears in
xyz.c:25:9: error: expected ‘;’ before numeric constant
 returni 0;
         ^
xyz.c:23:17: warning: unused variable ‘m’ [-Wunused-variable]
  struct student m=fun();
                 ^
[root@localhost rawat]# 


===============================================================

to receive array of strutures
void foo(struct *arr);


===============================================================


#include <stdio.h>
        struct student
        {
                char *name;
        };

struct student s[2], r[2];

int main()
{
        s[0].name="alan";
        s[1]=s[0];
        r=s;

        printf("%s %s",r[0].name,r[1].name);
return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:3: error: assignment to expression with array type
  r=s;
   ^
[root@localhost rawat]# 


===============================================================


#include <stdio.h>
        struct student
        {
                char *name;
        };

struct student s[2], r[2];

int main()
{
        s[1]=s[0]="alan";

        printf("%s %s",s[0].name,s[1].name);
return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:11: error: incompatible types when assigning to type ‘struct student’ from type ‘char *’
  s[1]=s[0]="alan";
           ^
[root@localhost rawat]# 


===============================================================

#include <stdio.h>
        struct student
        {
        };


int main()
{
        struct student s[2];
        struct student *sp;

        printf("sizeof(sp): %ld\n",sizeof(sp));
        printf("sizeof(s): %ld\n",sizeof(s));
        printf("sizeof(s[1]): %ld\n",sizeof(s[1]));

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
sizeof(sp): 8
sizeof(s): 0
sizeof(s[1]): 0
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        //struct point p1[]={1,2,3,4};//this is warning;see below
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d \n",p[1].x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:21:20: warning: missing braces around initializer [-Wmissing-braces]
  struct point p1[]={1,2,3,4};
                    ^
                     {  }{  }
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
3 
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d \n",p->x);

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 



===============================================================

#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",p->x,++p->x);

}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:24: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",p->x,++p->x);
                        ^~~~~~
[root@localhost rawat]# ./a.out 
2 2
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",++p->x,p->x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:19: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",++p->x,p->x);
                   ^~~~~~
[root@localhost rawat]# ./a.out 
101 100
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",p->x,++p->x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:24: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",p->x,++p->x);
                        ^~~~~~
[root@localhost rawat]# ./a.out 
101 101
[root@localhost rawat]# 



===============================================================
the .dot hashigher precedence then ->
and the -> operator has higher precedence then ++

//check the operator precedence
===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
}p[]={{100,200},{300,400}};

void foo(struct point*);
int main()
{
        foo(p);
}
void foo(struct point p[])
{
        printf("%d %d %d %d\n",p->x,p[0].y,p[2].x,p[2].y);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
100 200 0 0
[root@localhost rawat]#



===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d %d\n",p->x, p[2].x, p[2].y, p[3].y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# 

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 
100 500 0 0
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
xyz.c: In function ‘foo’:
xyz.c:25:35: error: ‘p + 16’ is a pointer; did you mean to use ‘->’?
  printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
                                   ^
                                   ->
xyz.c:25:45: error: ‘p + 16’ is a pointer; did you mean to use ‘->’?
  printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
                                             ^
                                             ->
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , (p+2)->x , (p+2)->y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# ./a.out 
100 500 0
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , ++(p+2)->x , ++(p+2)->y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# ./a.out 
100 501 1
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct point
{
        char *c;
};
int main()
{
        struct point p1[2];
        printf("%ld",sizeof(p1));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct point
{
        char *c;
};
int main()
{
        struct point p1[2];
        printf("%ld\n",sizeof(p1));
        printf("%ld\n",sizeof(p1[0]));
        printf("%ld\n",sizeof(p1+1));
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16
8
8
[root@localhost rawat]# 



===============================================================

xyz.c: In function ‘main’:
xyz.c:20:9: warning: excess elements in array initializer
  struct p p1[2]={1,92,3,94,5,96};
         ^
xyz.c:20:9: note: (near initialization for ‘p1’)
xyz.c:20:17: warning: missing braces around initializer [-Wmissing-braces]
  struct p p1[2]={1,92,3,94,5,96};
                 ^
                  {   }{   }{   }
[root@localhost rawat]# 



===============================================================



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:35: warning: excess elements in array initializer
  struct p p1[2]={{1,92} ,{3,94} , {5,96}};
                                   ^
xyz.c:20:35: note: (near initialization for ‘p1’)


===============================================================


#include <stdio.h>
struct p
{
        int x;
        char y;
};
typedef struct p*  q;
int main()
{
        struct p p1[]={{1,92} ,{3,94} , {5,96}};
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:17:21: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘*’ token
 typedef struct p*  q*;
                     ^
xyz.c: In function ‘main’:
xyz.c:21:2: error: unknown type name ‘q’
  q* ptr1 = p1;
  ^
xyz.c:21:12: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  q* ptr1 = p1;
            ^~
xyz.c:22:20: error: request for member ‘x’ in something not a structure or union
  printf("%d\n",ptr1->x);
                    ^~
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct p
{
        int x;
        char y;
};
void foo(struct p*);

int main()
{
        typedef struct p*  q;

        struct p p1[]={{1,92} ,{3,94} , {5,96}};

        foo(p1);

}

void foo(struct p* p1)
{
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:21:21: warning: typedef ‘q’ locally defined but not used [-Wunused-local-typedefs]
  typedef struct p*  q;
                     ^
xyz.c: In function ‘foo’:
xyz.c:31:2: error: unknown type name ‘q’
  q ptr1 = p1;
  ^
xyz.c:31:11: warning: initialization makes integer from pointer without a cast [-Wint-conversion]
  q ptr1 = p1;
           ^~
xyz.c:32:20: error: invalid type argument of ‘->’ (have ‘int’)
  printf("%d\n",ptr1->x);
                    ^~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

typedef struct p*  q;

struct p
{
        int x;
        char y;
};
void foo(struct p*);

int main()
{

        struct p p1[]={{1,92} ,{3,94} , {5,96}};

        foo(p1);

}

void foo(struct p* p1)
{
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}


[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 




===============================================================

pointer to structure
struct temp
{
	int b;
}*my_struct;

these way u can access
(*my_struct).b=10;
my_struct->b=10;

but not this way: *my_struct.b=10;

===============================================================

func(&s.a);
func(&(s).a);
func(&(s.a));
are the correct way to for pass by reference a member of a structure in a function

===============================================================


#include <stdio.h>

struct temp
{
        int a;
}s;

void change(struct temp);

int main()
{
        s.a=10;
        change(s);
        printf("%d\n",s.a);
}

void change(struct temp s)
{
        s.a=1;
}

[root@localhost rawat]# ./a.out 
10



===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{

        struct temp *s;
        s->c="hello";

        printf("%s\n",s->c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: warning: ‘s’ is used uninitialized in this function [-Wuninitialized]
  s->c="hello";
  ~~~~^~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *(s).c="hello";

        printf("%s\n",m.c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *(s).c="hello";
      ^
      ->
xyz.c:21:15: warning: variable ‘s’ set but not used [-Wunused-but-set-variable]
  struct temp *s=&m;
               ^


===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *s->c="hello";
        printf("%s\n",m.c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:7: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *s->c="hello";
       ^
[root@localhost rawat]# ./a.out 
�
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        s->c="hello";
        printf("%s\n",m.c);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hello
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        (*s).c="hello";
        printf("%p %p\n",s,&m);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
0x7fff77303750 
0x7fff77303750 
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *s.c="hello";
        printf("%p \n%p \n",s,&m);
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:4: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *s.c="hello";
    ^
    ->
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *(s).c="hello";
        printf("%p \n%p \n",s,&m);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *(s).c="hello";
      ^
      ->
[root@localhost rawat]# 


===============================================================


#include <stdio.h>
struct temp
{
        char *c;
        struct temp t;
};
int main()
{
        struct temp m1,m2;
        struct temp *s=&m1;

        struct temp *s2=m2;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:15:14: error: field ‘t’ has incomplete type
  struct temp t;
              ^
xyz.c: In function ‘main’:
xyz.c:24:18: error: incompatible types when initializing type ‘struct temp *’ using type ‘struct temp’
  struct temp *s2=m2;
                  ^~
xyz.c:24:15: warning: unused variable ‘s2’ [-Wunused-variable]
  struct temp *s2=m2;
               ^~
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
[root@localhost rawat]# 


===============================================================

self referencial struture are those who have pointer to itself as its member

but if u have a normal variable inside the structure of the same structure type ...it will be error....as shown above.



===============================================================


struct temp
{
        char *c;
        struct temp *t;
};


int main()
{
        struct temp m1;
        struct temp *s=&m1;

        printf("%ld\n",sizeof(temp));
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:24: error: ‘temp’ undeclared (first use in this function)
  printf("%ld\n",sizeof(temp));
                        ^~~~
xyz.c:24:24: note: each undeclared identifier is reported only once for each function it appears in
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
===============================================================



#include <stdio.h>

struct temp
{
        char *c;
        struct temp *t;
};


int main()
{
        struct temp m1;
        struct temp *s=&m1;

        printf("%ld\n",sizeof(struct temp));
        //printf("%ld\n",sizeof(temp));
        printf("%ld\n",sizeof(m1));
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
[root@localhost rawat]# ./a.out 
16
16
[root@localhost rawat]# 



===============================================================

#include <stdio.h>

struct p
{
        int x;
        char y;
        struct p *ptr;
};

int main()
{
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->x);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 
[root@localhost rawat]# 



===============================================================



#include <stdio.h>
typedef struct p *q;
int main()
{
        struct p
        {
                int x;
                char y;
                q ptr;
        };
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:18: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  struct p p={1,2,&p};
                  ^
xyz.c:24:18: note: (near initialization for ‘p.ptr’)
xyz.c:25:22: error: dereferencing pointer to incomplete type ‘struct p’
  printf("%d \n",p.ptr->x);
                      ^~
[root@localhost rawat]# 



===============================================================


#include <stdio.h>
typedef struct p *q;
        struct p
        {
                int x;
                char y;
                q ptr;
        };
int main()
{
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 
[root@localhost rawat]# 


===============================================================

#include <stdio.h>
typedef struct p *q;
int main()
{
        struct p
        {
                int x;
                char y;
                q ptr;
        };
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:18: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  struct p p={1,2,&p};
                  ^
xyz.c:20:18: note: (near initialization for ‘p.ptr’)
xyz.c:21:22: error: dereferencing pointer to incomplete type ‘struct p’
  printf("%d \n",p.ptr->ptr->x);
                      ^~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p;
        p->name = "xyz";
        p->next = NULL;
        ptrary[0] = &p;

        printf("%s \n",p->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:3: error: invalid type argument of ‘->’ (have ‘struct p’)
  p->name = "xyz";
   ^~
xyz.c:23:3: error: invalid type argument of ‘->’ (have ‘struct p’)
  p->next = NULL;
   ^~
xyz.c:26:18: error: invalid type argument of ‘->’ (have ‘struct p’)
  printf("%s \n",p->name);
                  ^~
[root@localhost rawat]# 


===============================================================



#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p;
        p.name = "xyz";
        p.next = NULL;
        ptrary[0] = &p;

        printf("%s \n",p.name);
        printf("%s \n",ptrary[0]->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
xyz 
xyz 
[root@localhost rawat]# 



===============================================================

#include <string.h>
#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p,q;

        p.name = "xyz";
        p.next = NULL;

        ptrary[0] = &p;

        strcpy(q.name,p.name);

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->name);

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:28:2: warning: ‘q.name’ is used uninitialized in this function [-Wuninitialized]
  strcpy(q.name,p.name);
  ^~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


//segfault inside strcpy();

===============================================================

#include <string.h>
#include <stdio.h>

int main()
{
        struct p
        {
                char *name;
                struct p *next;
        };

        struct p *ptrary[10];

        struct p p,q;

        p.name = "xyz";
        p.next = NULL;

        ptrary[0] = &p;

        strcpy(q.name,p.name);

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->name);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:30:2: warning: ‘q.name’ is used uninitialized in this function [-Wuninitialized]
  strcpy(q.name,p.name);
  ^~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================


#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main()
{
        struct p
        {
                char *name;
                struct p *next;
        };

        struct p *ptrary[10];

        struct p p,q;

        p.name = "xyz";
        p.next = NULL;


        ptrary[0] = &p;

        q.name=(char*)malloc(sizeof(char)*3);

        strcpy(q.name,p.name);

        q.next=&q;

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->next->next->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
xyz 
[root@localhost rawat]# 

===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        char a[];
}

int main()
{
        struct student s;
        printf("%d \n",sizeof(struct student));
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:15:7: error: flexible array member in a struct with no named members
  char a[];
       ^
xyz.c:18:1: error: expected ‘;’, identifier or ‘(’ before ‘int’
 int main()
 ^~~
xyz.c: In function ‘main’:
xyz.c:21:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d \n",sizeof(struct student));
          ~^
          %ld
xyz.c:20:17: warning: unused variable ‘s’ [-Wunused-variable]
  struct student s;
                 ^
[root@localhost rawat]# 


===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
struct student
{
        int i;
        char a[];

};
int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
4 
[root@localhost rawat]# 

===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        int i;
        char b[10];
        char a[];

};

int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16 
[root@localhost rawat]# 

===============================================================


#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        int i;
        char a[];
        char b[10];

};

int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:16:7: error: flexible array member not at end of struct
  char a[];
       ^
[root@localhost rawat]# 




===============================================================

typedef int (*PFI)(char *, char *)

type PFI , for pointer to funciton of two char* arguments returning int


===============================================================

-)
deletion and insertion are difficult and need movemnts in array 
but in liked list no movement of nodes is required

-)
in array space is wasted upon deletion but not in linked list

-)
array cant be reduced and extended as per conditions but linked list can be.

-)
in array to avail each element same amount of time is required
but in linkd list, to avail each element differnet amount of time is required.

-)
in consequtive memory locations elements are stored in array
but in linked list , elements may or may not be stored in consequitive memory locations

-)
we can access element directly in array,but to reach a particular node we have to traverse every node.

-)
array need to know size in advance but not in LL

===============================================================
application of LL
used to implement queues, stack, graphs,
you dont need to know the size of LL


===============================================================
if it is circular link list so
move a pointer by 1 position
and another pointer by 2 positions
....so after a time both will meet...(not necessarily in one time..but after looping again and again.)

===============================================================
finding mid of LL

method 1 : traverse to end and count...and then count/2
method 2 : move a slow pointer by 1 position and a fast pointer by 2 positions. so when fast reaches end(NULL), the slow will be at mid.


===============================================================
we can flatten a LL
and LL should be the linked list of linked list
ie... every linked list nodes pointing to other linked list

so we can flatten them into a single linked list as per some given condition ...ascending/descending order



===============================================================
find Nth node from the end

-)
(len -Nth +1) will tell you how many postions to move from head

-)
take two pointer "ref" and "main" pointing to head initially

first, move ref pointer to the 'n' nodes from head
now, move both pointers till ref pointer reaches the end.

Now, the main pointer will point to the Nth node from end

===============================================================
display/read LL in reverse(from end)

-)
use recursion and then go end and then display

===============================================================
to count the number of occurences 

-)
traverse LL and if the node is the key , increment the count


===============================================================
to find duplicate

-)
move one pinter one by one
but make other pointer to move whole linked list while first moves by one node
and keep matching if any other node is found 

 (so the second pointer traverse LL from position of first pointer  till the duplicate is found. if not found increment the first pointer ...and second pointer will traverse from position pointed b first pointer till the duplicate if found...this goes so on...till the dupilcate is found ot the first pointer reaches end)

===============================================================
reverse a linked list

void rev(struct node **head)
{
	struct node *p,*q,*r;
	p=q=r=*head;
	p=p->next->next;
	
	q=q->next;
	r->next=NULL;
	q->next=r;

	while(p!=NULL)
	{
		r=q;
		q=p;
		p=p->next;
		q->next=r;
	}
	
	*head=q;
}

basically we chanegd the starting as it would have been if it was the end
and in loop we made the pointer point to previous node 
===============================================================
interchanging two adjacent nodes in circular linked list
===============================================================
palindrome

to check if LL is palindrome
bring one pointer at mid and keep one pointer at begin
now loop till size/2
increase the front pointer and the mid pointer...and check


===============================================================

doubly linked list 
 each node have two links to next nad previous
 and the begin/end nodes pointer previous/next  have null ...since it is linear


===============================================================
doubly LL using Single LL

make a singly LL . now use two pointers current and begin
 to go forward move the current ahead..to go backward bring begin one previous to current pointer

( so a single LL with two pointers one moving forward and other at/moving one previous to the current ...so that u can go to any direction ) 


===============================================================
implementing Stack using LL

look the concept is to create LL and perform operations
as per stack.

( so if u want to delete ... make a hard code that when use r ask to delete ...a functions is called and delete will happen only at the end of LL
similalry if user wants to insert ..make it hard coded that insert will happen in the end only )

===============================================================
implement queue using LL

make the hardcode that insert will happen at the last node
and deleteion from head node


===============================================================

binary tree using linked list

binary search tree is a binary tree in which each internal node x stores an element such that the element stored in the left subtree of x are less than or equal to x and elements stored in the right subtree of x are greater than or equal to x. this is called binary search tree property

===============================================================



