
Compiler converts a C program into an executable. There are four phases for a C program to become an executable:
Pre-processing
Compilation
Assembly
Linking

gcc options:
-save-temps              Do not delete intermediate files.
-time                    Time the execution of each subprocess
-E                       Preprocess only; do not compile, assemble or link.
-S                       Compile only; do not assemble or link.
-c                       Compile and assemble, but do not link.
-shared                  Create a shared library.
-o <file>                Place the output into <file>.
-Xassembler <arg>        Pass <arg> on to the assembler.
-Xpreprocessor <arg>     Pass <arg> on to the preprocessor.
-Xlinker <arg>           Pass <arg> on to the linker.

-Wfloat-equal
Directly comparing floats is a bad idea. If you execute:
float a=0.2f, b=0.2f;
if(a + b != 0.4)
printf("Not equal");
You will get the output Not equal. This is because of precision issues. This can be caught by the compiler by using -Wfloat-equal flag. I will soon write a post explaining this behavior, and how to tackle it. For now, just understand it is bad.

-std=XXX
Set a language standard. Very useful when you strictly want features from a particular standard. For example,
-std=c++14
-std=c++17
-std=c99

-I
gcc -Iexample_dir_name example.c
By default, gcc looks in the current working directory. You can also include multiple other directory locations with -I flag.

-D
gcc -Dmacro_name=definition
Define a macro with a value. This is helpful when you want to run the same code in multiple ways such that the code depends on that macro, or maybe for debugging.

For a (very long) list of other such flags, refer to the manpage of gcc (man gcc).

------------------------------------------------------------------------

invoke the linker with a flag such as the gcc -fno-common flag, which triggers an error if it encounters multiple defined global symbols.


the final phase in which all the linking of function calls with their definitions are done. Linker knows where all these functions are implemented. Linker does some extra work also, it adds some extra code to our program which is required when the program starts and ends.

For example, there is a code which is required for setting up the environment like passing command line arguments. This task can be easily verified by using $size filename.o and $size filename. Through these commands, we know that how output file increases from an object file to an executable file. This is because of the extra code that linker adds with our program.



compilers are platform dependent.“Compilers turns the high level language to binary language or machine code(its compiler not he compiling staage which converts .i to .s) at only time once”.


------------------------------------------------------------------------
interpreter occupies less memory.Compilers usually generate an intermediate code called object code, during the compilation process. Hence it requires more memory than interpreters. Unlike compilers, interpreters do not generate any intermediate code, during the interpretation process. Thus, interpreters are memory efficient
Also, a compiler saves the machine codes for future use permanently but an interpreter doesn’t, but an interpreter occupies less memory.

------------------------------------------------------------------------

Linker is a program that holds one or more object files which is created by compiler, combines them into one executable file.

Linking is implemented  at both time,load time and compile time. Compile time is when high level language is turns to machine code and load time is when the code is loaded into the memory by loader.

Linker is of two types:

1.Dynamic Linker: implemented during run time. requires less memory. error and failure chances. stored the program in virtual memory to save RAM,So we have need to shared library

2.Static Linker: implemented during compilation of source program.requires more memory. faster and portable. less chances to error and No chances to failure.

------------------------------------------------------------------------

Loader is a program that loads machine codes of a program into the system memory.
It is part of the OS of the computer that is responsible for loading the program. 
It is the bare beginning of the execution of a program. 
Loading a program involves reading the contents of executable file( executable file is executable code ,which linker makes as an output  ) into memory. Only after the program is loaded the operating system starts the program by passing control to the loaded program code. All the OS that support loading have loader and many have loaders permanently in their memory.

------------------------------------------------------------------------

compiler_alignment:
Object File Alignment, Section Alignment, Page Alignment

The stack is also memory. The system programmer should load the stack pointer with a memory address that is properly aligned. Generally, the processor won’t check stack alignment, it is the programmer’s responsibility to ensure proper alignment of stack memory. Any misalignment will cause run time surprises.

For example, if the processor word length is 32 bit, stack pointer also should be aligned to be multiple of 4 bytes.

If char data is placed in a bank other bank 0, it will be placed on wrong data lines during memory read. How the processor handles char type?

Usually, the processor will recognize the data type based on instruction.
Depending on the bank it is stored, the processor shifts the byte onto least significant data lines.

When arguments passed on stack, are they subjected to alignment?
Yes. The compiler helps programmer in making proper alignment. For example, if a 16-bit value is pushed onto a 32-bit wide stack, the value is automatically padded with zeros out to 32 bits. Consider the following program.
void argument_alignment_check( char c1, char c2 )
{
   // Considering downward stack
   // (on upward stack the output will be negative)
   printf("Displacement %d\n", (int)&c2 - (int)&c1);
}
The output will be 4 on a 32 bit machine. It is because each character occupies 4 bytes due to alignment requirements.

What will happen if we try to access a misaligned data?
It depends on processor architecture. If the access is misaligned, the processor automatically issues sufficient memory read cycles and packs the data properly onto the data bus. The penalty is on performance. Where as few processors will not have last two address lines, which means there is no-way to access odd byte boundary. Every data access must be aligned (4 bytes) properly. A misaligned access is critical exception on such processors. If the exception is ignored, read data will be incorrect and hence the results.

Is there any way to query alignment requirements of a data type?

------------------------------------------------------------------------

How Linkers Resolve Global Symbols Defined at Multiple Places?

At compile time, the compiler exports each global symbol to the assembler as either strong or weak, and the assembler encodes this information implicitly in the symbol table of the relocatable object file.

Functions and initialized global variables get strong symbols. Uninitialized global variables get weak symbols.

Given this notion of strong and weak symbols, Unix linkers use the following rules for dealing with multiple defined symbols:

Rule 1: Multiple strong symbols (with same variable name) are not allowed.
Rule 2: Given a strong symbol and multiple weak symbols, choose the strong symbol.
Rule 3: Given multiple weak symbols, choose any of the weak symbols.

For example, suppose we attempt to compile and link the following two C modules:

/* foo1.c */
int main()
{
  return 0;
}

/* bar1.c */
int main()
{
  return 0;
}
In this case, the linker will generate an error message because the strong symbol main is defined multiple times (rule 1):multiple definition of ‘main’.

Similarly, the linker will generate an error message for the following modules because the strong symbol x is defined twice (rule 1):

/* foo2.c */
int x = 15213;
int main()
{
  return 0;
}

/* bar2.c */
int x = 15213;
void f()
{
}

However, if x is uninitialized in one module, then the linker will quietly choose the strong symbol defined in the other (rule 2) as is the case in following program:

/* foo3.c */
#include <stdio.h>
void f(void);
int x = 15213;
int main()
{
  f();
  printf("x = %d\n", x);
  return 0;
}

/* bar3.c */
int x;
void f()
{
  x = 15212;
}
At run time, function f() changes the value of x from 15213 to 15212, which might come as a unwelcome surprise to the author of function main! Notice that the linker normally gives no indication that it has detected multiple definitions of x.

$ gcc -o gfg foo3.c bar3.c
$ ./gfg
x = 15212

The same thing can happen if there are two weak definitions of x (rule 3):

/*a.c*/
#include <stdio.h>
void b(void);

int x;
int main()
{
    x = 2016;
    b();
    printf("x = %d ",x);
    return 0;
}
/*b.c*/
#include <stdio.h>

int x;

void b()
{
    x = 2017;

}


The application of rules 2 and 3 can introduce some insidious run-time bugs that are incomprehensible to the unwary programmer, especially if the duplicate symbol definitions have different types.

Example : “x” is defined as an int in one module and a double in another.

/*a.c*/
#include <stdio.h>
void b(void);

int x = 2016;
int y = 2017;
int main()
{
    b();
    printf("x = 0x%x y = 0x%x \n", x, y);
    return 0;
}
/*b.c*/
double x;

void b()
{
    x = -0.0;
}
$ gcc a.c b.c -o geeksforgeeks
$ ./geeksforgeeks
x = 0x0 y = 0x80000000

This is a subtle and nasty bug, especially because it occurs silently, with no warning from the compilation system, and because it typically manifests itself much later in the execution of the program, far away from where the error occurred. 
In a large system with hundreds of modules, a bug of this kind is extremely hard to fix, especially because many programmers are not aware of how linkers work. 
When in doubt, invoke the linker with a flag such as the gcc -fno-common flag, which triggers an error if it encounters multiple defined global symbols.

------------------------------------------------------------------------

These are two important header files used in C programming. While “<stdio.h>” is header file for Standard Input Output, “<stdlib.h>” is header file for Standard Library.

It should be noted that a header file can contain not only function declaration but definition of constants and variables as well. Even macros and definition of new data types can also be added in a header file.

math.h header file must be linked with -lm option.

------------------------------------------------------------------------

There are many different ways to make the variable as constant
The const keyword specifies that a variable or object value is constant and can’t be modified at the compilation time.
    const int num = 1;
    num = 5; //ERROR:assignment of readonly variable 


Runtime vs. compile-time
A compile-time constant is a value that can be (and is) computed at compile-time. A runtime constant is a value that is computed only while the program is running. If you run the same program more than once:
A compile-time constant will have the same value each time the application is run.
A runtime constant can have a different value each time the application is run.

There are a few cases where runtime constants just won't do and compile-time constants will be required. Knowing what these cases are will save you a lot of trouble. Even if you declare a variable as constant, if you initialize it only at runtime you can't use it for:
Array bounds
Case expressions
Bit-field lengths
Enumerator initializers
Integral or enumeration nontype template arguments


Must processor get constant variable's value from memory every time it is used. But if constant variables can't be changed, compiler can replace them with their values, can't it ?
It depends, as there are two types of constants:
Compile-time constants (const variables which are initialized at compilation time, or constexpr variables).
Run-time constants (which are things like arguments that are marked as const).
For the first type (compile-time constants) the compiler can indeed "replace" the variables with the actual values, and that's what all major compilers will do.
For the second type, it's not possible since the values aren't known until run-time.

------------------------------------------------------------------------


Enumeration :used to assign names to integral constants, that make a program easy to read and maintain . int, char, long etc. but it can't be float, double or user defined data type.


------------------------------------------------------------------------

Using Macros: We can also use Macros to define constant, but there is a catch,
#define var 5
Since Macros are handled by the pre-processor(the pre-processor does text replacement in our source file, replacing all occurrences of ‘var’ with the literal 5) not by the compiler.

Literals are the constant values assigned to the constant variables. We can say that the literals represent the fixed values that cannot be modified. It also contains memory but does not have references as variables. For example, const int =10; is a constant integer expression in which 10 is an integer literal.

Hence it wouldn’t be recommended because Macros doesn’t carry type checking information and also prone to error.

 In fact not quite constant as ‘var’ can be redefined like this,
#define var 5
#ifdef var
	#undef var
	#define var 10
#endif

preprocessor work as literal constant, enum work as integer constant.
they basically define symbolic name of the constant.

therefore , use 'const' keyword in C.


------------------------------------------------------------------------

Why variable name does not start with numbers in C ?

In C, apart from keywords everything in the C program is treated as Identifier.
Identifier can be the names given to variables, constants, functions and user-defined data. A variable name can consist of alphabets (upper case, lower case), numbers (0-9) and _ (underscore) character. But the name of any variable must not start with a number.
Now we must have the answer that why can’t we name a variable starting with number. Following might be the reason for it. The compiler has 7 phase as fellows:

    Lexical Analysis
    Syntax Analysis
    Semantic Analysis
    Intermediate Code Generation
    Code Optimization
    Code Generation
    Symbol Table

Backtracking is avoided in lexical analysis phase while compiling the piece of code. The variable like Apple; , the compiler will know its a identifier right away when it meets letter ‘A’ character in the lexical Analysis phase. However, a variable like 123apple; , compiler won’t be able to decide if its a number or identifier until it hits ‘a’ and it needs backtracking to go in the lexical analysis phase to identify that it is a variable. But it is not supported in compiler.

When you’re parsing the token you only have to look at the first character to determine if it’s an identifier or literal and then send it to the correct function for processing. So that’s a performance optimization.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++  AYUSH +++++++++++++++++++++++++++++++

/*
        gcc a.c f.c
        gcc a.c f.c -Wall -Wextra
        gcc a.c f.c -fno-common
*/
//a.c
#include<stdio.h>
int x;
void f();
int y=100;
int main()
{
        printf("before x=%d, y=%d\n",x,y);
        f();
        printf("after x=%d, y=%d\n",x,y);
return 0;
}

//f.c
#include<stdio.h>
int y;
int x;
void f()
{
        printf("f():before x=%d, y=%d\n",x,y);
        x=10;
        y=1000;
}
yes the rules mentioned above for weak and strong symbols works.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

shared libraries (called as Dynamic Linked Libraries or DLL in short)

The tool-set that is used to create these libraries need to understand the binary format. 
Linux variants follow a format called Executable and Linkable Format (ELF). 

The ELF files are position independent (PIC) format.
 Shared libraries in Linux are referred as shared objects (generally with extension *.so). 
These are similar to DLLs in Windows platform. Even shared object files follow the ELF binary format.

When you link your application against static library, the code is part of your application. There is no dependency. Even though it causes the application size to increase, it has its own advantages.The primary one is speed as there will be no symbol (a program entity) resolution at runtime. Since every piece of code part of the binary image, such applications are independent of version mismatch issues. However, the cost is on fixing an issue in library code. If there is any bug in library code, entire application need to be recompiled and shipped to the client. 

In case of dynamic libraries, fixing or upgrading the libraries is easy. You just need to ship the updated shared libraries. The application need not to recompile, it only need to re-run. You can design a mechanism where we don’t need to restart the application.

When we link an application against a shared library, the linker leaves some stubs (unresolved symbols) to be filled at application loading time. These stubs need to be filled by a tool called, dynamic linker at run time or at application loading time. Again loading of a library is of two types, static loading and dynamic loading. Don’t confuse between static loading vs static linking and dynamic loading vs dynamic linking.

In static loading, all of those dependent shared libraries are loaded into memory even before the application starts execution. If loading of any shared library fails, the application won’t run.

A dynamic loader examines application’s dependency on shared libraries. If these libraries are already loaded into the memory, the library address space is mapped to application virtual address space (VAS) and the dynamic linker does relocation of unresolved symbols.

If these libraries are not loaded into memory (perhaps your application might be first to invoke the shared library), the loader searches in standard library paths and loads them into memory, then maps and resolves symbols. Again loading is big process, if you are interested write your own loader :).

While resolving the symbols, if the dynamic linker not able to find any symbol (may be due to older version of shared library), the application can’t be started.

Dynamic Loading:
As the name indicates, dynamic loading is about loading of library on demand.
For example, if you want a small functionality from a shared library. Why should it be loaded at the application load time and sit in the memory? You can invoke loading of these shared libraries dynamically when you need their functionality. 
This is called dynamic loading. In this case, the programmer aware of situation ‘when should the library be loaded’. The tool-set and relevant kernel provides API to support dynamic loading, and querying of symbols in the shared library.

One of the main tasks for linker is to make code of library functions (eg printf(), scanf(), sqrt(), ..etc) available to your program. A linker can accomplish this task in two ways, by copying the code of library function to your object code, or by making some arrangements so that the complete code of library functions is not copied, but made available at run-time.

Following are some important points about static libraries.
1. For a static library, the actual code is extracted from the library by the linker and used to build the final executable at the point you compile/build your application.
2. Each process gets its own copy of the code and data. Where as in case of dynamic libraries it is only code shared, data is specific to each process. For static libraries memory footprints are larger. For example, if all the window system tools were statically linked, several tens of megabytes of RAM would be wasted for a typical user, and the user would be slowed down by a lot of paging.

3. Since library code is connected at compile time, the final executable has no dependencies on the library at run time i.e. no additional run-time loading costs, it means that you don’t need to carry along a copy of the library that is being used and you have everything under your control and there is no dependency.

4. In static libraries, once everything is bundled into your application, you don’t have to worry that the client will have the right library (and version) available on their system.

5. One drawback of static libraries is, for any change(up-gradation) in the static libraries, you have to recompile the main program every time.

6. One major advantage of static libraries being preferred even now “is speed”. There will be no dynamic querying of symbols in static libraries. Many production line software use static libraries even today.

Dynamic linking and Dynamic Libraries :
Dynamic Linking doesn’t require the code to be copied, it is done by just placing name of the library in the binary file. The actual linking happens when the program is run, when both the binary file and the library are in memory. Examples of Dynamic libraries (libraries which are linked at run-time) are, .so in Linux 


------------------------------------------------------------------------

1) Pointer to variable.
int *ptr;

2) Pointer to constant:
const int *ptr;
or
int const *ptr;

3) Constant pointer to variable.
int *const ptr;

4) constant pointer to constant
const int *const ptr;

There can be any types of constants like integer, float, octal, hexadecimal, character constants etc. Every constant has some range.

Const Qualifier in C
The qualifier const can be applied to the declaration of any variable to specify that its value will not be changed ( Which depends upon where const variables are stored, we may change the value of const variable by using pointer ). The result is implementation-defined if an attempt is made to change a const.

1) Pointer to variable.
int *ptr;
We can change the value of ptr and we can also change the value of object ptr pointing to. Pointer and value pointed by pointer both are stored in the read-write area.

2) Pointer to constant:
We can change the pointer to point to any other integer variable, but cannot change the value of the object (entity) pointed using pointer ptr. The pointer is stored in the read-write area (stack in the present case). The object pointed may be in the read-only or read-write area.

3) Constant pointer to variable.
Above declaration is a constant pointer to an integer variable, means we can change the value of object pointed by pointer, but cannot change the pointer to point another variable.

4) constant pointer to constant
we cannot change value pointed by the pointer as well as we cannot point the pointer to other variables.

Changing Value of a const variable through pointer

The variables declared using const keyword, get stored in .rodata segment, but we can still access the variable through the pointer and change the value of that variable. By assigning the address of the variable to a non-constant pointer, We are casting a constant variable to a non-constant pointer. The compiler will give warning while typecasting and will discard the const qualifier. Compiler optimization is different for variables and pointers. That is why we are able to change the value of a constant variable through a non-constant pointer.



------------------------------------------------------------------------

volatile:
The system always reads the current value of a volatile object from the memory location rather than keeping its value in temporary register at the point it is requested, even if a previous instruction asked for a value from the same object.

low level programming, we mean a piece of C code which is dealing with peripheral devices, IO ports (mainly memory mapped IO ports), Interrupt Service Routines (ISRs) which interact with Hardware.
While translating Source code to Machine code, compilers typically try to optimize the output so that lesser Machine code needs to be executed finally.

One such optimization is removing unnecessary Machine code for accessing variable which is not changing from Compiler’s perspective. Suppose we have the following code:

while (status == 0)
{
  /*Let us assume that status isn't being changed
  in this while loop or may be in our whole program*/

  /*So long as status (which could be reflecting
  status of some IO port) is ZERO, do something*/
}
An optimizing Compiler would see that status isn’t being changed by while loop. So there’s no need to access status variable again and again after each iteration of loop. So the Compiler would convert this loop to a infinite loop i.e. while (1) so that the Machine code to read status isn’t needed. Please note that compiler isn’t aware of that status is a special variable which can be changed from outside the current program at any point of time e.g. some IO operation happened on a peripheral device for which device IO port was memory mapped to this variable.

So in reality, we want complier to access status variable after every loop iteration even though it isn’t modified by our program which is being compiled by Compiler.

One can argue that we can turn-off all the compiler optimizations for such programs so that we don’t run into this situation. This is not an option due to multiple reasons such as
A) Each compiler implementation is different so it’s not a portable solution
B) Just because of one variable, we don’t want to turn of all the other optimizations which compiler does at other portions of our program.
C) By turning off all the optimizations, our low level program couldn’t work as expected e.g. too much increase in size or delayed execution.



------------------------------------------------------------------------

C doesn’t allow multiple storage class specifiers for a variable

To restrict access to the current file only, global variables can be marked as static.

register keyword can be used with pointer variables. Obviously, a register can have address of a memory location.

Static variables should not be declared inside structure. The reason is C compiler requires the entire structure elements to be placed together (i.e.) memory allocation for structure members should be contiguous. It is possible to declare structure inside the function (stack segment) or allocate memory dynamically(heap segment) or it can be even global (BSS or data segment). Whatever might be the case, all structure members should reside in the same memory segment because the value for the structure element is fetched by counting the offset of the element from the beginning address of the structure. Separating out one member alone to data segment defeats the purpose of static variable and it is possible to have an entire structure as static.

static variables can only be initialized using constant literals. 

extern int var = 0;//warning: ‘var’ initialized and declared ‘extern’
int main(void)
{
 var = 10;
 return 0;
}
Do you think this program will work? Well, here comes another surprise from C standards. They say that..if a variable is only declared and an initializer is also provided with that declaration, then the memory for that variable will be allocated–in other words, that variable will be considered as defined. Therefore, as per the C standard, this program will compile successfully and work.


static variables preserve their previous value in their previous scope and are not initialized again in the new scope

the local variable name is deallocated the memory adderess,but not the value at the memeory address if we try to print the value at that memeory.we will get the value . that is stack frame range for a function is deallocated if the same function is called again ...and by chance same stck frame range is provided so we will find the previous value at that memory which will be garbage for us.

Static variables (like global variables) are initialized as 0 if not initialized explicitly. Static global variables and functions are also possible in C. The purpose of these is to limit scope of a variable or function to a file.

Another reason for making functions static can be reuse of the same function name in other files

Basically, the extern keyword extends the visibility of the C variables and C functions. That’s probably the reason why it was named extern.

Declaration of a variable or function simply declares that the variable or function exists somewhere in the program, but the memory is not allocated for them. The declaration of a variable or function serves an important role–it tells the program what its type is going to be. In case of function declarations, it also tells the program the arguments, their data types, the order of those arguments, and the return type of the function. So that’s all about the declaration.

Coming to the definition, when we define a variable or function, in addition to everything that a declaration does, it also allocates memory for that variable or function.

It turns out that when a function is declared or defined, the extern keyword is implicitly assumed.

Since the extern keyword extends the the function’s visibility to the whole program, the function can be used (called) anywhere in any of the files of the whole program, provided those files contain a declaration of the function. 
(With the declaration of the function in place, the compiler knows the definition of the function exists somewhere else and it goes ahead and compiles the file). So that’s all about extern and functions.


extern int var;
Here, an integer type variable called var has been declared (it hasn’t been defined yet, so no memory allocation for var so far)

int var;
In this line, an integer type variable called var has been both declared and defined (remember that definition is the superset of declaration). Since this is a definition, the memory for var is also allocated. 

Now here comes the surprise. When we declared/defined a function, we saw that the extern keyword was present implicitly. But this isn’t the case with variables. If it were, memory would never be allocated for them. 
Therefore, we need to include the extern keyword explicitly when we want to declare variables without defining them. 
Also, as the extern keyword extends the visibility to the whole program, by using the extern keyword with a variable, we can use the variable anywhere in the program provided we include its declaration the variable is defined somewhere.


int var;
int main(void)
{
   var = 10;
   return 0;
}
This program compiles successfully. var is defined (and declared implicitly) globally.

extern int var;
int main(void)
{
  var = 10;
  return 0;
}
This program throws an error in compilation because var is declared but not defined anywhere.
Essentially, the var isn’t allocated any memory. And the program is trying to change the value to 10 of a variable that doesn’t exist at all.

A declaration can be done any number of times of extern variable  but definition only once.

As an exception, when an extern variable is declared with initialization, it is taken as the definition of the variable as well.

Registers are faster than memory to access, so the variables which are most frequently used in a C program can be put in registers using register keyword. The keyword register hints to compiler that a given variable can be put in a register. It’s compiler’s choice to put it in a register or not


#include <stdio.h>
#include <stdlib.h>
int main(void)
{
   static int *p = (int*)malloc(sizeof(p));
   *p = 10;
   printf("%d", *p);
}
main.c: In function ‘main’:
main.c:7:17: error: initializer element is not constant
 static int *p = (int*)malloc(sizeof(p));


#include <stdio.h>
#include <stdlib.h>
int *p = (int*)malloc(sizeof(p));
int main(void)
{
    *p = 10;
    printf("%d", *p);
}
main.c:4:10: error: initializer element is not constant
 int *p = (int*)malloc(sizeof(p));

In C, static and global variables are initialized by the compiler itself. Therefore, they must be initialized with a constant value.

A static variable needs to be initialized with constant value. But here the static variable is a pointer type and to initialize it dynamic memory allocation is attempted, which will give an address from heap segment.

According to process memory layout, the static variable has to be stored in Data segment and in above code the law is getting violated by assigning address to static variable from heap segment. Hence it will give error.

#include<stdio.h>
#include<stdlib.h>
int main()
{
static int *ptr = 0 ;
ptr = (int*)malloc(4);
*ptr = 10;
printf("%d\n",*ptr);
}
output:10


#include <stdio.h>
int fun(int x)
{
    return (x+5);
}
int y = fun(20);
int main()
{
    printf("%d ", y);
}
C++ : output: 25
C:error
main.c:7:9: error: initializer element is not constant
 int y = fun(20);


What if the inner block itself has one variable with the same name?
If an inner block declares a variable with the same name as the variable declared by the outer block, then the visibility of the outer block variable ends at the pint of the declaration by inner block.

Can variables of the block be accessed in another subsequent block?
No, a variable declared in a block can only be accessed inside the block and all inner blocks of this block.

Register variables are active only within the function. Register variables are alive until the end of a function.

Redeclaration of global variable in C: C allows a global variable to be declared again when first declaration doesn’t initialize the variable.

// Program 1
int main()
{
   int x;
   int x = 5;
   printf("%d", x);
   return 0;
}
Output in C:
redeclaration of ‘x’ with no linkage

// Program 2
int x;
int x = 5;
int main()
{
   printf("%d", x);
   return 0;
}
Output in C:
5

The below program fails in both C also as the global variable is initialized in first declaration itself.

int x = 5;
int x = 10;

int main()
{
   printf("%d", x);
   return 0;
}
Output:
 error: redefinition of ‘x’



int main()
{
int i, j, *p;
i = 25;
j = 100;
int *p = &i;

}
xyz.c: In function ‘main’:
xyz.c:16:6: error: redeclaration of ‘p’ with no linkage
 int *p = &i;
      ^
Both declarations don't specify the linkage - that is, they don't say that the object is extern (external linkage) or static (internal linkage) .Such objects have 'no linkage' and you can't have two of them in the same scope. 


#include<stdio.h>
int y;
int y = 5;

int z = 5;
int z = 10;

int main()
{
   int x;
   int x = 5;
   printf("%d", x);
   return 0;
}

redeclaringGlobalVariable.c:6:5: error: redefinition of ‘z’
 int z = 10;
     ^
redeclaringGlobalVariable.c:5:5: note: previous definition of ‘z’ was here
 int z = 5;
     ^
redeclaringGlobalVariable.c: In function ‘main’:
redeclaringGlobalVariable.c:11:8: error: redeclaration of ‘x’ with no linkage
    int x = 5;
        ^
redeclaringGlobalVariable.c:10:8: note: previous declaration of ‘x’ was here
    int x;
        ^

#include<stdio.h>
register int x;
int x=90;
register int z=10;
int main()
{
        register int y;
        return 0;
}

registerInLocalSpaceOnly.c: At top level:
registerInLocalSpaceOnly.c:5:14: error: register name not specified for ‘z’
 register int z=10;
              ^
[root@localhost storageClasses]# 


#include<stdio.h>
register int x;
int main()
{
        register int y;
        int x=90;
        register int z=10;
        return 0;
}
registerInLocalSpaceOnly.c: At top level:
registerInLocalSpaceOnly.c:3:14: error: register name not specified for ‘x’
 register int x;
              ^


#include<stdio.h>
char c;
register char *cp;
int i;
register int *ip;
extern int var=10;
extern int var2;
int main()
{
        var=100;
        var2=100;
return 0;
}
registerPointer.c:13:12: warning: ‘var’ initialized and declared ‘extern’
 extern int var=10;
            ^~~
registerPointer.c:6:16: error: register name not specified for ‘cp’
 register char *cp;
                ^~
registerPointer.c:9:15: error: register name not specified for ‘ip’
 register int *ip;
               ^~



#include<stdio.h>
char c;
register char *cp;

int i;
register int *ip;
int *ip=&i;


extern int var=10;
extern int var2;
int main()
{
cp=&c;
        var=100;
        var2=100;
return 0;
}

registerPointer.c:13:12: warning: ‘var’ initialized and declared ‘extern’
 extern int var=10;
            ^~~
registerPointer.c:6:16: error: register name not specified for ‘cp’
 register char *cp;
                ^~


------------------------------------------------------------------------

signals are generated by the kernel and handled by the process.

Segmentation Fault (also known as SIGSEGV and is usually signal 11) occur when the program tries to write/read outside the memory allocated for it or when writing memory which can only be read.In other words when the program tries to access the memory to which it doesn’t have access to. SIGSEGV is abbreviation for “Segmentation Violation”.

Few cases where SIGSEGV signal generated are as follows,
-> Using uninitialized pointer
-> De-referencing a NULL pointer
-> Trying to access memory that the program doesn’t own (eg. trying to access an array element
out of array bounds).
-> Trying to access memory which is already de-allocated (trying to use dangling pointers).


Core Dump Reasons:
-Dereferencing uninitialized pointer.A pointer must point to valid memory before accessing it. SIGSEGV
-Stack Overflow. SIGSEGV
-Improper use of scanf(). SIGSEGV
-Accessing out of array index bounds. SIGSEGV
-Accessing an address that is freed. SIGSEGV
-Modifying a string literal. SIGSEGV
char *str;
str = "GfG";    /* Stored in read only part of data segment */
*(str+1) = 'n'; /* Problem:  trying to modify read only memory */


------------------------------------------------------------------------

\'
\"
\?
\OOO: here each O is an octal value from digit 0-7. 
	printf("z\072100"); == z:100...so \072 is treated as octal

\xhh: here hh is hexaecimal. "B\x4a" ==  BJ.
\a: alarm bell
\b: backspace. one character back with or without deleting on different compilers.
\n
\t
\v
\\
\r: carriage return charcter.



------------------------------------------------------------------------

A token is the smallest element of a program that is meaningful to the compiler. Tokens can be classified as follows:

:Keywords:Identifiers:Constants:Strings:Special Symbols:Operators

Identifiers are used as the general terminology for naming of variables, functions and arrays.

Integer constants – Example: 0, 1, 1218, 12482
Real or Floating point constants – Example: 0.0, 1203.03, 30486.184
Octal & Hexadecimal constants – Example: octal: (013 )8 = (11)10, Hexadecimal: (013)16 = (19)10
Character constants -Example: ‘a’, ‘A’, ‘z’
String constants -Example: “GeeksforGeeks”

Strings are nothing but an array of characters ended with a null character (‘\0’).This null character indicates the end of the string. Strings are always enclosed in double quotes.

Special Symbols: The following special symbols are used in C having some special meaning and thus, cannot be used for some other purpose.[] () {}, ; * = #

Arithmetic operators
Relational Operators
Logical Operators
Assignment Operators
Conditional Operators
Bitwise Operators
Ternary Operators


Compound literal (an array is created without any name and address of first element is assigned to p.  This is equivalent to:
   // int arr[] = {2, 4, 6};
   // int *p = arr;
   int *p = (int []){2, 4, 6};

Compound literals feature allows us to create unnamed objects with given list of initialized values.

What is the use of it?
Compound literals are mainly used with structures and are particularly useful when passing structures variables to functions. We can pass a structure object without defining it

void printPoint(struct Point p)//defination
{
   printf("%d, %d", p.x, p.y);
}
printPoint((struct Point){2, 3});//calling

------------------------------------------------------------------------

Difference b/w variable declaration and definition
Variable declaration refers to the part where a variable is first declared or introduced before its first use. Variable definition is the part where the variable is assigned a memory location and a value. Most of the times, variable declaration and definition are done together.

------------------------------------------------------------------------

2) int (*daytab)[13]
Postfix : daytab * [13] int
Meaning : daytab is pointer to array of 13 integers.

3) void (*f[10]) (int, int)
Postfix : f[10] * (int, int) void
Meaning : f is an array of 10 pointer to function(which takes 2 arguments of type int) returning void


4) char (*(*x())[]) ()
Postfix : x () * [] * () char
Meaning : x is a function returning pointer to array of pointers to function returnging char


5) char (*(*x[3])())[5]
Postfix : x[3] * () * [5] char
Meaning : x is an array of 3 pointers to function returning pointer to array of 5 char’s

6) int *(*(*arr[5])()) ()
Postfix : arr[5] * () * () * int
Meaning : arr is an array of 5 pointers to functions returning pointer to function returning pointer to integer

7) void (*bsd_signal(int sig, void (*func)(int)))(int);
Postfix : bsd_signal(int sig, void(*func)(int)) * (int) void
Meaning : bsd_signal is a function that takes integer & a pointer to a function(that takes integer as argument and returns void) and returns pointer to a function(that take integer as argument and returns void)


------------------------------------------------------------------------

float: It is used to store decimal numbers (numbers with floating point value) with single precision.
double: It is used to store decimal numbers (numbers with floating point value) with double precision.


As already known character known character range is between -128 to 127 or 0 to 255.

So %d specifier causes an integer value to be printed and %c specifier causes a character value to printed. But care has to taken that while using %c specifier the integer value should not exceed 127.

float is a 32 bit IEEE 754 single precision Floating Point Number1 bit for the sign, (8 bits for the exponent, and 23* for the value), i.e. float has 7 decimal digits of precision.

double is a 64 bit IEEE 754 double precision Floating Point Number (1 bit for the sign, 11 bits for the exponent, and 52* bits for the value), i.e. double has 15 decimal digits of precision.

In C language, we have three floating data types i.e. float, double and long double. And the exact size of each of these 3 types depends on the C compiler implementation/platform.
printf("%d %d %d",sizeof(float), sizeof(double), sizeof(long double));

But what about the size of a floating point constant (e.g. 31.4 or 2.718)? For example if we have PI macro defined as follows, what would be the sizeof(3.14).

#define PI 3.14
Now if we do sizeof(PI), what will be its size? Is is equal to sizeof(float) ? Or is it also compiler implementation dependent.


Well, for floating constants, C standard (C11 i.e. ISO/IEC 9899:2011) has given guideline. As per C11 clause 6.4.4.2, 
“An unsuffixed floating constant has type double."
"If suffixed by the letter f or F, it has type float."
"If suffixed by the letter l or L, it has type long double.“

It means the type of a floating constant is same as that of double data type. 

size_t is an unsigned integral data type.
It’s a type which is used to represent the size of objects in bytes and is therefore used as the return type by the sizeof operator. 
It is guaranteed to be big enough to contain the size of the biggest object the host system can handle. Basically the maximum permissible size is dependent on the compiler; 
if the compiler is 32 bit then it is simply a typedef(i.e., alias) for unsigned int but 
if the compiler is 64 bit then it would be a typedef for unsigned long long. The size_t data type is never negative.

void *malloc(size_t n);
// While copying 'n' bytes from 's2' to 's1', n must be non-negative integer.
void *memcpy(void *s1, void const *s2, size_t n);
// strlen() uses size_t because the length of any string will always be at least 0.
size_t strlen(char const *s);
size_t or any unsigned type might be seen used as loop variable as loop variables are typically greater than or equal to 0.


1. If no data type is given to a variable, the compiler automatically converts it to int data type.
signed a;
signed b;

// size of a and b is equal to the size of int
printf("The size of a is %d\n", sizeof(a));
printf("The size of b is %d", sizeof(b));

2. Signed is the default modifier for char and int data types.

3. We can’t use any modifiers in float data type. If programmer tries to use it ,the compiler automatically gives compile time error
    signed float a;
    short float b;
Output:
[Error] both 'signed' and 'float' in declaration specifiers
[Error] both 'short' and 'float' in declaration specifiers

4. Only long modifier is allowed in double data types. We cant use any other specifier with double data type. If we try any other specifier, compiler will give compile time error.

------------------------------------------------------------------------

Integer Promotions in C
Some data types like char , short int take less number of bytes than int, these data types are automatically promoted to int or unsigned int when an operation is performed on them. This is called integer promotion.
For example no arithmetic calculation happens on smaller types like char, short and enum. They are first converted to int or unsigned int, and then arithmetic is done on them. If an int can represent all values of the original type, the value is converted to an int . Otherwise, it is converted to an unsigned int.


For example see the following program.
#include <stdio.h>
int main()
{
    char a = 30, b = 40, c = 10;
    char d = (a * b) / c;
    printf ("%d ", d);
    return 0;
}
Output:
120

At first look, the expression (a*b)/c seems to cause arithmetic overflow because signed characters can have values only from -128 to 127 (in most of the C compilers), and the value of subexpression ‘(a*b)’ is 1200 which is greater than 128. But integer promotion happens here in arithmetic done on char types and we get the appropriate result without any overflow.



------------------------------------------------------------------------

Now in order to compile with 32-bit gcc, just add a flag -m32 in the command line of compling the ‘C’ language program.

and similalry -m64

All the data types of the variables are upgraded to the data type of the variable with largest data type.

       bool -> char -> short int -> int ->
       unsigned int -> long -> unsigned ->
       long long -> float -> double -> long double


------------------------------------------------------------------------


What is return type of getchar(), fgetc() and getc() ?
In C, return type of getchar(), fgetc() and getc() is int (not char).

fgets() and gets() in C language
For reading a string value with spaces, we can use either gets() or fgets() in C programming 

fgets()  ::  char *fgets(char *str, int n, FILE *stream)
It reads a line from the specified stream and stores it into the string pointed to by str. It stops when either (n-1) characters are read, the newline character is read, or the end-of-file is reached, whichever comes first.

str : Pointer to an array of chars where the string read is copied.
n : Maximum number of characters to be copied into str(including the terminating null-character).
*stream : Pointer to a FILE object that identifies an input stream. stdin can be used as argument to read from the standard input.
returns : the function returns str

it follow some parameter such as Maximum length, buffer, input device reference.
It is safe to use because it checks the array bound.
It keep on reading until new line character encountered or maximum limit of character array.


gets()
Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.
char * gets ( char * str );
str :Pointer to a block of memory (array of char)
where the string read is copied as a C string.
returns : the function returns str

It is not safe to use because it does not check the array bound.
It is used to read string from user until newline character not encountered.

Difference between getc(), getchar(), getch() and getche()
All of these functions read a character from input and return an integer value. The integer is returned to accommodate a special value used to indicate failure. The value EOF is generally used for this purpose.


getc():
It reads a single character from a given input stream and returns the corresponding integer value (typically ASCII value of read character) on success. It returns EOF on failure.

Syntax:
int getc(FILE *stream);

printf("%c", getc(stdin));


getchar():
The difference between getc() and getchar() is getc() can read from any input stream, but getchar() reads from standard input. So getchar() is equivalent to getc(stdin).
int getchar(void);
printf("%c", getchar());

---------
getch():
int getch();
a nonstandard function and is present in conio.h header file which is mostly used by MS-DOS compilers like Turbo C.It is not part of the C standard library or ISO C, nor is it defined by POSIX .
Like above functions, it reads also a single character from keyboard. But it does not use any buffer, so the entered character is immediately returned without waiting for the enter key.

getche()
Like getch(), this is also a non-standard function present in conio.h. It reads a single character from the keyboard and displays immediately on output screen without waiting for enter key.
Syntax:
int getche(void);
----------

One more difference with getchar() is, it is not a C standard library function, but a POSIX function.

It is a known fact than scanf() is faster than cin and getchar() is faster than scanf() in general. getchar_unlocked() is faster than getchar(), hence fastest of all.

Similarly, there are getc_unlocked() putc_unlocked(), and putchar_unlocked() which are non-thread-safe versions of getc(), putc() and putchar() respectively.


While taking an input string with spaces, the buffer does not get cleared for the next input and considers the previous input for the same. 
A temporary storage area is called buffer. All standard input and output devices contain an input and output buffer.

in case of C after encountering “scanf()” , if we need to input a character array or character  we require to clear the input buffer or else the desired input is occupied by buffer of previous variable, not by the desired container.
On pressing “Enter” (carriage return) on output screen after the first input , , as the buffer of previous variable was the space for new container(as we did’nt clear it) , the program skips the following input of container.

#include<stdio.h>
int main()
{
    char str[80], ch;
    // Scan input from user - "GeeksforGeeks" for example
    scanf("%s", str);

    // Scan character from user - 'a' for example
    ch = getchar();

    // Printing character array, prints “GeeksforGeeks”)
    printf("%s\n", str);

    printf("%c", ch);   // This does not print character 'a'

    return 0;
}
Input:
GeeksforGeeks
a

Output:
GeeksforGeeks



the output is not printed as desired. Reason to this is an occupied Buffer. The “\n” character goes remains there in buffer and read as next input.

How can it be resolved?
In case of C : Using “ while ((getchar()) != ‘\n’); ”  
Typing “while ((getchar()) != ‘\n’);” reads the buffer characters till the end and discards them(including newline) 
and using it after the “scanf()” statement clears the input buffer and allows the input in the desired container.

// C Code to explain why adding "while ( (getchar()) != '\n');" . after "scanf()" statement flushes the input buffer
#include<stdio.h>
int main()
{
    char str[80], ch;
    // scan input from user - GeeksforGeeks for example
    scanf("%s", str);

    // flushes the standard input (clears the input buffer)
    while ((getchar()) != '\n');

    // scan character from user - 'a' for example
    ch = getchar();

    // Printing character array, prints “GeeksforGeeks”)
    printf("%s\n", str);

    // Printing character a: It will print 'a' this time
    printf("%c", ch);

    return 0;
}
Input:
GeeksforGeeks
a

Output:
GeeksforGeeks
a


fun_with_printf
The character % is followed by one of the following characters.
:The flag character : The field width : The precision : The length modifier : The conversion specifier:



What is use of %n in printf() ?

  int c;
  printf("geeks for %ngeeks ", &c);
  printf("%d", c);

The above program prints “geeks for geeks 10”. The first printf() prints “geeks for geeks”. The second printf() prints 10 as there are 10 characters printed (the 10 characters are “geeks for “) before %n in first printf() and c is set to 10 by first printf().

In C printf(), %n is a special format specifier which instead of printing something causes printf() to load the variable pointed by the corresponding argument with a value equal to the number of characters that have been printed by printf() before the occurrence of %n.


printf:
printf function is used to print character stream of data on stdout console.


sprintf:
Syntax: int sprintf(char *str, const char *string,...);
String print function instead of printing on console store it on char buffer which are specified in sprintf

    char buffer[50];
    int a = 10, b = 20, c;
    c = a + b;
    sprintf(buffer, "Sum of %d and %d is %d", a, b, c);

    // The string "sum of 10 and 20 is 30" is stored into buffer instead of printing on stdout
    printf("%s", buffer);


fprintf:
fprintf is used to print the string content in file but not on stdout console.
int fprintf(FILE *fptr, const char *str, ...);

#include<stdio.h>
int main()
{
    int i, n=2;
    char str[50];

    //open file sample.txt in write mode
    FILE *fptr = fopen("sample.txt", "w");
    if (fptr == NULL)
    {
        printf("Could not open file");
        return 0;
    }

    for (i=0; i<n; i++)
    {
        puts("Enter a name");
        gets(str);
        fprintf(fptr,"%d.%s\n", i, str);
    }
    fclose(fptr);

    return 0;
}
Input: GeeksforGeeks
       GeeksQuiz
Output :  sample.txt file now having output as
0. GeeksforGeeks
1. GeeksQuiz


getch() method pauses the Output Console untill a key is pressed.
It does not use any buffer to store the input character.
The entered character is immediately returned without waiting for the enter key.
The entered character does not show up on the console.
The getch() method can be used to accept hidden inputs like password, ATM pin numbers, etc.


scanf() and fscanf() in C
How to read only a part of the input that we need? For example, consider some input stream that contains only characters followed by an integer or a float. And we need to scan only that integer or float.That is ,
Input: “this is the value 100”,
Output: value read is 100
Input : “this is the value 21.2”,
Output : value read is 21.2

 assume we don’t know what the preceding characters are but we surely know that the last value is an integer. How can we scan the last value as an integer?
Below solution works only if input string has no spaces.
    int a;
    scanf("%*s %d", &a);
    printf("Input value read : a=%d",a);
    return 0;
Explanation: The %*s in scanf is used to ignore some input as required. In this case, it ignores the input until the next space or new line. Similarly if you write %*d it will ignore integers until the next space or new line.

int fscanf(FILE *ptr, const char *format, ...)
fscanf reads from a file pointed by the FILE pointer (ptr), instead of reading from the input stream.

Consider the following text file abc.txt
NAME    AGE   CITY
abc     12    hyderbad
bef     25    delhi
cce     65    bangalore
Now, we want to read only the city field of the above text file, ignoring all the other fields. A combination of fscanf and the trick mentioned above does this with ease

/*c program demonstrating fscanf and its usage*/
#include<stdio.h>
int main()
{
    FILE* ptr = fopen("abc.txt","r");
    if (ptr==NULL)
    {
        printf("no such file.");
        return 0;
    }
    char* buf[100];
    while (fscanf(ptr,"%*s %*s %s ",buf)==1)
        printf("%s\n", buf);

    return 0;
}
Output:
CITY
hyderbad
delhi
bangalore

scanf(“%[^\n]s”, str) Vs gets(str) 
gets is a more convenient method of reading a string of text containing whitespaces.
Unlike scanf(), it does not skip whitespaces.
It is used to read the input until it encounters newline.

In general scanf() function with format specification like %s and specification with the field width in the form of %ws can read-only strings till non-whitespace part.
It means they cannot be used for reading a text containing more than one word, especially with Whitespaces.

The main difference between them is:
scanf() reads input until it encounters whitespace, newline or End Of File(EOF) whereas gets() reads input until it encounters newline or End Of File(EOF), gets() does not stop reading input when it encounters whitespace instead it takes whitespace as a string.

Problem with scanf() when there is fgets()/gets()/scanf() after it
#include<stdio.h>
int main()
{
   int x;
   char str[100];
   scanf("%d", &x);
   fgets(str, 100, stdin);
   printf("x = %d, str = %s", x, str);
   return 0;
}
Input
10
test
Output:
x = 10, str =
The problem with above code is scanf() reads an integer and leaves a newline character in buffer. So fgets() only reads newline and the string “test” is ignored by the program.

The similar problem occurs when scanf() is used in a loop.
This happens because every scanf() leaves a newline character in buffer that is read by next scanf.

How to solve above problem?
        1)We can make scanf() to read a new line by using an extra “\n”, i.e., scanf(“%d\n”, &x) .
          In fact scanf(“%d “, &x       ) also works (Note extra space).
        2)We can add a getchar() after scanf() to read an extra newline.


although the fgets function does actually append a null to the end of the input string, provided there is enough room in the buffer.

Usually, to clear the input buffer, one would just call fseek(stdin, 0, SEEK_END); but it doesn’t seem to work on every platform.


In case of a string (character array), the variable itself points to the first element of the array in question. Thus, there is no need to use the ‘&’ operator to pass the address.

char name[25];
scanf("%s", name);

‘&’ is used to get the address of the variable. C does not have a string type, String is just an array of characters and an array variable stores the address of the first index location.
By default the variable itself points to the base address and therefore to access base address of string, there is no need of adding an extra ‘&’

The iscntrl() function is used to checks whether a character is a control character or not. iscntrl() function also take a single argument and return an integer.


How srand() and rand() are related to each other?

srand() sets the seed which is used by rand to generate “random” numbers. If you don’t call srand before your first call to rand, it’s as if you had called srand(1) to set the seed to one.
In short, srand() — Set Seed for rand() Function.


scanf() : It returns total number of Inputs Scanned successfully, or EOF if input failure occurs before the first receiving argument was assigned.

printf() : It returns total number of Characters Printed, Or negative value if an output error or an encoding error
when multiple printf’s appear inside another printf, the inner printf prints its output and returns length of the string printed on the screen to the outer printf.

Input:
Hey!
welcome to
geeks for geeks

Output:
 First scanf() returns : 1
 Second scanf() returns : 2
 Third scanf() returns : 3


    long int n = 123456789;
    printf("While printing ");
    printf(", the value returned by printf() is : %d", printf("%d", n));
    return 0;

Output: While printing 123456789, the value returned by printf() is : 9


Inbuilt library functions for user Input | scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s

sscanf(): sscanf() is used to read formatted input from the string.
Syntax: int sscanf ( const char * s, const char * format, ...);
Return type: Integer
Parameters:
s: string used to retrieve data
format: string that contains the type specifier(s)
… : arguments contains pointers to allocate storage with appropriate type.


    char s [] = "3 red balls 2 blue balls";
    char str [10],str2 [10];
    int i;
    // %*s is used to skip a word
    sscanf (s,"%d %*s %*s %*s %s %s", &i, str, str2);
    printf ("%d %s %s \n", i, str, str2);
Output:
3 blue balls


fscanf(): fscanf() reads formatted data from file and stores it into variables.
Syntax: int fscanf(FILE *stream, const char *format, ...)

Parameters:
Stream:  pointer to the File object that identifies the stream.
format: is a string that contains the type specifier(s)
On success, the function returns the number of variables filled. In the case of an input failure, before any data could be successfully read, EOF is returned.

    // file pointer
    FILE * fp;

    // opening/creation of file
    fp = fopen ("file.txt", "w+");

    // storing string in the file
    fputs("Hello World its 2017", fp);

    // sets the file position to the beginning of the file
    rewind(fp);

    // taking input from file
    fscanf(fp, "%s %s %s %d", s1, s2, s3, &year);

    printf("String1 |%s|\n", s1 );
    printf("String2 |%s|\n", s2 );
    printf("String3 |%s|\n", s3 );
    printf("Integer |%d|\n", year );

    // close file pointer
    fclose(fp);

Output:
String1 |Hello|
String2 |World|
String3 |its|
Integer |2017|


Scansets in C
scanf family functions support scanset specifiers which are represented by %[]. Inside scanset, we can specify single character or range of characters. While processing scanset, scanf will process only those characters which are part of scanset. We can define scanset by putting characters inside squre brackets. Please note that the scansets are case-sensitive.


Let us see with example. Below example will store only capital letters to character array ‘str’, any other character will not be stored inside character array.
    scanf("%[A-Z]s", str);

If first character of scanset is ‘^’, then the specifier will stop reading after first occurrence of that character. For example, given below scanset will read all characters but stops after first occurrence of ‘o’

scanf("%[^o]s", str);
  Enter a string: http://geeks for geeks
  You entered: http://geeks f

Never use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead.

percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments.

%d specifies signed decimal integer while %i specifies integer.

%d and %i behave similar with printf
There is no difference between the %i and %d format specifiers for printf.
%d and %i behavior is different in scanf

%d and %i behavior is different in scanf.
%d assume base 10 while %i auto detects the base. Therefore, both specifiers behaves differently while they are used with an input specifier. So, 012 would be 10 with %i but 12 with %d.

%d takes integer value as signed decimal integer i.e. it takes negative values along with positive values but values should be in decimal otherwise it will print garbage value. Consider a following example.
%i takes integer value as integer value with decimal, hexadecimal or octal type.

To enter a value in hexadecimal format – value should be provided by preceding “0x” and value in octal format – value should be provided by preceding “0”.

    printf("Enter value of a in decimal format:");
    scanf("%d", &a);

    printf("Enter value of b in octal format: ");
    scanf("%i", &b);

    printf("Enter value of c in hexadecimal format: ");
    scanf("%i", &c);

    printf("a = %i, b = %i, c = %i", a, b, c);


Output:
Enter value of a in decimal format:12
Enter value of b in octal format: 012
Enter value of c in hexadecimal format: 0x12
a = 12, b = 10, c = 18
Explanation:
The decimal value of a as 12 is 12
The decimal value of b as 12(octal) is 10
The decimal value of c as 12(hexadecimal) is 18

remember scanf is a function().
 scanf() needs to modify values of a and b and but they are local to scanf(). So in order to reflect changes in the variable a and b of the main function, we need to pass addresses of them. We cannot simply pass them by value.

But in case of printf function as we are only going to print the values of the variables in output console, there are no changes going to be made in variable a and b’s values. So it is not required to send their addresses.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Arithmetic Operators (+, -, *, /, %, post-increment, pre-increment, post-decrement, pre-decrement)

Relational Operators (==, !=, >, <, >= , <=)

Logical Operators (&&, || and !)

Bitwise Operators (&, |, ^, ~, >> and <<)

Assignment Operators (=, +=, -=, *=, etc..(like : ^= ,&= ))

Other Operators (conditional, comma, sizeof, address, redirecton)




precedence of Postfix ++ (or Postfix –) is higher than both Prefix ++ and *. precedence of Prefix ++ (or Prefix –) has higher priority than dereference (*) operator 
so, post, pre,*


sizeof operator:
It is a compile time unary operator which can be used to compute the size of its operand. The result of sizeof is of unsigned integral type which is usually denoted by size_t. Basically, sizeof operator is used to compute the size of the variable.

Comma Operator:
The comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). The comma operator has the lowest precedence of any C operator. Comma acts as both operator and separator.

remembering following simple rules about postfix ++, prefix ++ and * (dereference) operators
1) Precedence of prefix ++ and * is same. Associativity of both is right to left.
2) Precedence of postfix ++ is higher than both * and prefix ++. Associativity of postfix ++ is left to right.

The logical and operator ‘&&’ expects its operands to be boolean expressions (either 1 or 0) and returns a boolean value.
The bitwise and operator ‘&’ works on Integral (short, int, unsigned, char, bool, unsigned char, long) values and return Integral value.


b) If an integral value is used as an operand for ‘&&’ which is supposed to work on boolean values, following rule is used in C.
…..A zero is considered as false and non-zero is considered as true.
It is compiler error to use non-integral expression as operand for bitwise &.

c) The ‘&&’ operator doesn’t evaluate second operand if first operand becomes false. Similarly ‘||’ doesn’t evaluate second operand when first operand becomes true. The bitwise ‘&’ and ‘|’ operators always evaluate their operands.

results of both -1 << 1 and 1 << -1 is undefined. Also, if the number is shifted more than the size of integer, the behaviour is undefined. For example, 1 << 33 is undefined


“Given a set of numbers where all elements occur even number of times except one number, find the odd occurring number” This problem can be efficiently solved by just doing XOR of all numbers.

// Function to return the only odd
// occurring element
int findOdd(int arr[], int n)
{
    int res = 0, i;
    for (i = 0; i < n; i++)
        res ^= arr[i];
    return res;
}

The following are many other interesting problems using XOR operator.

#Find the Missing Number
#swap two numbers without using a temporary variable
#A Memory Efficient Doubly Linked List
#Find the two non-repeating elements.
#Find the two numbers with odd occurences in an unsorted-array.
#Add two numbers without using arithmetic operators.
#Swap bits in a given number/.
#Count number of bits to be flipped to convert a to b .
#Find the element that appears once.
#Detect if two integers have opposite signs.

4)The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively. As mentioned in point 1, it works only if numbers are positive.

5)The & operator can be used to quickly check if a number is odd or even. The value of expression (x & 1) would be non-zero only if x is odd, otherwise the value would be zero.

6)The ~ operator should be used carefully. The result of ~ operator on a small number can be a big number if the result is stored in an unsigned variable. And the result may be a negative number if the result is stored in a signed variable (assuming that the negative numbers are stored in 2’s complement form where the leftmost bit is the sign bit)


1) Comma as an operator:
The comma operator (represented by the token, ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type).

/* comma as an operator */
int i = (5, 10); /* 10 is assigned to i*/
int j = (f1(), f2()); /* f1() is called (evaluated) first followed by f2().
                      The returned value of f2() is assigned to j */


2) Comma as a separator:
Comma acts as a separator when used with function calls and definitions, function like macros, variable declarations, enum declarations, and similar constructs.
/* comma as a separator */
int a = 1, b = 2;
void fun(x, y);


The use of comma as a separator should not be confused with the use as an operator. For example, in below statement, f1() and f2() can be called in any order.
/* Comma acts as a separator here and doesn't enforce any sequence.
    Therefore, either f1() or f2() can be called first */
void fun(f1(), f2());



  int a = 10, b = 20;
  (a, b) = 30; // Since b is l-value, this statement is valid in C++, but not in C.
  printf("b = %d", b);


#include <stdio.h>
int main()
{
    int x = 10;
    int y = (x++, ++x);
    printf("%d", y);
    getchar();
    return 0;
}
12


#include <stdio.h>
int main()
{
    int x = 10, y;

    // The following is equivalent
    // to y = x + 2 and x += 3,
    // with two printings
    y = (x++,
         printf("x = %d\n", x),
         ++x,
         printf("x = %d\n", x),
         x++);

    // Note that last expression is evaluated
    // but side effect is not updated to y
    printf("y = %d\n", y);
    printf("x = %d\n", x);

    return 0;
}
x = 11
x = 12
y = 12
x = 13



A comma operator question
Consider the following C programs.

#include<stdio.h>
int main(void)
{
    int a = 1, 2, 3;
    printf("%d", a);
    return 0;
}


#include<stdio.h>
int main(void)
{
    int (a = 1), 2, 3;
    printf("%d", a);
    return 0;
}

#include<stdio.h>
int main(void)
{
    int (a = 1, 2,) 3;
    printf("%d", a);
    return 0;
}


    
int x = 10, y = 10; 
    printf("%d \n", sizeof(x == y));
    printf("%d \n", sizeof(x < y));
    return 0;
Output:
4
4


lvalue and rvalue in C language
L-value: “l-value” refers to memory location which identifies an object. l-value may appear as either left hand or right hand side of an assignment operator(=). l-value often represents as identifier.

Expressions referring to modifiable locations are called “modifiable l-values“. A modifiable l-value cannot have an array type, an incomplete type, or a type with the const attribute.

R-value: r-value” refers to data value that is stored at some address in memory. A r-value is an expression that can’t have a value assigned to it which means r-value can appear on right but not on left hand side of an assignment operator(=).



// declare a, b an object of type 'int'
int a = 1, b;

a + 1 = b; // Error, left expression is
           // is not variable(a + 1)

// declare pointer variable 'p', and 'q'
int *p, *q; // *p, *q are lvalue

*p = 1; // valid l-value assignment

// below is invalid - "p + 2" is not an l-value
// p + 2 = 18;

q = p + 5; // valid - "p + 5" is an r-value



// Below is valid - dereferencing pointer
// expression gives an l-value
*(p + 2) = 18;

p = &b;

int arr[20]; // arr[12] is an lvalue; equivalent
              // to *(arr+12)
              // Note: arr itself is also an lvalue

struct S { int m; };

struct S obj; // obj and obj.m are lvalues

// ptr-> is an lvalue; equivalent to (*ptr).m
// Note: ptr and *ptr are also lvalues
struct S* ptr = &obj;
Note: The unary & (address-of) operator requires an lvalue as its operand. That is, &n is a valid expression only if n is an lvalue. Thus, an expression such as &12 is an error. Again, 12 does not refer to an object, so it’s not addressable. For instance,


// declare a as int variable and
// 'p' as pointer variable
int a, *p;
p = &a; // ok, assignment of address
        // at l-value
&a = p;    // error: &a is an r-value

int x, y;
(  x < y ? y : x) = 0; // It's valid because the ternary
                  // expression preserves the "lvalue-ness"
                 // of both its possible return values


Increment (Decrement) operators require L-value Expression
What will be the output of the following program?
#include<stdio.h>
int main()
{
   int i = 10;
   printf("%d", ++(-i));
   return 0;
}
A) 11 B) 10 C) -9 D) None
Answer: D, None – Compilation Error.
Explanation:



In C/C++ the pre-increment (decrement) and the post-increment (decrement) operators require an L-value expression as operand. Providing an R-value or a const qualified variable results in compilation error.

In the above program, the expression -i results in R-value which is operand of pre-increment operator. The pre-increment operator requires an L-value as operand, hence the compiler throws an error.

The increment/decrement operators needs to update the operand after the sequence point, so they need an L-value. The unary operators such as -, +, won’t need L-value as operand. The expression -(++i) is valid.


Operator precedence determines which operator is performed first in an expression with more than one operators with different precedence.
Operators Associativity is used when two operators of same precedence appear in an expression. Associativity can be either Left to Right or Right to Left.

1) Associativity is only used when there are two or more operators of same precedence.
The point to note is associativity doesn’t define the order in which operands of a single operator are evaluated
For example, consider the following program, associativity of the + operator is left to right, but it doesn’t mean f1() is always called before f2(). The output of the following program is in-fact compiler dependent. See this for details.
    int p = f1() + f2();

4) Comma has the least precedence among all operators and should be used carefully For example consider the following program, the output is 1.
#include <stdio.h>
int main()
{
    int a;
    a = 1, 2, 3; // Evaluated as (a = 1), 2, 3
    printf("%d", a);
    return 0;
}

A sequence point defines any point in a computer program’s execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. 


   // Since && defines a sequence point after first operand, it is guaranteed that f1() is completed first.
   int p = f1() && f2();   

   // Since comma operator defines a sequence point after first operand, it is  guaranteed that f1() is completed first.
  int p = (f1(), f2());


   // Since ? operator defines a sequence point after first operand, it isguaranteed that f1() is completed first.
  int p = f1()? f2(): 3;




   int i = 8;
   int p = i++*i++;
It may be 64, 72, or may be something else. The subexpression i++ causes a side effect, it modifies i’s value, which leads to undefined behavior since i is also referenced elsewhere in the same expression.


Implement Your Own sizeof
#include<stdio.h>
#define my_sizeof(type) (char *)(&type+1)-(char*)(&type)
int main()
{
    double x; 
    printf("%ld", my_sizeof(x));
    getchar();
    return 0;
}


the sizeof() operator only takes into account the type of the operand, which may be an expression or the name of a type (i.e int, double, float etc) and not the value obtained on evaluating the expression. Hence, the operand inside the sizeof() operator is not evaluated. 

It is evaluated only if the type of the operand is variable length array because in that case, the size can be determined only after the expression is evaluated.

It is a compile time unary operator which can be used to compute the size of its operand. The result of sizeof is of unsigned integral type which is usually denoted by size_t. sizeof can be applied to any data-type, including primitive types such as integer and floating-point types, pointer types, or compound datatypes such as Structure, union etc.


1. To find out number of elements in a array.
Sizeof can be used to calculate number of elements of the array automatically.
    int arr[] = { 1, 2, 3, 4, 7, 98, 0, 12, 35, 99, 14 };
    printf("Number of elements:%lu ", sizeof(arr) / sizeof(arr[0]));

2. To allocate a block of memory dynamically.
sizeof is greatly used in dynamic memory allocation. For example, if we want to allocate memory for which is sufficient to hold 10 integers and we don’t know the sizeof(int) in that particular machine. We can allocate with the help of sizeof.
int* ptr = (int*)malloc(10 * sizeof(int));


The operand either may be a data-type or an expression. sizeof(char). 
The expression is used only for getting the type of operand and not evaluation.  int int_size = sizeof(i++);


The sizeof for a struct is not always equal to the sum of sizeof of each individual member. This is because of the padding added by the compiler to avoid alignment issues. Padding is only added when a structure member is followed by a member with a larger size or at the end of the structure.

When the sizeof() method is passed a variable size structure:
In this case, the sizeof() operator evaluates the parameter to see if there is any change of size. If found, then first the size is modified then the final size is returned

#include <stdio.h>
int main()
{
    int x = 3;
    printf("%d\n", sizeof(int[x++]));
    printf("x = %d", x);

    return 0;
}
Output:
12
x = 4



#include <stdio.h>
int main()
{
    int x = 3;
    printf("%d\n", sizeof(int[++x]));
    printf("x = %d", x);

    return 0;
}
Output:
16
x = 4



strlen() is a predefined function in C whose definition is contained in the header file “string.h”.
Sizeof operator is a compile time unary operator
strlen() accepts a pointer to an array as argument and walks through memory at run time from the address we give it looking for a NULL character and counts up how many memory locations it passed before it finds one.
The main task of strlen() is to count the length of an array or string.

How to find size of array in C/C++ without using sizeof ?

Method 1 (Writing our own sizeof)
# define my_sizeof(type) ((char *)(&type+1)-(char*)(&type))
    int  arr[] = {1, 2, 3, 4, 5, 6};
    int size = my_sizeof(arr)/my_sizeof(arr[0]);

Method 2(Using a pointer hack)
The following solution is very short when compared to the above solution. Number of elements in an array A can be found out using the expression
int size = *(&arr + 1) - arr;

How does this work?
Here the pointer arithmetic does its part. We don’t need to explicitly convert each of the locations to character pointers.

&arr ==> Pointer to an array of 6 elements.
         [See this for difference between &arr
          and arr]

(&arr + 1) ==> Address of 6 integers ahead as
               pointer type is pointer to array
               of 6 integers.

*(&arr + 1) ==> Same address as (&arr + 1), but
                type of pointer is "int *".

*(&arr + 1) - arr ==> Since *(&arr + 1) points
                   to the address 6 integers
                   ahead of arr, the difference
                   between two is 6.


To find sum of two numbers without using any operator
//this uses inc/dec operator
#include<stdio.h>
int main()
{
    int a = 10, b = 5, sum;
    while(b > 0)
    {
        a++;
        b--;
    }
    printf("Sum = %d",a);
    return 0;
}


We can use printf() to find sum of two numbers as printf() returns the number of characters printed. The width field in printf() can be used to find the sum of two numbers. We can use ‘*’ which indicates the minimum width of output. For example, in the statement “printf(“%*d”, width, num);”, the specified ‘width’ is substituted in place of *, and ‘num’ is printed within the minimum width specified. If number of digits in ‘num’ is smaller than the specified ‘width’, the output is padded with blank spaces. If number of digits are more, the output is printed as it is (not truncated). In the following program, add() returns sum of x and y. It prints 2 spaces within the width specified using x and y. So total characters printed is equal to sum of x and y. That is why add() returns x+y.

#include<stdio.h>

int add(int x, int y)
{
    return printf("%*c%*c", x, ' ', y, ' ');
}

// Driver code
int main()
{
    printf("Sum = %d", add(3, 4));
    return 0;
}
       Sum = 7

The output is seven spaces followed by “Sum = 7”. We can avoid the leading spaces by using carriage return.


The following program prints output without any leading spaces.
#include<stdio.h>
int add(int x, int y)
{
    return printf("%*c%*c", x, '\r', y, '\r');
}

// Driver code
int main()
{
    printf("Sum = %d", add(3, 4));
    return 0;
}


In the following condition : a ? b : c
If a is true, b will be executed. Otherwise, c will be executed.
We can code the equation as : Result = (!!a)*b + (!a)*c
In above equation, is a is true, result will be b. Otherwise, result will be c.

Return Type:
It is another interesting fact. The ternary operator has return type. The return type depends on exp2, and convertibility of exp3 into exp2 as per usual\overloaded conversion rules. If they are not convertible, the compiler throws an error. See the examples below,

The following program compiles without any error. The return type of ternary expression is expected to be float (as that of exp2) and exp3 (i.e. literal zero – int type) is implicitly convertible to float.

#include <iostream>
using namespace std;
int main()
{
   int test = 0;
   float fvalue = 3.111f;
   cout << (test ? fvalue : 0) << endl;
   return 0;
}


The following program will not compile, because the compiler is unable to find return type of ternary expression or implicit conversion is unavailable between exp2 (char array) and exp3 (int).
#include <iostream>
using namespace std;
int main()
{
   int test = 0;
   cout << test ? "A String" : 0 << endl;
   return 0;
}


A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. 


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Diffference between #define and const in C?
#define is a preprocessor directive. const variables are actual variables like other normal variable.

The big advantage of const over #define is type checking. We can also have poitners to const varaibles, we can pass them around, typecast them and any other thing that can be done with a normal variable. One disadvantage that one could think of is extra space for variable which is immaterial due to optimizations done by compilers.


1) When we use include directive,
2) When we use define for a constant,
3) The macros can take function like arguments, the arguments are not checked for data type. For example, the following macro INCREMENT(x) can be used for x of any data type.
#include <stdio.h>
#define INCREMENT(x) ++x
int main()
{
    char *ptr = "GeeksQuiz";
    int x = 10;
    printf("%s  ", INCREMENT(ptr));
    printf("%d", INCREMENT(x));
    return 0;
}

4) The macro arguments are not evaluated before macro expansion. For example, consider the following program
#include <stdio.h>
#define MULTIPLY(a, b) a*b
int main()
{
    // The macro is expended as 2 + 3 * 3 + 5, not as 5*8
    printf("%d", MULTIPLY(2+3, 3+5));
    return 0;
}
// Output: 16
Output:
16

The previous problem can be solved using following program
#include <stdio.h>
//here, instead of writing a*a we write (a)*(b)
#define MULTIPLY(a, b) (a)*(b)


5) The tokens passed to macros can be concatenated using operator ## called Token-Pasting operator.
#include <stdio.h>
#define merge(a, b) a##b
int main()
{
    printf("%d ", merge(12, 34));
}
Output:
1234

6) A token passed to macro can be converted to a string literal by using # before it.
#include <stdio.h>
#define get(a) #a
int main()
{
    // GeeksQuiz is changed to "GeeksQuiz"
    printf("%s", get(GeeksQuiz));
}
Output:
GeeksQuiz

7) The macros can be written in multiple lines using ‘\’. The last line doesn’t need to have ‘\’.
#include <stdio.h>
#define PRINT(i, limit) while (i < limit) \
                        { \
                            printf("GeeksQuiz "); \
                            i++; \
                        }
int main()
{
    int i = 0;
    PRINT(i, 3);
    return 0;
}
Output:
GeeksQuiz GeeksQuiz GeeksQuiz

8) The macros with arguments should be avoided as they cause problems sometimes. And Inline functions should be preferred as there is type checking parameter evaluation in inline functions. From C99 onward, inline functions are supported by C language also.
For example consider the following program. From first look the output seems to be 1, but it produces 36 as output.
#include <stdio.h>
#define square(x) x*x
int main()
{
    // Expanded as 36/6*6
    int x = 36/square(6);
    printf("%d", x);
    return 0;
}
Output:
36
If we use inline functions, we get the expected output. Also, the program given in point 4 above can be corrected using inline functions.
#include <stdio.h>
static inline int square(int x) { return x*x; }
int main()
{
int x = 36/square(6);
printf("%d", x);
return 0;
}
Output:
1


9) Preprocessors also support if-else directives which are typically used for conditional compilation.

10) A header file may be included more than one time directly or indirectly, this leads to problems of redeclaration of same variables/functions. To avoid this problem, directives like defined, ifdef and ifndef are used.
11) There are some standard macros which can be used to print program file (__FILE__), Date of compilation (__DATE__), Time of compilation (__TIME__) and Line Number in C code (__LINE__)

12) We can remove already defined macros using :
#undef MACRO_NAME
Another interesting fact about macro using (#undef): u can un-define or define functions(argument macros) depending upon a conditon. 

Macros are no longer recommended as they cause following issues. There is a better way in modern compilers that is inline functions and const variable.

functions are not preprocessed but compiled.
Also, macros do not check for compilation error (if any)

Macros:
#include<stdio.h>
#define CUBE(b) b*b*b
int main()
{
     printf("%d", CUBE(1+2));
     return 0;
}
Output: Unexpected output
7

Functions:
#include<stdio.h>
int cube(int a)
{
     return a*a*a;
}
int main()
{
    printf("%d", cube(1+2));
    return 0;
}
Output: As expected
27


The speed at which macros and functions differs. Macros are typically faster than functions as they don’t involve actual function call overhead.

#include<stdio.h>
#define PRINT(x) (#x)
int main()
{
printf("%f",PRINT(5.009));
return 0;
}

prog.c: In function ‘main’:
prog.c:5:8: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘char *’ [-Wformat=]
 printf("%f",PRINT(5.009));
        ^

your macro expansion should not result into the extra semicolon at the end . check it


C's offsetof() macro is an ANSI C library feature found in stddef.h.
It evaluates to the offset (in bytes) of a given member within a struct or union type, an expression of type size_t. The offsetof() macro takes two parameters, the first being a structure name, and the second being the name of a member within the structure

We know that the elements in a structure will be stored in sequential order of their declaration.
How to extract the displacement of an element in a structure? We can make use of offsetof macro.
The following non-standard macro can be used to get the displacement of an element in bytes from the base address of the structure variable.
#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT))


__STDC__ Macro is used to confirm the compiler standard. Generally it holds the value 1 which means that the compiler conforms to ISO Standard C.
__STDC__HOSTED Macro: This macro holds the value 1 if the compiler’s target is a hosted environment. A hosted environment is a facility in which a third-party holds the compilation data and runs the programs on its own computers. Generally, the value is set to 1.


There are 4 main types of preprocessor directives:

Macros
File Inclusion
Conditional Compilation
Other directives

The ‘#define’ directive is used to define a macro.
Note: There is no semi-colon(‘;’) at the end of macro definition. Macro definitions do not need a semi-colon to end.
Macros with arguments: We can also pass arguments to macros.

File Inclusion: This type of preprocessor directive tells the compiler to include a file in the source code program.

Conditional Compilation: Conditional Compilation directives are type of directives which helps to compile a specific portion of the program or to skip compilation of some specific part of the program based on some conditions. This can be done with the help of two preprocessing commands ‘ifdef‘ and ‘endif‘.


#pragma Directive: This directive is a special purpose directive and is used to turn on or off some features. This type of directives are compiler-specific i.e., they vary from compiler to compiler. Some of the #pragma directives are discussed below:


#pragma startup and #pragma exit: These directives helps us to specify the functions that are needed to run before program startup( before the control passes to main()) and just before program exit (just before the control returns from main()).

#pragma warn Directive: This directive is used to hide the warning message which are displayed during compilation.
We can hide the warnings as shown below:

#pragma warn -rvl: This directive hides those warning which are raised when a function which is supposed to return a value does not returns a value.
#pragma warn -par: This directive hides those warning which are raised when a function does not uses the parameters passed to it.
#pragma warn -rch: This directive hides those warning which are raised when a code is unreachable. For example: any code written after the return statement in a function is unreachable.


// C program to demonstrate importance
// of typedef over #define for data types
#include <stdio.h>
typedef char* ptr;
#define PTR char*
int main()
{
    ptr a, b, c;
    PTR x, y, z;
    printf("sizeof a:%u\n" ,sizeof(a) );
    printf("sizeof b:%u\n" ,sizeof(b) );
    printf("sizeof c:%u\n" ,sizeof(c) );
    printf("sizeof x:%u\n" ,sizeof(x) );
    printf("sizeof y:%u\n" ,sizeof(y) );
    printf("sizeof z:%u\n" ,sizeof(z) );
    return 0;
}
Output:
sizeof a:8
sizeof b:8
sizeof c:8
sizeof x:8
sizeof y:1
sizeof z:1
From the output of the above program size of “a” which is a pointer is 8 (on a machine where pointers are stored using 8 bytes). In the above program, when the compiler comes to

typedef char* ptr;
ptr a, b, c;
the statement effectively becomes
char *a, *b, *c;
This declares a, b, c as char*.

In contrast, #define works like this:

#define PTR char*
PTR x, y, z;
the statement effectively becomes
char *x, y, z;


typedef is limited to giving symbolic names to types only,

typedef interpretation is performed by the compiler where #define statements are performed by preprocessor.

#define should not be terminated with a semicolon, but typedef should be terminated with semicolon.

#define will just copy-paste the definition values at the point of use, while typedef is the actual definition of a new type.

typedef follows the scope rule which means if a new type is defined in a scope (inside a function), then the new type name will only be visible till the scope is there. In case of #define, when preprocessor encounters #define, it replaces all the occurrences, after that (No scope rule is followed).


How to Count Variable Numbers of Arguments in C?
C supports variable numbers of arguments. But there is no language provided way for finding out total number of arguments passed. User has to handle this in one of the following ways:
1) By passing first argument as count of arguments.
2) By passing last argument as NULL (or 0).
3) Using some printf (or scanf) like mechanism where first argument has placeholders for rest of the arguments.

Variable Length Argument in C
Variable number of arguments are represented by three dotes (…)

#include <stdarg.h>
#include <stdio.h>

// this function returns minimum of integer
// numbers passed. First argument is count
// of numbers.
int min(int arg_count, ...)
{
        int i;
        int min, a;

        // va_list is a type to hold information about
        // variable arguments
        va_list ap;

        // va_start must be called before accessing
        // variable argument list
        va_start(ap, arg_count);

        // Now arguments can be accessed one by one
        // using va_arg macro. Initialize min as first
        // argument in list
        min = va_arg(ap, int);
        // traverse rest of the arguments to find out minimum
        for (i = 2; i <= arg_count; i++)
                if ((a = va_arg(ap, int)) < min)
                        min = a;

        // va_end should be executed before the function
        // returns whenever va_start has been previously
        // used in that function
        va_end(ap);

        return min;
}

// Driver code
int main()
{
        int count = 5;
        printf("Minimum value is %d", min(count, 12, 67, 6, 7, 100));
        return 0;
}

Use int parameter and va_start macro to initialize the va_list variable to an argument list. The macro va_start is defined in stdarg.h header file.
Use va_arg macro and va_list variable to access each item in argument list.
macro va_end to clean up the memory assigned to va_list variable.


X-Macros in C
X-Macros are based on the property of nested macros and the ability to define macros inside other macros. X-Macros are very powerful pre-processor technique in the sense that it can create a self-maintaining and inter-dependent piece of code. When the change of one part of a program leads to a change in another part, then the code is said to be inter-dependent.

Syntax:
An X macro application consists of two parts:

The definition of the list’s elements:
#define VARIABLES \
    X(value1, 1)  \
    .
    .
    .  \
    X(valueN, N)
Expansion(s) of the list to generate fragments of declarations or statements:
#define X(name) int name;
    VARIABLES
#undef X

Advantages of X-Macros
X-Macros are extensively used in Operating System development by creating separate header files for maintainability as well as readability
Helps to maintain complex programming easily
it can create a self-maintaining and inter-dependent piece of code
Disadvantages of X-Macros

The code becomes less readable
Code is complex to understand
Commonly used for internal programming only, like OS programming.


Q:C Program to print environment variables ?
// Most of the C compilers support a third parameter to main which
// store all envorinment variables
int main(int argc, char *argv[], char * envp[])
{
    int i;
    for (i = 0; envp[i] != NULL; i++)
        printf("\n%s", envp[i]);
    getchar();
    return 0;
}


“array” is a “pointer to the first element of array” but “&array” is a “pointer to whole array.

Since “array” is pointer to int, addition of 1 resulted in an address with increment of 4 (assuming int size in your machine is 4 bytes). Since “&array” is pointer to array of 5 ints, addition of 1 resulted in an address with increment of 4 x 5 = 20 = 0x14.

Why C treats array parameters as pointers?
Array parameters treated as pointers because of efficiency. It is inefficient to copy the array data in terms of both memory and time; and most of the times, when we pass an array our intention is to just tell the array we interested in, not to create a copy of the array.

Advantages of an Array in C/C++:
Random access of elements using array index.
Use of less line of code as it creates a single array of multiple elements.
Easy access to all the elements.
Traversal through the array becomes easy using a single loop.
Sorting becomes easy as it can be accomplished by writing less line of code.

Disadvantages of an Array in C/C++:
Allows a fixed number of elements to be entered which is decided at the time of declaration. Unlike a linked list, an array in C is not dynamic.
Insertion and deletion of elements can be costly since the elements are needed to be managed in accordance with the new memory allocation.

No Index Out of bound Checking:
There is no index out of bounds checking in C/C++,

In C, it is not compiler error to initialize an array with more elements than the specified size. BUTT, it gives warning , excess intilizer elements

The elements are stored at contiguous memory locations

In C, it is possible to have array of all types except following.
1) void.
2) functions.

But we can have array of void pointers(void *arr[100];) and function pointers.

3) Arrays are always passed as pointer to functions.
4) A character array initialized with double quoted string has last element as ‘\0’.

5) Like other variables, arrays can be allocated memory in any of the three segments, data, heap, and stack. Dynamically allocated arrays are allocated memory on heap, static or global arrays are allocated memory on data segment and local arrays are allocated memory on stack segment.

 When we assign a struct variable to another, all members of the variable are copied to the other struct variable. But what happens when the structure contains pointer to dynamically allocated memory and what if it contains an array?

 struct variable st1 contains pointer to dynamically allocated memory. When we assign st1 to st2, str pointer of st2 also start pointing to same memory location. This kind of copying is called Shallow Copy.

Now, what about arrays? The point to note is that the array members are not shallow copied, compiler automatically performs Deep Copy for array members.
struct test contains array member str[]. When we assign st1 to st2, st2 has a new copy of the array. So st2 is not changed when we change str[] of st1.


“Array of pointers” is an array of the pointer variables. It is also known as pointer arrays.
Syntax: int *var_name[array_size];

We can likewise make an array of pointers to the character to store a list of strings.

#include <stdio.h>
const int size = 4;
void main()
{
    // array of pointers to a character
    // to store a list of strings
    char* names[] = {
        "amit",
        "amar",
        "ankit",
        "akhil"
    };
    int i = 0;
    for (i = 0; i < size; i++) {
        printf("%s\n", names[i]);
    }
}
Output:
amit
amar
ankit
akhil


int arr[5] = { 1, 2, 3, 4, 5 };
int *ptr = arr;
In this program, we have a pointer ptr that points to the 0th element of the array. Similarly, we can also declare a pointer that can point to whole array instead of only one element of the array. This pointer is useful when talking about multidimensional arrays.
Syntax::   data_type (*var_name)[size_of_array];
Example::  int (*ptr)[10];
Here ptr is pointer that can point to an array of 10 integers. Since subscript have higher precedence than indirection, it is necessary to enclose the indirection operator and pointer name inside parentheses.

Note : The pointer that points to the 0th element of array and the pointer that points to the whole array are totally different. 

    // Pointer to an integer
    int *p;

    // Pointer to an array of 5 integers
    int (*ptr)[5];
    int arr[5];

    // Points to 0th element of the arr.
    p = arr;

    // Points to the whole array arr.
    ptr = &arr;



&array is an alias for &array[0] and returns the address of the first element in array

char array[] = “abc” sets the first four elements in array to ‘a’, ‘b’, ‘c’, and ‘\0’

char *pointer = “abc” sets pointer to the address of the “abc” string (which may be stored in read-only memory and thus unchangeable)

Pointer variable can be assigned a value whereas array variable cannot be.
int a[10];
int *p;
p=a; /*legal*/
a=p; /*illegal*/
Arithmetic on pointer variable is allowed.
p++; /*Legal*/
a++; /*illegal*/


Array parameters treated as pointers because of efficiency. It is inefficient to copy the array data in terms of both memory and time; and most of the times, when we pass an array our intention is to just tell the array we interested in, not to create a copy of the array.

Compiler uses pointer arithmetic to access array element. For example, an expression like “arr[i]” is treated as *(arr + i) by the compiler. That is why the expressions like *(arr + i) work for array arr, and expressions like ptr[i] also work for pointer ptr.

A shorthand array notation in C for repeated values
In C, when there are many repeated values, we can use a shorthand array notation to define array. Below program demonstrates same.
int array[10] = {1, 1, 1, 1, 0, 0, 2, 2, 2, 2};
int array[10] = {[0 ... 3]1, [6 ... 9]2};

The statements ‘char s[] = “geeksquiz”‘ creates a character array which is like any other array and we can do all array operations. The only special thing about this array is, although we have initialized it with 9 elements, its size is 10 (Compiler automatically adds ‘\0’)

The statement ‘char *s = “geeksquiz”‘ creates a string literal. The string literal is stored in the read-only part of memory by most of the compilers. The C and C++ standards say that string literals have static storage duration, any attempt at modifying them gives undefined behaviour.
s is just a pointer and like any other pointer stores address of string literal.

atoi() : The atoi() function takes a character array or string literal as an argument and returns its value. 
atoi() works only for C-style strings (character array and string literal)
Similarly, for converting String to Double, atof() 


How to pass an array by value in C ?
In C, array name represents address and when we pass an array, we actually pass address and the parameter receiving function always accepts them as pointers

How to pass array by value, i.e., how to make sure that we have a new copy of array when we pass it to function?
This can be done by wrapping the array in a structure and creating a variable of type of that structure and assigning values to that array. After that, passing the variable to some other function and modifying it as per requirements. Note that array members are copied when passed as parameter, but dynamic arrays are not. So this solution works only for non-dynamic arrays (created without new or malloc).


The strdup() and strndup() functions are used to duplicate a string.
Syntax : char *strdup(const char *s);

This function returns a pointer to a null-terminated byte string, which is a duplicate of the string pointed to by s. The memory obtained is done dynamically using malloc and hence it can be freed using free().


strndup() :
syntax: char *strndup(const char *s, size_t n);
This function is similar to strdup(), but copies at most n bytes.
Note: If s is longer than n, then only n bytes are copied, and a NULL (”) is added at the end.


strpbrk() in C
This function finds the first character in the string s1 that matches any character specified in s2 (It excludes terminating null-characters).
Syntax :: char *strpbrk(const char *s1, const char *s2)
Parameters ::
s1 : string to be scanned.
s2 : string containing the characters to match.
Return Value ::
It returns a pointer to the character in s1 that
matches one of the characters in s2, else returns NULL.

strcmp() in C/C++
strcmp() is a built-in library function and is declared in <string.h> header file. This function takes two strings as arguments and compare these two strings lexicographically.

This process will be continued until a character in either string is NULL or the characters are unequal.

What does strcmp() return?
This function can return three different integer values based on the comparison:

1)
Zero ( 0 ): A value equal to zero when both strings are found to be identical. That is, That is, All of the characters in both strings are same.

2)
Greater than zero ( >0 ): A value greater than zero is returned when the first not matching character in leftStr have the greater ASCII value than the corresponding character in rightStr or we can also say
If character in leftStr is lexicographically
after the character of rightStr

3)
Less than Zero ( <0 ): A value less than zero is returned when the first not matching character in leftStr have lesser ASCII value than the corresponding character in rightStr.
If character in leftStr is lexicographically
before the character of rightStr

Important point : When the strings are not same, you will find that the value returned by the strcmp() function is the difference between the ASCII values of first unmatched character in leftStr and rightStr in both the cases.

strcpy() is a standard library function in C/C++ and is used to copy one string to another. 
Syntax:
char* strcpy(char* dest, const char* src);

The term “punctuation” as defined by this function includes all printable characters that are neither alphanumeric nor a space. For example ‘@’, ‘$’, etc.


strspn() function in C
The strspn() function returns the length of the initial substring of the string pointed to by str1 that is made up of only those character contained in the string pointed to by str2.

Syntax :: size_t strspn(const char *str1, const char *str2)
str1 : string to be scanned.
str2 : string containing the characters to match.
Return Value : This function returns the number of characters in the initial segment of str1 which consist only of characters from str2.

strtok() and strtok_r() functions in C with examples
C provides two functions strtok() and strtok_r() for splitting a string by some delimiter. Splitting a string is a very common task. For example, we have a comma separated list of items from a file and we want individual items in an array.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

When the continue statement is executed in the loop, the code inside the loop following the continue statement will be skipped and next iteration of the loop will begin.

Nested Loops: We can also use break statement while working with nested loops. If the break statement is used in the innermost loop. The control will come out only from the innermost loop.

Infinite Loops: break statement can be included in an infinite loop with a condition in order to terminate the execution of the infinite loop.

What happens if loop till Maximum of Signed and Unsigned in C/C++?

    unsigned char i;
    for (i=0; i<256; i++)
        printf("%d ",i);

We know that the size of the character variable is 8 bits or 1 byte. Hence by base 2 representation of decimal numbers, the maximum number in 8 bits is 11111111.This is because the range of unsigned numbers in 8 bits ranges from 0 to 28-1
Now (11111111)2 = (255)10
If we drive the loop upto 255 starting from 0, it will execute the statement in the loop 256 times (both 0 and 255 inclusive). As the loop reaches to (255)10, After executing it, the variable “i” is incremented by 1 i.e. going by the 2s complement arithmetic,
(11111111)2 + (00000001)2 = (00000000)10

Note: the end carry is discarded in this case; hence the final incremented number is 0, which results in re-execution of the loop, hence the loop runs for the infinite times. Therefore the above condition can be avoided if we put limit to unsigned char i to be lesser than 255 rather than 256.


    signed char i;
    for (i=0; i<128; i++)
        printf("%d ",i);

Signed char range belongs from -27 to 27-1, hence it also goes for the infinite execution if the limit is <128.

Note that the 2s complement of (127)10 is (01111111)2 adding 1 to which will give us (10000000)2, which is –(128)10 when calculated from 2s complement form.


The goto statement is a jump statement which is sometimes also referred to as unconditional jump statement. The goto statement can be used to "jump from anywhere to anywhere within a function".

Syntax:
Syntax1      |   Syntax2
----------------------------
goto label;  |    label:
.            |    .
.            |    .
.            |    .
label:       |    goto label;

Suppose we need to write a program which prints numbers from 1 to 10 using the goto statement.

Use of goto can be simply avoided using break and continue statements.


Important Points:

Use for loop when number of iterations is known beforehand, i.e. the number of times the loop body is needed to be executed is known.

Use while loops where exact number of iterations is not known but the loop termination condition is known.

Use do while loop if the code needs to be executed at least once like in Menu driven programs


A nested loop puzzle
Which of the following two code segments is faster? Assume that compiler makes no optimizations.

/* FIRST */
for(i=0;i<10;i++)
  for(j=0;j<100;j++)
    //do something

/* SECOND */
for(i=0;i<100;i++)
  for(j=0;j<10;j++)
    //do something
Both code segments provide same functionality, and the code inside the two for loops would be executed same number of times in both code segments.
If we take a closer look then we can see that the SECOND does more operations than the FIRST. It executes all three parts (assignment, comparison and increment) of the for loop more times than the corresponding parts of FIRST:

The SECOND executes assignment operations ( j = 0 or i = 0) 101 times while FIRST executes only 11 times.
The SECOND does 101 + 1100 comparisons (i < 100 or j < 10) while the FIRST does 11 + 1010 comparisons (i < 10 or j < 100).
The SECOND executes 1100 increment operations (i++ or j++) while the FIRST executes 1010 increment operation.

Below C++ code counts the number of increment operations executed in FIRST and SECOND, and prints the counts.
//program to count number of increment
//operations in FIRST and SECOND
#include<iostream>
using namespace std;
int main()
{
  int c1 = 0, c2 = 0;

  /* FIRST */
  for(int i=0;i<10;i++,c1++)
    for(int j=0;j<100;j++, c1++);
      //do something

  /* SECOND */
  for(int i=0; i<100; i++, c2++)
      for(int j=0; j<10; j++, c2++);
        //do something

  cout << " Count in FIRST = " <<c1 << endl;
  cout << " Count in SECOND  = " <<c2 << endl;

  getchar();
  return 0;
}
Output:
Count in FIRST = 1010
 Count in SECOND  = 1100

Below C++ code counts the number of comparison operations executed by FIRST and SECOND
//program to count the number of comparison
//operations executed by FIRST and SECOND */
#include<iostream>

using namespace std;

int main()
{
   int c1 = 0, c2 = 0;
   /* FIRST */
   for(int i=0; ++c1&&i<10; i++)
      for(int j=0; ++c1&&j<100;j++);
     //do something
   /* SECOND */
   for(int i=0; ++c2&&i<100; i++)
      for(int j=0; ++c2&&j<10; j++);
      //do something

   cout << " Count fot FIRST  " <<c1 << endl;
   cout << " Count fot SECOND  " <<c2 << endl;
   getchar();
   return 0;
}
Output:
Count fot FIRST  1021
 Count fot SECOND  1201


Switch case statements are a substitute for long if-else statements that compare a variable to several integral values
Switch is a control statement that allows a value to change control of execution.

The expression provided in the switch should result in a constant value otherwise it would not be valid.

Valid expressions for switch:
// Constant expressions allowed
switch(1+2+23)
switch(1*2+3%4)

// Variable expression are allowed provided
// they are assigned with fixed values
switch(a*b+c*d)
switch(a+b+c)

Duplicate case values are not allowed.
The default statement is optional

The break statement is used inside the switch to terminate a statement sequence. When a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement.

The break statement is optional. If omitted, execution will continue on into the next case. The flow of control will fall through to subsequent cases until a break is reached.

1) The expression used in switch must be integral type ( int, char and enum). Any other type of expression is not allowed.

3) The default block can be placed anywhere. The position of default doesn’t matter, it is still executed if no match found.

4) The integral expressions used in labels must be a constant expressions
// A program with variable expressions in labels
#include <stdio.h>
int main()
{
    int x = 2;
    int arr[] = {1, 2, 3};
    switch (x)
    {
        case arr[0]: printf("Choice 1\n");
        case arr[1]: printf("Choice 2\n");
        case arr[2]: printf("Choice 3\n");
    }
    return 0;
}
Output:
Compiler Error: case label does not reduce to an integer constant

5) The statements written above cases are never executed After the switch statement, the control transfers to the matching case, the statements written before case are not executed.

6) Two case labels cannot have same value

You all are familiar with switch case in C/C++, but did you know you can use range of numbers instead of a single number or character in case statement.

That is the case range extension of the GNU C compiler and not standard C or C++
You can specify a range of consecutive values in a single case label, like this:
case low ... high:
It can be used for ranges of ASCII character codes like this:
 case 'A' ... 'Z':
You need to Write spaces around the ellipses … . For example, write this:
// Correct  -   case 1 ... 5:
// Wrong -    case 1...5:

Error conditions:
low > high : The compiler gives with an error message.
Overlapping case values : If the value of a case label is within a case range that has already been used in the switch statement, the compiler gives an error message.

If a reference of a function is passed to another function as an argument to call it, then it will be called as a Callback function.
In C, a callback function is a function that is called through a function pointer.

// A simple C program to demonstrate callback
#include<stdio.h>

void A()
{
    printf("I am function A\n");
}

// callback function
void B(void (*ptr)())
{
    (*ptr) (); // callback to A
}

int main()
{
    void (*ptr)() = &A;

    // calling function B and passing
    // address of the function A as argument
    B(ptr);

   return 0;
}


exit() terminates the process normally.
status: Status value returned to the parent process. Generally, a status value of 0 or EXIT_SUCCESS indicates success, and any other value or the constant EXIT_FAILURE is used to indicate an error. 

exit() performs following operations.
* Flushes unwritten buffered data.
* Closes all open files.
* Removes temporary files.
* Returns an integer exit status to the operating system.

The C standard atexit() function can be used to customize exit() to perform additional actions at program termination

When exit() is called, any open file descriptors belonging to the process are closed and any children of the process are inherited by process 1, init, and the process parent is sent a SIGCHLD signal.

The mystery behind exit() is that it takes only integer args in the range 0 – 255 . Out of range exit values can result in unexpected exit codes. An exit value greater than 255 returns an exit code modulo 256.
For example, exit 9999 gives an exit code of 15 i.e. (9999 % 256 = 15).


void abort ( void );

Unlike exit() function, abort() may not close files that are open. It may also not delete temporary files and may not flush stream buffer. Also, it does not call functions registered with atexit().
If we want to make sure that data is written to files and/or buffers are flushed then we should either use exit() or include a signal handler for SIGABRT.
This function actually terminates the process by raising a SIGABRT signal, and your program can include a handler to intercept this signal

void assert( int expression );
If expression evaluates to 0 (false), then the expression, sourcecode filename, and line number are sent to the standard error, and then abort() function is called. If the identifier NDEBUG (“no debug”) is defined with #define NDEBUG then the macro assert does nothing.

Now the question is that if we have exit() function then why C11 standard introduced _Exit()? Actually exit() function performs some cleaning before termination of the program like connection termination, buffer flushes etc. The _Exit() function in C/C++ gives normal termination of a program without performing any cleanup tasks. For example it does not execute functions registered with atexit.

What is evaluation order of function parameters in C?
It is compiler dependent in C. It is never safe to depend on the order of evaluation of side effects. 

func (i++, i++);
There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. func might get the arguments `2, 3′, or it might get `3, 2′, or even `2, 2′.

3) In C, functions can return any type except arrays and functions. We can get around this limitation by returning pointer to array or pointer to function.

Functions help us in reducing code redundancy. If functionality is performed at multiple places in software, then rather than writing the same code, again and again, 

This also helps in maintenance as we have to change at one place if we make future changes to the functionality.

Functions make code modular. Consider a big file having many lines of codes. It becomes really simple to read and use the code if the code is divided into functions.
Functions provide abstraction. For example, we can use library functions without worrying about their internal working.

Pass by Value: In this parameter passing method, values of actual parameters are copied to function’s formal parameters and the two types of parameters are stored in different memory locations. So any changes made inside functions are not reflected in actual parameters of caller.


Pass by Reference Both actual and formal parameters refer to same locations, so any changes made inside the function are actually reflected in actual parameters of caller.
However, in C, we can use pointers to get the effect of pass by reference.

Moreover, if the return type of the function is void, we still can use return statement in the body of function definition by not specifying any constant, variable, etc. with it, by only mentioning the ‘return;’ statement which would symbolise the termination of the function

5)If in a C program, a function is called before its declaration then the C compiler automatically assumes the declaration of that function in the following way:
int function name();
And in that case if the return type of that function is different than INT ,compiler would show an error.

What is the purpose of a function prototype?
The Function prototype serves the following purposes –

1) It tells the return type of the data that the function will return.
2) It tells the number of arguments passed to the function.
3) It tells the data types of the each of the passed arguments.
4) Also it tells the order in which the arguments are passed to the function.

Therefore essentially, function prototype specifies the input/output interlace to the function i.e. what to give to the function and what to expect from the function.

Functions that are executed before and after main() in C .

So some startup code can be executed before main() starts, and some cleanup code can be executed after main() ends. For example, in the following program, myStartupFun() is called before main() and myCleanupFun() is called after main().

#include<stdio.h>

/* Apply the constructor attribute to myStartupFun() so that it
    is executed before main() */
void myStartupFun (void) __attribute__ ((constructor));

/* Apply the destructor attribute to myCleanupFun() so that it
   is executed after main() */
void myCleanupFun (void) __attribute__ ((destructor));
/* implementation of myStartupFun */
void myStartupFun (void)
{
    printf ("startup code before main()\n");
}
/* implementation of myCleanupFun */
void myCleanupFun (void)
{
    printf ("cleanup code after main()\n");
}
int main (void)
{
    printf ("hello\n");
    return 0;
}
Output:
startup code before main()
hello
cleanup code after main()

In C, if we do not specify a return type, compiler assumes an implicit return type as int. However, C99 standard doesn’t allow return type to be omitted even if return type is int. This was allowed in older C standard C89.

 functions are global by default. The “static” keyword before a function name makes it static. For example, below function fun() is static.
static int fun(void)
{
  printf("I am a static function ");
}
Unlike global functions in C, access to static functions is restricted to the file where they are declared. Therefore, when we want to restrict access to functions, we make them static. Another reason for making functions static can be reuse of the same function name in other files.

Nested function is not supported by C because we cannot define a function within another function in C. We can declare a function inside a function, but it’s not a nested function.
Because nested functions definitions can not access local variables of the surrounding blocks, they can access only global variables of the containing module. This is done so that lookup of global variables doesn’t have to go through the directory. As in C, there are two nested scopes: local and global (and beyond this, built-ins). Therefore, nested functions have only a limited use. If we try to approach nested function in C, then we will get compile time error.


// C program to illustrate the
// concept of Nested function.
#include <stdio.h>
int main(void)
{
    printf("Main");
    int fun()
    {
        printf("fun");
        // defining view() function inside fun() function.
        int view()
        {
            printf("view");
        }
        return 1;
    }
    view();
}
Output:
Compile time error: undefined reference to `view'


An extension of the GNU C Compiler allows the declarations of nested functions. The declarations of nested functions under GCC’s extension need to be prefix/start with the auto keyword.

// C program of nested function
// with the help of gcc extension
#include <stdio.h>
int main(void)
{
    auto int view(); // declare function with auto keyword
    view(); // calling function
    printf("Main\n");
    int view()
    {
        printf("View\n");
        return 1;
    }
    printf("GEEKS");
    return 0;
}
Output:
view
Main
GEEKS


Executing main() in C/C++ – behind the scene
How to write a C program to print “Hello world” without main() function?
At first, it seems impractical to execute a program without a main() function because the main() function is the entry point of any program.

Let us first understand what happens under the hood while executing a C program in Linux system, how main() is called and how to execute a program without main().

Following setup is considered for the demonstration.

Ubuntu 16.4 LTS operating system
GCC 5.4.0 compiler
objdump utility
From C/C++ programming perspective, the program entry point is main() function. From the perspective of program execution, however, it is not.

Prior to the point when the execution flow reaches to the main(), calls to few other functions are made, which setup arguments, prepare environment variables for program execution etc.

The executable file created after compiling a C source code is a Executable and Linkable Format (ELF) file.
Every ELF file have a ELF header where there is a e_entry field which contains the program memory address from which the execution of executable will start. This memory address point to the _start() function.
After loading the program, loader looks for the e_entry field from the ELF file header. Executable and Linkable Format (ELF) is a common standard file format used in UNIX system for executable files, object code, shared libraries, and core dumps.

Let’s see this using an example. I’m creating a example.c file to demonstrate this.

int main()
{
   return(0);
}
Now compiling this using following commands

gcc -o example example.c
Now an example executable is created, let us examine this using objdump utility

objdump -f example
This outputs following critical information of executable on my machine. Have a look at start address below, this is the address pointing to _start() function.

example:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000004003e0
We can cross check this address by deassembling the executable, the output is long so I’m just pasting the output which shows where this address 0x00000000004003e0 is pointing

objdump --disassemble  example
Output :

00000000004003e0 <_start>:
  4003e0:       31 ed                   xor    %ebp,%ebp
  4003e2:       49 89 d1                mov    %rdx,%r9
  4003e5:       5e                      pop    %rsi
  4003e6:       48 89 e2                mov    %rsp,%rdx
  4003e9:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  4003ed:       50                      push   %rax
  4003ee:       54                      push   %rsp
  4003ef:       49 c7 c0 60 05 40 00    mov    $0x400560,%r8
  4003f6:       48 c7 c1 f0 04 40 00    mov    $0x4004f0,%rcx
  4003fd:       48 c7 c7 d6 04 40 00    mov    $0x4004d6,%rdi
  400404:       e8 b7 ff ff ff          callq  4003c0
  400409:       f4                      hlt
  40040a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
As we can clearly see this is pointing to the _start() function.

The role of _start() function
The _start() function prepare the input arguments for another function _libc_start_main() which will be called next. This is prototype of _libc_start_main() function. Here we can see the arguments which were prepared by _start() function.

int __libc_start_main(int (*main) (int, char * *, char * *), /* address of main function*/
int argc, /* number of command line args*/
char ** ubp_av, /* command line arg array*/
void (*init) (void), /* address of init function*/
void (*fini) (void), /* address of fini function*/
void (*rtld_fini) (void), /* address of dynamic linker fini function */
void (* stack_end) /* end of the stack address*/
);
The role of _libc_start_main() function
The role of _libs_start_main() function is following –

Preparing environment variables for program execution
Calls _init() function which performs initialization before the main() function start.
Register _fini() and _rtld_fini() functions to perform cleanup after program terminates
After all the prerequisite actions has been completed, _libc_start_main() calls the main() function.
Writing program without main()
Now we know how the call to the main() is made.To make it clear, main() is nothing but a agreed term for startup code. We can have any name for startup code it doesn’t necessarily have to be “main”. As _start() function by default calls main(), we have to change it if we want to execute our custom startup code. We can override the _start() function to make it call our custom startup code not main(). Let’s have an example, save it as nomain.c –

#include<stdio.h>
#include<stdlib.h>
void _start()
{
    int x = my_fun(); //calling custom main function
    exit(x);
}

int my_fun() // our custom main function
{
    printf("Hello world!\n");
    return 0;
}
Now we have to force compiler to not use it’s own implementation of _start().In GCC we can do this using -nostartfiles

gcc -nostartfiles -o nomain nomain.c
Execute the executable nomain

./nomain
Output:
Hello world!



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Dangling pointer
A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer.
 There are three different ways where Pointer acts as dangling pointer
1)Deallocating(free) a memory pointed by ptr causes dangling pointer
2)Function Call
 The pointer pointing to local variable becomes dangling when local variable is not static.
3) Variable goes out of scope
void main()
{
   int *ptr;
   .....
   .....
   {
       int ch;
       ptr = &ch;
   }
   .....
   // Here ptr is dangling pointer
}


How to declare a pointer to a function?
int foo(int);
Here foo is a function that returns int and takes one argument of int type. So as a logical guy will think, by putting a * operator between int and foo(int) should create a pointer to a function i.e.

int * foo(int);
But Oops..C operator precedence also plays role here ..so in this case, operator () will take priority over operator *. And the above declaration will mean – a function foo with one argument of int type and return value of int * i.e. integer pointer. So it did something that we didn’t want to do. 🙁

So as a next logical step, we have to bind operator * with foo somehow. And for this, we would change the default precedence of C operators using () operator.
int (*foo)(int);

    // fun_ptr is a pointer to function fun()
    void (*fun_ptr)(int) = &fun;

    /* The above line is equivalent of following two
       void (*fun_ptr)(int);
       fun_ptr = &fun;
    */
    // Invoking fun() using fun_ptr
    (*fun_ptr)(10);

Following are some interesting facts about function pointers.
1) Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code.

2) Unlike normal pointers, we do not allocate de-allocate memory using function pointers.

3) A function’s name can also be used to get functions’ address.we have removed address operator ‘&’ in assignment. We have also changed function call by removing *, the program still works.
        void (*fun_ptr)(int) = fun; // & removed
        fun_ptr(10); // * removed

4) Like normal pointers, we can have an array of function pointers


Level-N pointer can only be used to point level-(N-1) pointer. Except for Level-1 pointer. The level-1 pointer will always point to the variable.


What are near, far and huge pointers?

These are some old concepts used in 16 bit intel architectures in the days of MS DOS, not much useful anymore.
Near pointer is used to store 16 bit addresses means within current segment on a 16 bit machine. The limitation is that we can only access 64kb of data at a time.
A far pointer is typically 32 bit that can access memory outside current segment.  To use this, compiler allocates a segment register to store segment address, then another register to store offset within current segment.
Like far pointer, huge pointer is also typically 32 bit and can access outside segment. In case of far pointers, a segment is fixed. In far pointer, the segment part cannot be modified, but in Huge it can be


NULL Pointer
“An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.”

NULL Pointer is a pointer which is pointing to nothing. In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL.


Important Points
NULL vs Uninitialized pointer – An uninitialized pointer stores an undefined value. A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object.
NULL vs Void Pointer – Null pointer is a value, while void pointer is a type


a) To initialize a pointer variable when that pointer variable isn’t assigned any valid memory address yet.
b) To check for a null pointer before accessing any pointer variable.
   By doing so, we can perform error handling in pointer related code e.g. dereference pointer variable only if it’s not NULL.
c) To pass a null pointer to a function argument when we don’t want to pass any valid memory address.

Coming to our discussion, NULL macro is defined as ((void *)0) in header files of most of the C compiler implementations. But C standard is saying that 0 is also a null pointer constant. It means that the following is also perfectly legal as per standard.

int * ptr = 0;

Please note that 0 in the above C statement is used in pointer-context and it’s different from 0 as integer. This is one of the reasons why the usage of NULL is preferred because it makes it explicit in code that programmer is using null pointer, not integer 0

You can try few other things in above program such as printf(“‘%c“,NULL) or printf(“%s”,NULL) and even printf(“%f”,NULL). The outputs of these are going to be different depending on the platform used but it’d be interesting especially usage of %f with NULL!

Can we use sizeof() operator on NULL in C? Well, usage of sizeof(NULL) is allowed but the exact size would depend on platform.

Since NULL is defined as ((void*)0), we can think of NULL as a special pointer and its size would be equal to any pointer. If the pointer size of a platform is 4 bytes, the output of the above program would be 4. But if pointer size on a platform is 8 bytes, the output of the above program would be 8.

If an argument to a function has an invalid value (such as a value outside the domain of the function, or a pointer outside the address space of the program, or a null pointer, or a pointer to non-modifiable storage when the corresponding parameter is not const-qualified) or a type (after promotion) not expected by a function with variable number of arguments, the behavior is undefined.


Opaque pointer is a pointer which points to a data structure whose contents are not exposed at the time of its definition.
Following pointer is opaque. One can’t know the data contained in STest structure by looking at the definition.
struct STest* pSTest;
It is safe to assign NULL to an opaque pointer.

Pointer Expressions and Pointer Arithmetic
A limited set of arithmetic operations can be performed on pointers. A pointer may be:

incremented ( ++ )
decremented ( — )
an integer may be added to a pointer ( + or += )
an integer may be subtracted from a pointer ( – or -= )


Pointer arithmetic is meaningless unless performed on an array.
Note : Pointers contain addresses. Adding two addresses makes no sense, because there is no idea what it would point to. Subtracting two addresses lets you compute the offset between these two addresses

Pointers store address of variables or a memory location.

we use the unary operator & (ampersand) that returns the address of that variable.
 When a pointer variable is declared in C/C++, there must a * before its name.
To access the value stored in the address we use the unary operator (*) that returns the value of the variable located at the address specified by its operand.

What is Memory Leak? How can we avoid?
Memory leak occurs when programmers create a memory in heap and forget to delete it.
Memory leaks are particularly serious issues for programs like daemons and servers which by definition never terminate
To avoid memory leaks, memory allocated on heap should always be freed when no longer needed.


There is possibility of potential error while dealing with pointer arithmetic. For example, dereferencing a generic pointer (void *) as shown below can cause misaligned exception,

A note on malloc() returned pointer

The pointer returned by malloc() is void *. It can be converted to any data type as per the need of programmer. The implementer of malloc() should return a pointer that is aligned to maximum size of primitive data types (those defined by compiler). It is usually aligned to 8 byte boundary on 32 bit machines.


Array Name as Pointers
An array name acts like a pointer constant. The value of this pointer constant is the address of the first element
For example, if we have an array named val then val and &val[0] can be used interchangeably.

Array parameters treated as pointers because of efficiency. It is inefficient to copy the array data in terms of both memory and time; and most of the times, when we pass an array our intention is to just tell the array we interested in, not to create a copy of the array.

Now if you replace arr[0] with 0[arr], the output would be same.
Because compiler converts the array operation in pointers before accessing the array elements.

e.g. arr[0] would be *(arr + 0) and therefore 0[arr] would be *(0 + arr) and you know that both *(arr + 0) and *(0 + arr) are same.

Pointer vs Array in C

Most of the time, pointer and array accesses can be treated as acting the same, the major exceptions being:

1) the sizeof operator
o sizeof(array) returns the amount of memory used by all elements in array
o sizeof(pointer) only returns the amount of memory used by the pointer variable itself

2) the & operator
o &array is an alias for &array[0] and returns the address of the first element in array
o &pointer returns the address of pointer

3) a string literal initialization of a character array
o char array[] = “abc” sets the first four elements in array to ‘a’, ‘b’, ‘c’, and ‘\0’
o char *pointer = “abc” sets pointer to the address of the “abc” string (which may be stored in read-only memory and thus unchangeable)

4) Pointer variable can be assigned a value whereas array variable cannot be.

int a[10];
int *p;
p=a; /*legal*/
a=p; /*illegal*/
5) Arithmetic on pointer variable is allowed.

p++; /*Legal*/
a++; /*illegal*/


int const* is pointer to const int
int *const is const pointer to int
int const* const is const pointer to const int
Using this rule, even complex declarations can be decoded like,

int ** const is a const pointer to pointer to an int.
int * const * is a pointer to const pointer to an int.
int const ** is a pointer to a pointer to a const int.
int * const * const is a const pointer to a const pointer to an int.

The qualifier const can be applied to the declaration of any variable to specify that its value will not be changed. const keyword applies to whatever is immediately to its left. If there is nothing to its left, it applies to whatever is immediately to its right.

NOTE: There is no difference between const char *p and char const *p as both are pointer to a const char and position of ‘*'(asterik) is also same.

char *const ptr : This is a constant pointer to non-constant character. You cannot change the pointer p, but can change the value pointed by ptr.

char const * const ptr is same as const char *const ptr.

In general, nums[i][j] is equivalent to *(*(nums+i)+j)



restrict keyword in C
In the C programming language (after 99 standard), a new keyword is introduced known as restrict.

restrict keyword is mainly used in pointer declarations as a type qualifier for pointers.
It doesn’t add any new functionality. It is only a way for programmer to inform about an optimizations that compiler can make.
When we use restrict with a pointer ptr, it tells the compiler that ptr is the only way to access the object pointed by it and compiler doesn’t need to add any additional checks.

If a programmer uses restrict keyword and violate the above condition, result is undefined behavior.
restrict is not supported by C++. It is a C only keyword.


pointers:To pass arguments by reference. Passing by reference serves two purposes
(i) To modify variable of function in other. Example to swap two variables;
(ii) For efficiency purpose. Example passing large structure without reference would create a copy of the structure (hence wastage of space).

Dynamic memory allocation : We can use pointers to dynamically allocate memory. The advantage of dynamically allocated memory is, it is not deleted until we explicitly delete it.

To implement data structures.
Example linked list, tree, etc. We cannot use C++ references to implement these data structures because references are fixed to a location (For example, we can not traverse a linked list using references)

To do system level programming where memory addresses are useful. For example shared memory used by multiple threads. For more examples, see IPC through shared memory, Socket Programming in C/C++, etc

Features of Pointers:

Pointers save memory space.
Execution time with pointers is faster because data are manipulated with the address, that is, direct access to
memory location.
Memory is accessed efficiently with the pointers. The pointer assigns and releases the memory as well. Hence it can be said the Memory of pointers is dynamically allocated.
Pointers are used with data structures. They are useful for representing two-dimensional and multi-dimensional
arrays.
An array, of any type can be accessed with the help of pointers, without considering its subscript range.
Pointers are used for file handling.
Pointers are used to allocate memory dynamically.

Void pointer is a specific pointer type – void * – a pointer that points to some data location in storage, which doesn’t have any specific type. Void refers to the type. Basically the type of data that it points to is can be any. If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. Any pointer type is convertible to a void pointer hence it can point to any value.

void pointers cannot be dereferenced. 
Compiler Error: 'void*' is not a pointer-to-object type

It can however be done using typecasting the void pointer
Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size.

Advantages of void pointers:
1) malloc() and calloc() return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *)
we must explicitly typecast return value of malloc

2) void pointers in C are used to implement generic functions in C.


What are Wild Pointers? How can we avoid?
Uninitialized pointers are known as wild pointers because they point to some arbitrary memory location and may cause a program to crash or behave badly.

a pointer p points to a known variable then it’s not a wild pointer, p is a wild pointer till this points to variable.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Enumeration (or enum) is a user defined data type in C. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain.

The keyword ‘enum’ is used to declare new enumeration types.
enum flag{constant1, constant2, constant3, ....... };


Variables of type enum can also be defined.
enum week{Mon, Tue, Wed};
enum week day;
// Or
enum week{Mon, Tue, Wed}day;


#define statements are handled by the pre-processor before the compiler gets to see the code whereas enums are part of the C language itself and have the following advantages. They may have type and the compiler can type-check them. Since they are available to the compiler, symbol information on them can be passed through to the debugger, making debugging easier

Constants allow you to specify a datatype, which is (usually) an advantage. Macros are much more flexible, and therefore can get you into much more trouble if you're not careful.

#include<stdio.h>
enum year{Jan, Feb, Mar, Apr, May, Jun, Jul,
          Aug, Sep, Oct, Nov, Dec};
int main()
{
   int i;
   for (i=Jan; i<=Dec; i++)
      printf("%d ", i);

   return 0;
}
Output:
0 1 2 3 4 5 6 7 8 9 10 11

1)Two enum names can have same value. For example, in the following C program both ‘Failed’ and ‘Freezed’ have same value 0.

#include <stdio.h>
enum State {Working = 1, Failed = 0, Freezed = 0};
int main()
{
   printf("%d, %d, %d", Working, Failed, Freezed);
   return 0;
}
Output:
1, 0, 0

2. If we do not explicitly assign values to enum names, the compiler by default assigns values starting from 0


3. We can assign values to some name in any order. All unassigned names get value as value of previous name plus one.


#include <stdio.h>
enum day {sunday = 1, monday, tuesday = 5,
          wednesday, thursday = 10, friday, saturday};
int main()
{
    printf("%d %d %d %d %d %d %d", sunday, monday, tuesday,
            wednesday, thursday, friday, saturday);
    return 0;
}
Output:
1 2 5 6 10 11 12


4. The value assigned to enum names must be some integeral constant, i.e., the value must be in range from minimum possible integer value to maximum possible integer value.

5. All enum constants must be unique in their scope. For example, the following program fails in compilation.

enum state  {working, failed};
enum result {failed, passed};
int main()  { return 0; }

Output:
Compile Error: 'failed' has a previous declaration as 'state failed'

Program 1:
#include <stdio.h>
enum day {sunday = 1, tuesday, wednesday, thursday, friday, saturday};
int main()
{
    enum day d = thursday;
    printf("The day number stored in d is %d", d);
    return 0;
}
output:: The day number stored in d is 4

Program 2:
#include <stdio.h>
enum State {WORKING = 0, FAILED, FREEZED};
enum State currState = 2;
enum State FindState() {
    return currState;
}
int main() {
   (FindState() == WORKING)? printf("WORKING"): printf("NOT WORKING");
   return 0;
}
output:: NOT WORKING


Enum vs Macro
We can also use macros to define names constants.
There are multiple advantages of using enum over macro when many related named constants have integral values.
a) Enums follow scope rules.
b) Enum variables are automatically assigned values.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

union is a user defined data type. In union, all members share the same memory location.
How is the size of union decided by compiler?
Size of a union is taken according the size of largest member in union.

union test3 {
    int arr[10];
    char y;
} Test3;

sizeof(test3) = 40

#include <stdio.h> 
union test { 
    int x;
    char y;
};


int main()
{
    union test p1;
    p1.x = 65;

    // p2 is a pointer to union p1
    union test* p2 = &p1;

    // Accessing union members using pointer
    printf("%d %c", p2->x, p2->y);
    return 0;
}
Output:
65 A


Similarities between Structure and Union

Both are user-defined data types used to store data of different types as a single unit.
Their members can be objects of any type, including other structures and unions or arrays. A member can also consist of a bit field.
Both structures and unions support only assignment = and sizeof operators. The two structures or unions in the assignment must have the same members and member types.

A structure or a union can be passed by value to functions and returned by value by functions. The argument must have the same type as the function parameter. A structure or union is passed by value just like a scalar variable as a corresponding parameter.
‘.’ operator is used for accessing members.

differences
1)keyword:: struct  || union

2)size:: greater or eqaul to sum of structure members || largest member in union

3)compiler::  when a variable is associated with structure, compiler considers all memebers and allocates memory for each member || when a variable is associated with union, compiler allocates memory by considering size of the largest element

4)altering value:: one member value has no effect on other member value || alteriing value of any member will have values altered for all members in union

5)accessing
4)initializing


What are applications of union?
Unions can be useful in many situations where we want to use the same memory for two or more members. For example, suppose we want to implement a binary tree data structure where each leaf node has a double data value, while each internal node has pointers to two children, but no data. If we declare this as:

struct NODE {
    struct NODE* left;
    struct NODE* right;
    double data;
};
then every node requires 16 bytes, with half the bytes wasted for each type of node. On the other hand, if we declare a node as following, then we can save space.

struct NODE {
    bool is_leaf;
    union {
        struct
        {
            struct NODE* left;
            struct NODE* right;
        } internal;
        double data;
    } info;
};


Anonymous Union and Structure in C
In C11 standard of C, anonymous Unions and structures were added.

Anonymous unions/structures are also known as unnamed unions/structures as they don’t have names. Since there is no names, direct objects(or variables) of them are not created and we use them in nested structure or unions.

Definition is just like that of a normal union just without a name or tag. For example,

// Anonymous union example
union
{
   char alpha;
   int num;
};
// Anonymous structure example
struct
{
   char alpha;
   int num;
};
Since there is no variable and no name, we can directly access members. This accessibility works only inside the scope where the anonymous union is defined.



Following is a complete working example of anonymous union.

// C Program to demonstrate working of anonymous union
#include<stdio.h>
struct Scope
{
    // Anonymous union
    union
    {
        char alpha;
        int num;
    };
};

int main()
{
    struct Scope x;
    x.num = 65;

    // Note that members of union are accessed directly
    printf("x.alpha = %c, x.num = %d", x.alpha, x.num);

    return 0;
}
Output:
x.alpha = A, x.num = 65


// C Program to demonstrate working of anonymous struct
#include<stdio.h>
struct Scope
{
    // Anonymous structure
    struct
    {
        char alpha;
        int num;
    };
};

int main()
{
    struct Scope x;
    x.num = 65;
    x.alpha = 'B';

    // Note that members of structure are accessed directly
    printf("x.alpha = %c, x.num = %d", x.alpha, x.num);

    return 0;
}
Output:
x.alpha = B, x.num = 65


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Bit Fields in C
In C, we can specify size (in bits) of structure and union members. The idea is to use memory efficiently when we know that the value of a field or group of fields will never exceed a limit or is withing a small range.

must be aware of signed number while using bit fields...
therefore try to use the unsigned number in the bit feilds


Following are some interesting facts about bit fields in C.
4) Use bit fields in C to figure out a way whether a machine is little-endian or big-endian.
1) A special unnamed bit field of size 0 is used to force alignment on next boundary. For example consider the following program.

#include <stdio.h>
// A structure without forced alignment
struct test1 {
        unsigned int x : 5;
        unsigned int y : 8;
};
// A structure with forced alignment
struct test2 {
        unsigned int x : 5;
        unsigned int : 0;
        unsigned int y : 8;
};
int main()
{
        printf("Size of test1 is %lu bytes\n",
                sizeof(struct test1));
        printf("Size of test2 is %lu bytes\n",
                sizeof(struct test2));
        return 0;
}
Output:
Size of test1 is 4 bytes
Size of test2 is 8 bytes

2) We cannot have pointers to bit field members as they may not start at a byte boundary.
3) It is implementation defined to assign an out-of-range value to a bit field member.
#include <stdio.h>
struct test {
    unsigned int x : 2;
    unsigned int y : 2;
    unsigned int z : 2;
};
int main()
{
    struct test t;
    t.x = 5;
    printf("%d", t.x);
    return 0;
}
Output:
main.c:10:11: warning: large integer implicitly truncated to unsigned type [-Woverflow]
1
//Implementation-Dependent
//if t.x=4; then output=0; so only data is  stored in two bits (last two bits of the binary representation of integer value)

5) Array of bit fields is not allowed. For example, the below program fails in the compilation.

struct test {
    unsigned int x[10] : 5;
};
int main()
{
}
Output:
prog.c:3:1: error: bit-field 'x' has invalid type
 unsigned int x[10]: 5;
 ^




main.c:4:15: error: width of ‘y’ exceeds its type
  unsigned int y : 33;
               ^
main.c:5:9: error: bit-field ‘y’ has invalid type
  double y : 5 ;
         ^
main.c:5:8: error: bit-field ‘y’ has invalid type
  float y : 5 ;
        ^



#include <stdio.h>
struct test {
        unsigned int x;
        long long int y : 5 ;
        unsigned int z;
};
int main()
{
        struct test t;
        unsigned int* ptr1 = &t.x;
        unsigned int* ptr2 = &t.z;
        printf("%ld", ptr2 - ptr1);
        return 0;
}

2


#include <stdio.h>
struct test {
        unsigned int x;
        int y  ;
         int h  ;
        unsigned int z;
};
int main()
{
        struct test t;
        unsigned int* ptr1 = &t.x;
        unsigned int* ptr2 = &t.z;
        printf("%ld", ptr2 - ptr1);
        return 0;
}
3



#include <stdio.h>
struct test {
        unsigned int x;
        int y : 1 ;
         int h  :1;
        unsigned int z;
};
int main()
{
        struct test t;
        unsigned int* ptr1 = &t.x;
        unsigned int* ptr2 = &t.z;
        printf("%ld", ptr2 - ptr1);
        return 0;
}
2


#include <stdio.h>
struct test {
        unsigned int x;
        int y : 30 ;
         int h  :2;
        unsigned int z;
};
int main()
{
        struct test t;
        unsigned int* ptr1 = &t.x;
        unsigned int* ptr2 = &t.z;
        printf("%ld", ptr2 - ptr1);
        return 0;
}
2


#include <stdio.h>
struct test {
        unsigned int x;
        int y : 30 ;
         int h  :3;
        unsigned int z;
};
int main()
{
        struct test t;
        unsigned int* ptr1 = &t.x;
        unsigned int* ptr2 = &t.z;
        printf("%ld", ptr2 - ptr1);
        return 0;
}
3

#include<stdio.h>
union test {
        unsigned int x : 3;
        unsigned int y : 3;
        int z;
};

int main()
{
        union test t;
        t.x = 5;
        t.y = 4;
        t.z = 1;
        printf("t.x = %d, t.y = %d, t.z = %d",
                t.x, t.y, t.z);
        return 0;
}
t.x = 1, t.y = 1, t.z = 1

--------------------------------------------------------------------------
#include<stdio.h>
union test {
        unsigned int x : 1;
        unsigned int y : 1;
        int z;
};

int main()
{
        union test t;
        t.z = 3;
        printf("t.x = %d, t.y = %d, t.z = %d",
                t.x, t.y, t.z);
        return 0;
}
t.x = 1, t.y = 1, t.z = 3

--------------------------------------------------------------------------
#include<stdio.h>
union test {
        unsigned int x : 1;
        unsigned int y : 1;
        int z;
};

int main()
{
        union test t;
        t.z = 4;
        printf("t.x = %d, t.y = %d, t.z = %d",
                t.x, t.y, t.z);
        return 0;
}
t.x = 0, t.y = 0, t.z = 4

--------------------------------------------------------------------------


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

How to initialize structure members?
Structure members cannot be initialized with declaration. For example the following C program fails in compilation.

struct Point
{
   int x = 0;  // COMPILER ERROR:  cannot initialize members here
   int y = 0;  // COMPILER ERROR:  cannot initialize members here
};

The reason for above error is simple, when a datatype is declared, no memory is allocated for it. Memory is allocated only when variables are created.

Structure members can be initialized using curly braces ‘{}’. For example, following is a valid initialization.
struct Point
{
   int x, y;
};
int main()
{
   struct Point p1 = {0, 1};
}


What is designated Initialization?
Designated Initialization allows structure members to be initialized in any order. This feature has been added in C99 standard.
struct Point
{
   int x, y, z;
};
int main()
{
   // Examples of initialization using designated initialization
   struct Point p1 = {.y = 0, .z = 1, .x = 2};
   struct Point p2 = {.x = 20};
   printf ("x = %d, y = %d, z = %d\n", p1.x, p1.y, p1.z);
   printf ("x = %d", p2.x);
   return 0;
}
Output:
x = 2, y = 0, z = 1
x = 20



   // Create an array of structures
   struct Point arr[10];
   // Access array members
   arr[0].x = 10;
   arr[0].y = 20;


What is a structure pointer?
Like primitive types, we can have pointer to a structure. If we have a pointer to structure, members are accessed using arrow ( -> ) operator.


struct employee
{
    int     emp_id;
    int     name_len;
    char    name[0];
};
4 + 4 + 0 = 8 bytes.

And what about size of “name[0]”. In gcc, when we create an array of zero length, it is considered as array of incomplete type that’s why gcc reports its size as “0” bytes. This technique is known as “Stuct Hack”. When we create array of zero length inside structure, it must be (and only) last member of structure. Shortly we will see how to use it.
“Struct Hack” technique is used to create variable length member in a structure. In the above structure, string length of “name” is not fixed, so we can use “name” as variable length array.


Let us see below memory allocation.

struct employee *e = malloc(sizeof(*e) + sizeof(char) * 128);
is equivalent to
struct employee
{
    int     emp_id;
    int     name_len;
    char    name[128]; /* character array of size 128 */
};
And below memory allocation

struct employee *e = malloc(sizeof(*e) + sizeof(char) * 1024);
is equivalent to

struct employee
{
    int     emp_id;
    int     name_len;
    char    name[1024]; /* character array of size 1024 */
};
Note: since name is character array, in malloc instead of “sizeof(char) * 128”, we can use “128” directly. sizeof is used to avoid confusion.

Now we can use “name” same as pointer. e.g.

e->emp_id       = 100;
e->name_len     = strlen("Geeks For Geeks");
strncpy(e->name, "Geeks For Geeks", e->name_len);

When we allocate memory as given above, compiler will allocate memory to store “emp_id” and “name_len” plus contiguous memory to store “name”. When we use this technique, gcc guaranties that, “name” will get contiguous memory.


Obviously there are other ways to solve problem, one is we can use character pointer. But there is no guarantee that character pointer will get contiguous memory, and we can take advantage of this contiguous memory. For example, by using this technique, we can allocate and deallocate memory by using single malloc and free call (because memory is contagious). Other advantage of this is, suppose if we want to write data, we can write whole data by using single “write()” call. e.g.

write(fd, e, sizeof(*e) + name_len); /* write emp_id + name_len + name */
If we use character pointer, then we need 2 write calls to write data. e.g.

write(fd, e, sizeof(*e));               /* write emp_id + name_len */
write(fd, e->name, e->name_len);        /* write name */
Note: In C99, there is feature called “flexible array members”, which works same as “Struct Hack”


Flexible Array Members in a structure in C
Flexible Array Member(FAM) is a feature introduced in the C99 standard of the C programming language.

For the structures in C programming language from C99 standard onwards, we can declare an array without a dimension and whose size is flexible in nature.
Such an array inside the structure should preferably be declared as the last member of structure and its size is variable(can be changed be at runtime).
The structure must contain at least one more named member in addition to the flexible array member.
What must be the size of the structure below?

struct student
{
   int stud_id;
   int name_len;
   int struct_size;
   char stud_name[];
};
The size of structure is = 4 + 4 + 4 + 0 = 12
In the above code snippet, the size i.e length of array “stud_name” isn’t fixed and is an FAM.

The memory allocation using flexible array members(as per C99 standards) for the above example can be done as:

 struct student *s = malloc( sizeof(*s) + sizeof(char [strlen(stud_name)])  );
Note: While using flexible array members in structures some convention regarding actual size of the member is defined.
In the above example the convention is that the member “stud_name” has character size.

For Example, Consider the following structure:

Input : id = 15, name = "Kartik"
Output : Student_id : 15
         Stud_Name  : Kartik
         Name_Length: 6
         Allocated_Struct_size: 18
Memory allocation of above structure:

struct student *s =
        malloc( sizeof(*s) + sizeof(char [strlen("Kartik")]));
Its structure representation is equal to:

struct student
{
   int stud_id;
   int name_len;
   int struct_size;
   char stud_name[6]; //character array of length 6
};



Operations on struct variables in C
In C, the only operation that can be applied to struct variables is assignment. Any other operation (e.g. equality check) is not allowed on struct variables.


struct Point p2 = p1; // works: contents of p1 are copied to p2
if (p1 == p2) // compiler error: cannot do equality check for
                                // whole structures

Limitations of C Structures

In C language, Structures provide a method for packing together data of different types. A Structure is a helpful tool to handle a group of logically related data items. However, C structures have some limitations.

The C structure does not allow the struct data type to be treated like built-in data types:
We cannot use operators like +,- etc. on Structure variables. For example, consider the following code:

    struct number n1,n2,n3;
    n1.x=4;
    n2.x=3;
    n3=n1+n2;
    return 0;
invalid operands to binary + (have 'struct number' and 'struct number')
  n3=n1+n2;

No Data Hiding: C Structures do not permit data hiding. Structure members can be accessed by any function, anywhere in the scope of the Structure.
Functions inside Structure: C structures do not permit functions inside Structure
Static Members: C Structures cannot have static members inside their body
Access Modifiers: C Programming language do not support access modifiers. So they cannot be used in C Structures.
Construction creation in Structure: Structures in C cannot have constructor inside Structures.
sizeof operator: This operator will generate 0 for an empty structure in C whereas 1 for an empty structure in C++.


Compound Literals in C
#include <stdio.h> 
int main()
{
        // Compound literal (an array is created without
        // any name and address of first element is assigned
        // to p.  This is equivalent to:

        // int arr[] = {2, 4, 6};
        // int *p = arr;
        int *p = (int []){2, 4, 6};

        printf("%d %d %d", p[0], p[1], p[2]);

        return 0;
}

Output:
2 4 6

Compound literals feature allows us to create unnamed objects with given list of initialized values. In the above example, an array is created without any name. Address of first element of array is assigned to pointer p.

What is the use of it?
Compound literals are mainly used with structures and are particularly useful when passing structures variables to functions. We can pass a structure object without defining it

For example, consider the below code.


#include <stdio.h> 
struct Point
{
        int x, y;
};
void printPoint(struct Point p)
{
        printf("%d, %d", p.x, p.y);
}
int main()
{
        // Calling printPoint() without creating any temporary
        // Point variable in main()
        printPoint((struct Point){2, 3});

        /*  Without compound literal, above statement would have
            been written as
            struct Point temp = {2, 3};
            printPoint(temp);  */

        return 0;
}
Output:
2, 3



Because of the alignment requirements of various data types, every member of structure should be naturally aligned. 

When memory reading is efficient in reading 4 bytes at a time on 32 bit machine.
it means when you can read a address of 32 bit(4byte) so make the alignment of 4byte.

What is structure packing?
Some times it is mandatory to avoid padded bytes among the members of structure.

Most of the compilers provide non standard extensions to switch off the default padding like pragmas or command line switches. Consult the documentation of respective compiler for more details.

Every data type in C/C++ will have alignment requirement (infact it is mandated by processor architecture, not by language). A processor will have processing word length as that of data bus size. On a 32 bit machine, the processing word size will be 4 bytesi.

Historically memory is byte addressable and arranged sequentially. If the memory is arranged as single bank of one byte width, the processor needs to issue 4 memory read cycles to fetch an integer.

It is more economical to read all 4 bytes of integer in one memory cycle. To take such advantage, the memory will be arranged as group of 4 banks as shown in the above figure

The memory addressing still be sequential. If bank 0 occupies an address X, bank 1, bank 2 and bank 3 will be at (X + 1), (X + 2) and (X + 3) addresses. If an integer of 4 bytes is allocated on X address (X is multiple of 4), the processor needs only one memory cycle to read entire integer.

Where as, if the integer is allocated at an address other than multiple of 4, it spans across two rows of the banks as shown in the below figure. Such an integer requires two memory read cycle to fetch the data.

Similarly, the natural alignment of short int is 2 bytes. It means, a short int can be stored in bank 0 – bank 1 pair or bank 2 – bank 3 pair. A double requires 8 bytes, and occupies two rows in the memory banks. Any misalignment of double will force more than two read cycles to fetch double data.

Note that a double variable will be allocated on 8 byte boundary on 32 bit machine and requires two memory read cycles. On a 64 bit machine, based on number of banks, double variable will be allocated on 8 byte boundary and requires only one memory read cycle.

So, to avoid structure padding we can use pragma pack as well as an attribute.
Below are the solutions to avoid structure padding:

Program-1: Using pragma pack
#include <stdio.h>
// To force compiler to use 1 byte packaging
#pragma pack(1)
struct s {
    int i;
    char ch;
    double d;
};
int main()
{
    struct s A;
    printf("Size of A is: %ld", sizeof(A));
}
Output:
Size of A is: 13



Program-2: Using attribute
// C program to avoid structure
// padding using attribute
#include <stdio.h>
struct s {
    int i;
    char ch;
    double d;
} __attribute__((packed));
// Attribute informing compiler to pack all members
int main()
{
    struct s A;
    printf("Size of A is: %ld", sizeof(A));
}
Output:
Size of A is: 13




++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Note that, initialized  data segment is not read-only, since the values of the variables can be altered at run time.
This segment can be further classified into initialized read-only area and initialized read-write area.
For instance the global string defined by char s[] = “hello world” in C and a C statement like int debug=1 outside the main (i.e. global) would be stored in initialized read-write area. And a global C statement like const char* string = “hello world” makes the string literal “hello world” to be stored in initialized read-only area and the character pointer variable string in initialized read-write area.

Uninitialized Data Segment:
Uninitialized data segment, often called the “bss” segment, named after an ancient assembler operator that stood for “block started by symbol.” Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing

uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code.

when the stack pointer met the heap pointer, free memory was exhausted. (With modern large address spaces and virtual memory techniques they may be placed almost anywhere, but they still typically grow opposite directions.)

The heap area begins at the end of the BSS segment and grows to larger addresses from there.The Heap area is managed by malloc, realloc, and free, which may use the brk and sbrk system calls to adjust its size (note that the use of brk/sbrk and a single “heap area” is not required to fulfill the contract of malloc/realloc/free; they may also be implemented using mmap to reserve potentially non-contiguous regions of virtual memory into the process’ virtual address space). The Heap area is shared by all shared libraries and dynamically loaded modules in a process.

u can try all and check sizes of segments by using 'size' command on an executable file




Initialization: malloc() allocates memory block of given size (in bytes) and returns a pointer to the beginning of the block. malloc() doesn’t initialize the allocated memory. If we try to access the content of memory block(before initializing) then we’ll get segmentation fault error(or maybe garbage values).
void* malloc(size_t size);

calloc() allocates the memory and also initializes the allocated memory block to zero. If we try to access the content of these blocks then we’ll get 0.
void* calloc(size_t num, size_t size);

We can achieve same functionality as calloc() by using malloc() followed by memset(),
ptr = malloc(size);
memset(ptr, 0, size);


Note: It would be better to use malloc over calloc, unless we want the zero-initialization because malloc is faster than calloc. So if we just want to copy some stuff or do something that doesn’t require filling of the blocks with zeros, then malloc would be a better choice.


How to deallocate memory without using free() in C?
Question: How to deallocate dynamically allocate memory without using “free()” function.
Solution: Standard library function realloc() can be used to deallocate previously allocated memory.
If “size” is zero, then call to realloc is equivalent to “free(ptr)”. And if “ptr” is NULL and size is non-zero then call to realloc is equivalent to “malloc(size)”.


ptr = (cast-type*) malloc(byte-size)
If space is insufficient, allocation fails and returns a NULL pointer.


When memory allocation is done, the actual heap space allocated is one word larger than the requested memory. The extra word is used to store the size of the allocation and is later used by free( ) . this extra memory is before the address pointed by pointer.


memcpy() is used to copy a block of memory from a location to another. It is declared in string.h
// Copies "numBytes" bytes from address "from" to address "to"
void * memcpy(void *to, const void *from, size_t numBytes);
Notes:
1) memcpy() doesn’t check for overflow or \0
2) memcpy() leads to problems when source and destination addresses overlap.

memmove() in C/C++
memmove() is used to copy a block of memory from a location to another. It is declared in string.h
// Copies "numBytes" bytes from address "from" to address "to"
void * memmove(void *to, const void *from, size_t numBytes);
Below is a sample C program to show working of memmove().

How is it different from memcpy()?
memcpy() simply copies data one by one from one location to another. On the other hand memmove() copies the data first to an intermediate buffer, then from buffer to destination.
memcpy() leads to problems when strings overlap.


The point to note is that realloc() should only be used for dynamically allocated memory. If the memory is not dynamically allocated, then behavior is undefined.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Creation of a new file (fopen with attributes as “a” or “a+” or “w” or “w++”)
Opening an existing file (fopen)
Reading from file (fscanf or fgetc)
Writing to a file (fprintf or fputs)
Moving to a specific location in a file (fseek, rewind)
Closing a file (fclose)

“r” – Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the first character in it. If the file cannot be opened fopen( ) returns NULL.
“w” – Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open file.
“a” – Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open file.
“r+” – Searches file. If is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the first character in it. Returns NULL, if unable to open the file.
“w+” – Searches file. If the file exists, its contents are overwritten. If the file doesn’t exist a new file is created. Returns NULL, if unable to open file.
“a+” – Searches file. If the file is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the last character in it. If the file doesn’t exist, a new file is created. Returns NULL, if unable to open file.
As given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”. For performing the operations on the file, a special pointer called File pointer is used which is declared as

As given above, if you want to perform operations on a binary file, then you have to append ‘b’ at the last. For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”. For performing the operations on the file, a special pointer called File pointer is used which is declared as

FILE *filePointer;
So, the file can be opened as
filePointer = fopen(“fileName.txt”, “w”)
The second parameter can be changed to contain all the attributes listed in the above table.

Reading from a file –
The file read operations can be performed using functions fscanf or fgets. Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. So, it depends on you if you want to read the file line by line or character by character.
And the code snippet for reading a file is as:

FILE * filePointer;
filePointer = fopen(“fileName.txt”, “r”);
fscanf(filePointer, "%s %s %s %d", str1, str2, str3, &year);

Writing a file –:
The file write operations can be perfomed by the functions fprintf and fputs with similarities to read operations. The snippet for writing to a file is as :

FILE *filePointer ;
filePointer = fopen(“fileName.txt”, “w”);
fprintf(filePointer, "%s %s %s %d", "We", "are", "in", 2012);
Closing a file –:
After every successful fie operations, you must always close a file. For closing a file, you have to use fclose function. The snippet for closing a file is given as :
FILE *filePointer ;
filePointer= fopen(“fileName.txt”, “w”);


EOF, getc() and feof() in C
In C/C++, getc() returns EOF when end of file is reached. getc() also returns EOF when it fails. So, only comparing the value returned by getc() with EOF is not sufficient to check for actual end of file. To solve this problem, C provides feof() which returns non-zero value only if end of file has reached, otherwise it returns 0.


#include <stdio.h>
int main()
{
FILE *fp = fopen("test.txt", "r");
int ch = getc(fp);
while (ch != EOF)
{
        /* display contents of file on screen */
        putchar(ch);
        ch = getc(fp);
}
if (feof(fp))
        printf("\n End of file reached.");
else
        printf("\n Something went wrong.");
fclose(fp);
getchar();
return 0;
}


The latest C standard C11 provides a new mode “x” which is exclusive create-and-open mode. Mode “x” can be used with any “w” specifier, like “wx”, “wbx”. When x is used with w, fopen() returns NULL if file already exists or could not open.


fseek() is used to move file pointer associated with a given file to a specific position.
Syntax:
int fseek(FILE *pointer, long int offset, int position)
pointer: pointer to a FILE object that identifies the stream.
offset: number of bytes to offset from position
position: position from where offset is added.

returns:
zero if successful, or else it returns a non-zero value
position defines the point with respect to which the file pointer needs to be moved. It has three values:
SEEK_END : It denotes end of the file.
SEEK_SET : It denotes starting of the file.
SEEK_CUR : It denotes file pointer’s current position.

The rewind function sets the file position indicator for the stream pointed to by stream to the beginning of the file. It is equivalent to
(void)fseek(stream, 0L, SEEK_SET)
except that the error indicator for the stream is also cleared.

But there is no way to check whether the rewind() was successful.
  rewind(fp);  /* no way to check if rewind is successful */
In the above code, fseek() can be used instead of rewind() to see if the operation succeeded. Following lines of code can be used in place of rewind(fp);
if ( fseek(fp, 0L, SEEK_SET) != 0 ) {
  /* Handle repositioning error */
}



fsetpos() (Set File Position) in C
The fsetpos() function moves the file position indicator to the location specified by the object pointed to by position. When fsetpos() is executed ,the end-of-file indecator is reset.
Declaration
int fsetpos(FILE *stream, const fpos_t *position)
Parameters –
stream – This is the pointer to a FILE object that identifies the stream.
position – This is the pointer to a fpos_t object containing a position previously obtained with fgetpos.
Return – If it successful, it return zero otherwise returns nonzero value.

ftell() in C is used to find out the position of file pointer in the file with respect to starting of the file. Syntax of ftell() is:
long ftell(FILE *pointer)


fwrite and fread make task easier when you want to write and read blocks of data.

fwrite : Following is the declaration of fwrite function
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
ptr - This is pointer to array of elements to be written
size -  This is the size in bytes of each element to be written
nmemb - This is the number of elements, each one with a size of size bytes
stream - This is the pointer to a FILE object that specifies an output stream

fread : Following is the declaration of fread function
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
ptr - This is the pointer to a block of memory with a minimum size of size*nmemb bytes.
size - This is the size in bytes of each element to be read.
nmemb - This is the number of elements, each one with a size of size bytes.
stream - This is the pointer to a FILE object that specifies an input stream.


The remove function in C/C++ can be used to delete a file. The function returns 0 if files is deleted successfully, other returns a non-zero value.

Using remove() function in C, we can write a program which can destroy itself after it is compiled and executed.

Explanation: This can be done using the remove function in C. Note that, this is done in Linux environment. So, the remove function is fed the first parameter in command line argument i.e. a.out file (executable file) created after compiling . Hence the program will be destroyed.
#include<stdio.h> 
#include<stdlib.h> 
int main(int c, char *argv[])
{
    printf("By the time you will compile me I will be destroyed \n");
   // array of pointers to command line arguments
    remove(argv[0]);
  // Note: argv[0] will contain the executable file i.e. 'a.out'

return 0;
}
Output:
By the time you will compile me I will be destroyed
After the output shown above, the a.out file will be removed.



rename function in C/C++
rename() function is used to change the name of the file or directory i.e. from old_name to new_name without changing the content present in the file. This function takes name of the file as its argument.
If new_name is the name of an existing file in the same folder then the function may either fail or override the existing file, depending on the specific system and library implementation.
Syntax:

int rename (const char *old_name, const char *new_name);
Parameters:
old_name : Name of an existing file to be renamed.
new_name : String containing new name of the file.
Return:
Return type of function is an integer. If the file is renamed successfully, zero is returned. On failure, a nonzero value is returned.

tmpfile() function in C
In C Programming Language, the tmpfile() function is used to produce/create a temporary file.
tmpfile() function is defined in the “stdio.h” header file.
The created temporary file will automatically be deleted after the termination of program.
It opens file in binary update mode i.e., wb+ mode.
The syntax of tmpfile() function is:
FILE *tmpfile(void)
The tmpfile() function always returns a pointer after the creation of file to the temporary file. If by chance temporary file can not be created, then the tmpfile() function returns NULL pointer.











=================================================================

External Names:

"External" names are ones that are visible to other compilation units, like non-static functions and variables declared with the "extern" keyword. These names have to be exposed to linkers and loaders. In Ye Olden Days, some linkers and loaders could only handle very short names.

Internal Names:

"Internal" names are ones that are not made visible outside of the module being compiled -- basically anything with "static" scope, or anything local to a function. C compilers have to handle these names, but not anything else.

"Internal names" are names of identifiers within a function (effectively local variable names).

"External names" would be the names of the other identifiers, including the names of functions and any identifiers declared at global scope or declared with storage class extern.

Basically, anything that needs to be "externally visible" is only guaranteed to have 6 (non case sensitive) unique characters, which is extremely limiting.

In practice, this is no longer an issue. C99 increased these limits, and most modern compilers do away or significantly increase these limits.


An external name is an identifier with external linkage. For an identifier to have external linkage it must either be a non-static of file scope or specifically declared "extern".




=================================================================

5. Why do variable names beginning with the underscore is not encouraged?
a) It is not standardized
b) To avoid conflicts since assemblers and loaders use such names
c) To avoid conflicts since library routines use such names
d) To avoid conflicts with environment variables of an operating system

Answer: c

=================================================================
the keywords are all lowercase. Since uppercase and lowercase characters are not equivalent, 

neither upper case nor camel case....only lower case

=================================================================

compiler and linker resolve the characters uniqueness 


================================================================

varible name starting with '$' are not allowed
or they cant have special variable hypen -, question mark ?
only with underscore_.

=================================================================

macro preprocessor is a textual substitution
not a variable.


=================================================================

int main;

u can have a variable name and function same.

=================================================================

int i=5;

if((char)i=='5')
	it will run

=================================================================


short int i;

short is the qualifier and int is the basic data type

=================================================================
int f=0.1;

if(f==0.1)

//it will be unequal
//because 0.1 is double by default

int f=0.1f;
if(f==0.1);
//yes its equal
//because u told it to make float

Binary floating point math is like this. In most programming languages, it is based on the IEEE 754 standard. The crux of the problem is that numbers are represented in this format as a whole number times a power of two; rational numbers (such as 0.1, which is 1/10) whose denominator is not a power of two cannot be exactly represented.

For 0.1 in the standard binary64 format, the representation can be written exactly as

0.1000000000000000055511151231257827021181583404541015625 in decimal, or
0x1.999999999999ap-4 in C99 hexfloat notation.
In contrast, the rational number 0.1, which is 1/10, can be written exactly as

0.1 in decimal, or
0x1.99999999999999...p-4 in an analogue of C99 hexfloat notation, where the ... represents an unending sequence of 9's.
The constants 0.2 and 0.3 in your program will also be approximations to their true values. It happens that the closest double to 0.2 is larger than the rational number 0.2 but that the closest double to 0.3 is smaller than the rational number 0.3. The sum of 0.1 and 0.2 winds up being larger than the rational number 0.3 and hence disagreeing with the constant in your code


#include<stdio.h> 
int main() 
{ 
   float x = 0.1; 
   printf("%d %d %d", sizeof(x), sizeof(0.1), sizeof(0.1f)); 
   return 0; 
} 
The output of above program is "4 8 4" on a typical C compiler.
It actually prints size of float, size of double and size of float


=================================================================

char<int<double, size of variable in any system

=================================================================
int main()
{
printf("hi its me %s","shivam rawat \n%san Engineer","i love my work");
}

//it works but gives warning : too many arguments
here the second argument will go into first %s, but the thrd argument will be ignored ; output:


hi its me shivam rawat                                                
%san Engineer


=================================================================

char *s="hellobye";
 printf("%s\n",s);
 printf("%d\n",strlen(s));
 printf("%d\n",sizeof(s));

//output:


hellobye                                                                        
8                                                                               
8 


=================================================================


char *s="hello\n\n\0bye";
 printf("%s\n",s);
 printf("%d\n",strlen(s));
 printf("%d\n",sizeof(s));

//output:

hello                                                                           
                                                                                
                                                                                
7                                                                               
8 

//remember strlen returns ' size_t ' ( long unsigned int)
// sizeof returns ' long unsigned  int'



//the \0 is accepted as a char in the string,
=================================================================


#define a 10

int main(){
const int a = 5;
printf("a=%d",a);


main.c: In function ‘main’:
main.c:10:11: error: expected identifier or ‘(’ before numeric constant
 #define a 10
           ^
main.c:14:12: note: in expansion of macro ‘a’
  const int a = 5;
            ^


=================================================================

int v=010;
printf("%d",v);

output: 8

it is the octal(0-7) representation for 8


=================================================================

#include<stdio.h> 
enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun}; 
int main() 
{ 
    enum week day; 
    day = Wed; 
    printf("%d",day); 
    return 0; 
}  
Output: 2


#include<stdio.h> 
enum year{Jan, Feb, Mar, Apr, May, Jun, Jul,  
          Aug, Sep, Oct, Nov, Dec}; 
int main() 
{ 
   int i; 
   for (i=Jan; i<=Dec; i++)       
      printf("%d ", i); 
        
   return 0; 
} 
Output:
0 1 2 3 4 5 6 7 8 9 10 11





=================================================================

#include <stdio.h> 
#include<string.h>

int main()
{
  char *str="x";
  char c='x';
  char ary[1];
  ary[0]=c;
  
  printf("%d %d -- %d",strlen(str),strlen(ary), ary[0]);
  
    return 0;
}
//output : 1 5 -- 120



here  5 is undefined behaviour 





=================================================================

#include <stdio.h> 
#include<string.h>

int main()
{
    
  char str[]="x";
  char c='x';
  char ary[1];
  ary[0]=c;
  
  printf("%d %d -- %d",sizeof(str),sizeof(ary), ary[0]);
  
    return 0;
}

//output: 2 1 -- 120  


=================================================================


[3:18 pm, 27/08/2020] ShivamRawat🙂 😊 😇: When are enum values resolved? In other words, is the following code snippet standard-compliant?

enum{
    A,
    B,
    MAX
}

#if MAX > 42
#    error "Woah! MAX is a lot!"
#endif
[3:19 pm, 27/08/2020] ShivamRawat 🙂 😊 😇: .

solution
Whenever the preprocessor is handling a conditional directive, any identifiers that are not defined as macros are treated as 0. So assuming that MAX isn't defined elsewhere as a macro, your snippet of code is equivalent to:

enum{
    A,
    B,
    MAX
}

#if 0 > 42
#    error "Woah! MAX is a lot!"
#endif


. 



=================================================================

    printf("hello\rbye");
//output: byelo                                                                          
carriage return moves the cursor back to start
=================================================================

printf("hell\noooo\rbye");
hell                                                              byeo 



=================================================================


printf("hell\r\noooobye");

hell                                     
oooobye


=================================================================

constant variable has to be declared and defined at the same time 

//it is wrong
const int i;
i=4;


main.c: In function ‘main’:
main.c:9:6: error: assignment of read-only variable ‘p’
     p=4;

=================================================================

int k=3;
int *const p=&k;
int i=9;
p=&i; //error

is a constant pointer u cant assign it new address.

=================================================================

void func( const int *i)
{
*i=90;
}

int main()
{
    const  int  i=10;;
    func(&i);
    printf("%d",i);
    return 0;
}
main.c: In function ‘func’:
main.c:7:3: error: assignment of read-only location ‘*i’
 *i=90;
   ^

=================================================================



void func( int *i)
{
*i=90;
}

int main()
{
    const  int  i=10;;
    func(&i);
    printf("%d",i);
    return 0;
}


main.c:13:10: warning: passing argument 1 of ‘func’ discards ‘const’ qualifier f
rom pointer target type [-Wdiscarded-qualifiers]                                
main.c:5:6: note: expected ‘int *’ but argument is of type ‘const int *’        

//output:90 
it changed

=================================================================
int main()
{
    const  int  i=10;;
    
    int *const ptr=&i;
    *ptr=99;
    printf("%d\n",i);
    return 0;
}

main.c:10:20: warning: initialization discards ‘const’ qualifier from pointer ta
rget type [-Wdiscarded-qualifiers]                                              

output:99 

=================================================================

int main()
{
    const  int  i=10;;
    
    const int * ptr=&i;
    *ptr=99;
    printf("%d\n",i);
    return 0;
}

main.c: In function ‘main’:
main.c:11:9: error: assignment of read-only location ‘*ptr’
     *ptr=99;



=================================================================

for (int k=0; k<10; k++)
	return 0;

compiler implementing c90 does not allow this but c99 allow this.

therefore do use -std=c99 or -st=gnu99 to compile your code

=================================================================


int main()
{
     float str=3e10;
    printf("%f",str);
     return 0;
}
//output:
30000001024.000000                                                              



int main()
{
     float str=3e9;
    printf("%f",str);
     return 0;
}
3000000000.000000                                                               



int main()
{
     unsigned float str=3e9;
    printf("%f",str);
     return 0;
}
main.c: In function ‘main’:
main.c:8:15: error: both ‘unsigned’ and ‘float’ in declaration specifiers
      unsigned float str=3e9;
               ^~~~~
main.c:9:14: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘unsigned int’ [-Wformat=]
     printf("%f",str);
              ^





int main()
{
     unsigned double str=3e9;
    printf("%f",str);
     return 0;
}
main.c: In function ‘main’:
main.c:8:15: error: both ‘unsigned’ and ‘double’ in declaration specifiers
      unsigned double str=3e9;
               ^~~~~~
main.c:9:14: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘unsigned int’ [-Wformat=]
     printf("%f",str);



=================================================================

char *v="fsfdfffafafafqkf	njfbhbhbfhfhvqdqc";

to print it we can use %s,%d,%c but not the %f

=================================================================

    char[] str="jbdh";


main.c: In function ‘main’:
main.c:8:9: error: expected identifier or ‘(’ before ‘[’ token
     char[] str="jbdh";
         ^

=================================================================
float int i=9; 

main.c: In function ‘main’:
main.c:8:7: error: two or more data types in declaration specifiers
 float int i=9;
       ^~~



=================================================================

int k=5;
float k=9;

error of conflicting types


=================================================================

int i=-3;
 int k=i%2;
 printf("%d",k);

//output:
-1                                                                              


=================================================================

int main()
{
 int i=3;
 int k=i%-2;
 
 int l=i/-2;
 printf("%d %d",k,l);
 
 return 0;
}

//output:
1 -1                                                                            


=================================================================
int main()
{
 int i=-3;
 int k=i%-2;
 
 int l=i/-2;
 printf("%d %d",k,l);
 
 return 0;
}

//output:
-1 1                                                                            



=================================================================

 int i=7.8%2.8;
 int i=7%2.8;
 int i=7.5%7;
 int i=7.0%7;


//all show same error
main.c: In function ‘main’:
main.c:8:11: error: invalid operands to binary % (have ‘double’ and ‘double’)
  int i=7.8%2.8


=================================================================

int i=97%'a';
   printf(" %d",i);

//output:
0 


int i=90%'a';
   printf(" %d",i);

//output:
 90                                                                             


int i=100%'a';
   printf(" %d",i);

//output:
3


int i=200%('a'+'b');
   printf(" %d",i);

//output:
5 

=================================================================

int a=3;
 int b= ++a + a++ + --a;
printf("b=%d",b);

// un defined behaviour



=================================================================
int a=10,b=5,c=5;
int d;
d= a==(b+c);

//it ok , d will get initalized with 1

=================================================================
int x=1,y=0,z=5;
 int a=x && y|| z++;
 printf("%d %d %d",x,y,z);

1 0 6                                                                           
=================================================================

int x=1,y=0,z=5;
 int a=--x && ++y || z--;
 printf("%d %d %d",x,y,z);

0 0 4

=================================================================
  int x=1,y=0,z=5;
 int a= ++x && y && --z;
 printf("%d %d %d",x,y,z);


2 0 5                                                                           
=================================================================

 int x=1,y=0,z=3;
   x>y?printf("%d",z): return z;


main.c: In function ‘main’:
main.c:10:24: error: expected expression before ‘return’
    x>y?printf("%d",z): return z;
                        ^~~~~~



=================================================================

int x=0,y=2,z=3;
 int a= x&y|z;
 printf("%d",a);

3 


=================================================================

logical operators are sequence points

When a sequence point occurs, it basically means that you are guaranteed that all previous operations are complete.

Changing a variable twice without an intervening sequence point is one example of undefined behaviour.

For example, i = i++; is undefined because there's no sequence point between the two changes to i.

The following are the sequence points described in the standard:

Between the evaluations of the function designator and actual arguments in a function call and the actual call;
Between the evaluations of the first and second operands of the operators &&, ||, and ,;
Between the evaluations of the first operand of the conditional ?: operator and whichever of the second and third operands is evaluated;
The end of a full declarator;
Between the evaluation of a full expression and the next full expression to be evaluated. The following are full expressions:
an initializer;
the expression in an expression statement;
the controlling expression of a selection statement (if or switch);
the controlling expression of a while or do statement;
each of the expressions of a for statement;
the expression in a return statement.
Immediately before a library function returns;
After the actions associated with each formatted input/output function conversion specifier;
Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call.


=================================================================

int i=0;
 i=i++;
 printf("%d ",i);
 i=++i;
 printf("%d ",i);

0 1

=================================================================

int i=0;
 i+=i++;
 printf("%d ",i);
 i=++i;
 printf("%d ",i);

1 2
 
=================================================================




int i=0;
 i+=i++;
 printf("%d ",i);
 i+=++i;
 printf("%d ",i);

1 4

//undefinedd behaviour.

=================================================================

int a=10,b=5,c=5;
 int d;
 d=b+c == a;
 printf("%d",d);


1

=================================================================

int a=10,b=5,c=3;
  b != !a;
  c = !!a;
printf("%d\t%d",b,c);


5	1



!= is a relational operator. It is just used to check the values of both the operands,there it just checks with b and !a that means it does not change the value of b

And in next ! Is logical operator and it reverse the value of operand i.e if it is true it become false and vice versa here 1st !a makes a false I.e 0 next !a makes it 1 that is c=1


=================================================================
relation operators cant be used in structures


=================================================================

#include <stdio.h>

int main()
{
        int i=10;
        int *j=&i;

        printf("%d\n",*j++);
        //printf("%d\n",*(j++));
    //both are same first fetch value and then increment the position
 return 0;
}
//output: 10



ok..   ++post has high precedence  then *  
but, it is post ...first value will be fectched ...... because of *
then display 
then increment

=================================================================
        int i=10;
        int *j=&i;
        int *k=j++;

        int r=j-k;
        printf("%d",r);

//output: 1

=================================================================
int a=5,b=-7,c=0,d;
        d= ++a && ++b || ++c;
        printf("\n%d %d %d %d",a,b,c,d);

//output: 6 -6 0 1

=================================================================

int a=-5;
        int k=(a++ ,++a);
        printf("%d %d",k,a);
//output: -3 -3

=================================================================

f = 1 1 1 1

since f is the 15 in hex

=================================================================

Decimal Number	4-bit Binary Number	Hexadecimal Number
0		0000				0
1		0001				1
2		0010				2
3		0011				3
4		0100				4
5		0101				5
6		0110				6
7		0111				7
8		1000				8
9		1001				9
10		1010				A
11		1011				B
12		1100				C
13		1101				D
14		1110				E
15		1111				F
16		0001 0000			10 (1+0)
17		0001 0001			11 (1+1)


=================================================================
int k=7;
        int x = 0 == 1 && k++;
        printf("%d %d\n",x,k);
//output:
0 7



int k=7;
        int x = 1 == 1 && k++;
        printf("%d%d\n",x,k);
//output: 1 8



int k=0;
        int x = 1 == 1 && k || k++;
        printf("%d%d\n",x,k);
//output: 0 1


=================================================================

char a='a';
        int x = (a%10)++;
        printf(" %d\n",x);


xyz.c: In function ‘main’:
xyz.c:6:16: error: lvalue required as increment operand
  int x = (a%10)++;
                ^~



=================================================================

        1<2? return 1: return 2;

xyz.c:5:7: error: expected expression before ‘return’
  1<2? return 1: return 2;
       ^~~~~~

=================================================================

unsigned int x= -5;
        printf("%d",x);

//output: -5


unsigned int x= -77;
        printf("%d",x);

//output: -77

=================================================================


int x=2,y=1;
        x*=x+y;
        printf("%d",x);

//output: 6



int x=2,y=1;
        x=x*x+y;
        printf("%d",x);
//output: 5


=================================================================


int x=2, y=2;
        x/=x/y;
        printf("%d\n",x);

//output: 2

=================================================================


 int x=1, y=0;
        x && =y;
        x ||=y;


xyz.c:6:7: error: expected expression before ‘=’ token
  x && =y;
       ^
xyz.c:7:6: error: expected expression before ‘=’ token
  x ||=y;
      ^



=================================================================

int x=10;
        x %= 23;
        printf("%d",x);

//output:10



=================================================================

 #include <stdio.h>

int main()
{
        m();
        printf("%d",x);

}

int x;

void m()
{
        x=4;
}




xyz.c: In function ‘main’:
xyz.c:5:2: warning: implicit declaration of function ‘m’ [-Wimplicit-function-declaration]
  m();
  ^
xyz.c:6:14: error: ‘x’ undeclared (first use in this function)
  printf("%d",x);
              ^
xyz.c:6:14: note: each undeclared identifier is reported only once for each function it appears in
xyz.c: At top level:
xyz.c:12:6: warning: conflicting types for ‘m’
 void m()
      ^
xyz.c:5:2: note: previous implicit declaration of ‘m’ was here
  m();
  ^



=================================================================


 #include <stdio.h>
int x=5;
void main()
{
        int x=3;
        printf("%d",x);
        {
                x=4;
        }
        printf("%d",x);
}

//output: 3 4


=================================================================


 #include <stdio.h>
double i;
void main()
{
        printf("%g",i);
}

//output: 0

it will give only 0 ... not 0.00000




 #include <stdio.h>
double i=8.9883;
void main()
{
        printf("%g",i);
}
//output: 8.9883


 #include <stdio.h>
double i=8.0000;
void main()
{
        printf("%g",i);
}

//output: 8

only 8...not 8.0000
=================================================================

#include<stdio.h>
int i;
void main()
{
        extern int i;

        if(i==0)
                printf("scoperules\n");

}

//output: scoperules


=================================================================
#include<stdio.h>
void main()
{
        extern int i;

                printf("scoperules\n");

}

//output: scoperules



=================================================================
#include<stdio.h>
void main()
{
        extern arr[];

                printf("scoperules\n");

}

//output: scoperules

xyz.c: In function ‘main’:
xyz.c:6:9: warning: type defaults to ‘int’ in declaration of ‘arr’ [-Wimplicit-int]
  extern arr[];
         ^~~



=================================================================
#include<stdio.h>
void main()
{
        int i;
        for(i=0; i<5; i++)
        {
                int a=i;
        }
        printf(" %d",a);


}

xyz.c: In function ‘main’:
xyz.c:11:15: error: ‘a’ undeclared (first use in this function)
  printf(" %d",a);
               ^
xyz.c:11:15: note: each undeclared identifier is reported only once for each function it appears in



=================================================================


void main()
{
        int i;
        for(i=0; i<5; i++)
                int a=i;
        printf(" %d",a);


}


xyz.c: In function ‘main’:
xyz.c:9:17: error: expected expression before ‘int’
                 int a=i;
                 ^~~
xyz.c:10:22: error: ‘a’ undeclared (first use in this function)
         printf(" %d",a);
                      ^
xyz.c:10:22: note: each undeclared identifier is reported only once for each function it appears in



=================================================================

global variable declared before main or after main
ie...in global section ...have same scope and lifetime of scope.

=================================================================
//i dont belive it ..i cant prove it...//
// so  be carefull before u say it.


// so make programs and see every case.....
array size are optional during array declaration by using 'auto' keyword.
but not 'static', 'extern', 'register'


=================================================================
//case:1

#include<stdlib.h>

auto int arr1[];
void main()
{
        auto int arr2[];

}



xyz.c:5:10: error: file-scope declaration of ‘arr1’ specifies ‘auto’
 auto int arr1[];
          ^~~~
xyz.c: In function ‘main’:
xyz.c:8:11: error: array size missing in ‘arr2’
  auto int arr2[];
           ^~~~
xyz.c: At top level:
xyz.c:5:10: warning: array ‘arr1’ assumed to have one element
 auto int arr1[];
          ^~~~


=================================================================
//case :2


#include<stdlib.h>
static int arr2[];
void main()
{


}
//but here no error
//it compile fine.




=================================================================

//case : 3  

#include<stdlib.h>
void main()
{

static int arr2[];

}


xyz.c: In function ‘main’:
xyz.c:7:12: error: storage size of ‘arr2’ isn’t known
 static int arr2[];
            ^~~~




=================================================================
//case : 4


#include<stdlib.h>
extern int arr1[];
void main()
{
        extern int arr2[];

}
// no error..it works fine


=================================================================
//case : 5


#include<stdlib.h>
extern int arr1[];
void main()
{
        extern int arr2[];

        int arr1[];

        int arr2[];
}


xyz.c:9:6: error: array size missing in ‘arr1’
  int arr1[];
      ^~~~
xyz.c:11:6: error: declaration of ‘arr2’ with no linkage follows extern declaration
  int arr2[];
      ^~~~
xyz.c:7:13: note: previous declaration of ‘arr2’ was here
  extern int arr2[];
             ^~~~
xyz.c:11:6: error: array size missing in ‘arr2’
  int arr2[];
      ^~~
=================================================================

//case : 6 

#include<stdlib.h>
register int  arr1[];
void main()
{
        register int arr2[];
}


xyz.c: In function ‘main’:
xyz.c:7:15: error: array size missing in ‘arr2’
  register int arr2[];
               ^~~~
xyz.c: At top level:
xyz.c:4:15: warning: array ‘arr1’ assumed to have one element
 register int  arr1[];
               ^~~~
xyz.c:4:15: error: register name not specified for ‘arr1’



=================================================================
//case : 7





#include<stdlib.h>
void main()
{
register int  arr1[];
}

xyz.c: In function ‘main’:
xyz.c:6:15: error: array size missing in ‘arr1’
 register int  arr1[];
               ^~~~

--

#include<stdlib.h>
register int  arr1[];
void main()
{

}

xyz.c:4:15: warning: array ‘arr1’ assumed to have one element
 register int  arr1[];
               ^~~~
xyz.c:4:15: error: register name not specified for ‘arr1’

--

#include<stdlib.h>
register arr1[];
void main()
{
register   arr2[];
}

xyz.c:4:10: warning: type defaults to ‘int’ in declaration of ‘arr1’ [-Wimplicit-int]
 register arr1[];
          ^~~~
xyz.c: In function ‘main’:
xyz.c:7:12: warning: type defaults to ‘int’ in declaration of ‘arr2’ [-Wimplicit-int]
 register   arr2[];
            ^~~~
xyz.c:7:12: error: array size missing in ‘arr2’
xyz.c: At top level:
xyz.c:4:10: warning: array ‘arr1’ assumed to have one element
 register arr1[];
          ^~~~
xyz.c:4:10: error: register name not specified for ‘arr1’


=================================================================

#include<stdlib.h>
static int x;
void main()
{
        int x=9;
        printf("+++%d\n",x);
        {
        printf("---%d\n",x);
                x=4;
        printf("---%d\n",x);
        }
        printf("+++%d\n",x);
}

//output:
+++9
---9
---4
+++4




#include<stdlib.h>
static int x;
void main()
{

        printf("---%d: %p\n",x,&x);
        int x=9;

        printf("---%d: %p\n",x,&x);
                x=4;
        printf("---%d: %p\n",x,&x);
}
//output:
---0: 0x601028
---9: 0x7ffe910b78bc
---4: 0x7ffe910b78bc



=================================================================
void main()
{

static double x=5;
        int x;
        printf("---%d: %p\n",x,&x);
}


xyz.c: In function ‘main’:
xyz.c:8:6: error: conflicting types for ‘x’
  int x;
      ^
xyz.c:7:15: note: previous definition of ‘x’ was here
 static double x=5;
               ^


=================================================================

void main()
{
        register int i=0;
        int *p=&i;
        *p=11;
        printf("%d %d",i,*p);
}

xyz.c: In function ‘main’:
xyz.c:7:2: error: address of register variable ‘i’ requested
  int *p=&i;
  ^~~
=================================================================
void main()
{
        register int i=0;
        i=10;
        printf("%d ",i);
}
//output: 10

=================================================================

void main()
{
        const register  int i=99;
        i=10;
        printf("%d ",i);
}



xyz.c: In function ‘main’:
xyz.c:7:3: error: assignment of read-only variable ‘i’
  i=10;
   ^

=================================================================

int , long ,float can be stored in registers....

u cant declare registers variable globally
u cant read a value into a regiseter variable (ie...scanf())

=================================================================

#include<stdlib.h>

register int i;
register int k=99;

void main()
{
        i=10;
        printf("%d ",i);
}

xyz.c:5:14: error: register name not specified for ‘i’
 register int i;
              ^
xyz.c:6:14: error: register name not specified for ‘k’
 register int k=99;
              ^


#include<stdlib.h>

void main()
{
register int i;
scanf("%d",&i);

printf("%d ",i);
}

xyz.c: In function ‘main’:
xyz.c:8:1: error: address of register variable ‘i’ requested
 scanf("%d",&i);
 ^~~~~






void main()
{
        int j=89;
        register int i;
        i=j;
        printf("%d ",i);
}
//output: 89

=================================================================

#include<stdlib.h>

void main()
{
        static int z=0;
        register int x=0;
        if(x<2)
        {
                printf("%d\n",z++);
                x++;
                main();
        }
}

//segmeentation faualt

=================================================================
void main()
{
        register int x;
        printf("%d\n",x);
        x=x+99;
        printf("%d\n",x);
}
//output: 
0
99

=================================================================
#include<stdlib.h>

void foo(auto int i);

void main()
{
        foo(10);
}

void foo(auto int i)
{
        printf("%d\n",i);
}
xyz.c:5:19: error: storage class specified for parameter ‘i’
 void foo(auto int i);
                   ^
xyz.c:12:19: error: storage class specified for parameter ‘i’
 void foo(auto int i)
                   ^

/*
First,quoting C11, chapter 6.7.6.3

The only storage-class specifier that shall occur in a parameter declaration is register.

So, this is explicitly specified in the standard.

That said, this restriction exists because with an explicit storage class like static/ extern, there will be problems in memory management, as function parameters are in the block scope for the function and their lifetimes are limited to the execution of the function body.

A parameter variable cannot outlive the call to the function; otherwise, what would be the effect of the argument in the next call to the same function? So static storage is not meaningful, and auto is redundant.

Since the function parameters has no linkage, extern also makes no sense.

*/




=================================================================

automatic variable have no linkage .....neither internal linkage nor external likage.

=================================================================
xyz.c:8:7: warning: type defaults to ‘int’ in declaration of ‘i’ [-Wimplicit-int]
  auto i=10;
       ^
=================================================================
void main()
{
int i=99;
int j=77;

        printf("%d %d %d %d\n",i,j);
        int k=66;
        printf("%d %d %d %d\n",k, i,j);
}

99 77 0 4195744
66 99 77 7

// so ,values of variaables and then for extra %d..it will gve garbage

=================================================================

Let's start with a simple printf("%s", "abc"). It will print the string abc.

printf("%8s", "abc") will print      abc, including 5 leading spaces: 8 is the "field width". Think of a table of data with column widths so that data in the same column is vertically aligned. The data is by default right-aligned, suitable for numbers.

printf("%-8s", "abc") will print abc     , including 5 trailing spaces: the minus indicates left alignment in the field.

Now for the star: printf("%-*s", 8, "abc") will print the same. The star indicates that the field width (here: 8) will be passed as a parameter to printf. That way it can be changed programmatically.

Now for the "precision", that is : printf("%-*.10s", 8, "1234567890123") will print only 1234567890, ommitting the last three characters: the "precision" is the maximum field width in case of strings. This is one of the rare cases (apart from rounding, which is also controlled by the precision value) where data is truncated by printf.

And finally printf("%-*.*s", 8, 10, "1234567890123") will print the same as before, but the maximum field width is given as a parameter, too.




=================================================================

scanf("%d",i);
it result in segmentation fault but it compiles.
=================================================================

char *p;
        scanf("%s",p);
        printf("%s",p);

//it works fine...

=================================================================
char *p;
        scanf("%s",p);
        printf("%s",*p);

//segmentataion fault

=================================================================

For printf, the * allows you to specify the minimum field width through an extra parameter, e.g. printf("%*d", 4, 100); specifies a field width of 4. A field width of 4 means that if a number takes less than 4 characters to print, space characters are printed until the field width is filled. If the number takes up more space than the specified field width, the number is printed as-is with no truncation.

For scanf, the * indicates that the field is to be read but ignored, so that e.g. scanf("%*d %d", &i) for the input "12 34" will ignore 12 and read 34 into the integer i.



=================================================================

enter , space , tab .....act as a delimiter for an input in scanf



=================================================================
int x=2,y=0;
        int z=(y++)?y==1 && x: 0;
        printf("%d\n",z);
        return 0;

//output: 0



=================================================================
	int x=1;
        short int i=2;
        float f=3;
        if(sizeof((x==2)?f:i)==sizeof(float))
                printf("float\n");
        else if(sizeof((x==2)?f:i)== sizeof(short int))
                printf("short int\n");
        return 0;

//output: float

=================================================================
 int y=1,x=0;
int l=(y++,x++)?y:x;
printf("%d\n",l);

//output: 1

=================================================================


int main()
{
        1<2 ? return 1: return 2;
}

xyz.c: In function ‘main’:
xyz.c:9:8: error: expected expression before ‘return’
  1<2 ? return 1: return 2;
        ^~~~~~


?: is an operator not a control flow construct, so the whole thing with operands must be an expression, and return statements (or any statement) are not valid sub-expressions.

?: is not simply a shorthand for if-else (which is a control flow construct); it is semantically different.

if( a > b ) return a; else return b


=================================================================


int k=8;
        int m=7;
        k<m? k++:m=k;
        printf("%d",k);

xyz.c: In function ‘main’:
xyz.c:11:12: error: lvalue required as left operand of assignment
  k<m? k++:m=k;
            ^

=================================================================

int k=8;
        int m=7;
        k > m ? k=k+1:m=m+1;
        printf("%d",k);


xyz.c:11:16: error: lvalue required as left operand of assignment
  k > m? k=k+1:m=m+1;
                ^

=================================================================

int a=2;
         int c=1;
         c =(c)?a=0 : 2;

         printf("a=%d c=%d",a,c);

//output: a=0 c=0

=================================================================
This operator returns one of two values depending on the result of an expression. If "expression-1" is evaluated to Boolean true, then expression-2 is evaluated and its value is returned as a final result otherwise expression-3 is evaluated and its value is returned as a final result.

int a=2;
         int c=1;
         c =(c)?a=33 : 2;
         printf("a=%d c=%d",a,c);
//output: a=33 c=33

--
int a=2;
         int c=1;
         c =(c)?a=-1: 2;
         printf("a=%d c=%d",a,c);
//output: a=-1 c=-1
=================================================================

         int a=2;
         int c=0;
         c =(c)?a=0:-1;

         printf("a=%d c=%d",a,c);

//output: a=2 c=-1

=================================================================

void r(int i)
{
        if(i>5)
                exit(0);

        printf("%d\n",i);
        return r(i++);
}
int main()
{
        r(1);
}
//output: 1111111111111111111111....segfault ..stack overflow


void r(int i)
{
        if(i>5)
                exit(0);

        printf("%d\n",i);
        return r(++i);
}
int main()
{
        r(1);
}
//output: 1 2 3 4 5
================================================================

void r(int i)
{
        if(i>5)
                exit(0);

        printf("%d\n",i);
        return r(i++,i);
}
int main()
{
        r(1);
}


xyz.c: In function ‘r’:
xyz.c:13:9: error: too many arguments to function ‘r’
  return r(i++,i);
         ^
xyz.c:7:6: note: declared here
 void r(int i)
      ^
================================================================

void r(int i)
{
        if(i>5)
                exit(0);

        printf("%d\n",i);
        return r((i++,i));
}
int main()
{
        r(1);
}

//output: 1 2 3 4 5 

//notice there are two brackets in it ...so it is only one argument ...and the only first argument is contained  in  () which itself is a comma operator case
//here remember the comma operator.
//it will first increment the i and then its second operator is given as input to function call which is incremented i

=================================================================

        int y=2;
        int z=y+(y=10);
        printf("%d \n",z);

//output: 20

xyz.c: In function ‘main’:
xyz.c:20:12: warning: operation on ‘y’ may be undefined [-Wsequence-point]
  int z=y+(y=10);
           ~^~~~


int y=2;
        int z=y+(y=20)+(y=10);
        printf("%d \n",z);
//output: 50

xyz.c:20:19: warning: operation on ‘y’ may be undefined [-Wsequence-point]
  int z=y+(y=20)+(y=10);
                 ~~^~~~
xyz.c:20:19: warning: operation on ‘y’ may be undefined [-Wsequence-point]


=================================================================

        int x=2,y=2;
        float f = y +x/=x/y;
        printf("%d %f\n",x,f);

xyz.c:11:16: error: lvalue required as left operand of assignment
  float f = y +x/=x/y;
                ^~
//so remeber when ever there is equal = to put a value it must a address/variable but not a constant 
//since this expression will have values of the variables not the variables itself

=================================================================

        int x=1,y=2;
        if(x && y == 1)
                printf("true\n");
        else
                printf("false\n");
//false


        int x=1,y=2;
        if(x && (y == 1))
                printf("true\n");
        else
                printf("false\n");

//false

        int x=1,y=2;
        if((x&&y) == 1)
                printf("true\n");
        else
                printf("false\n");

//true
=================================================================

int x=1,y=2;
int z= x & y == 2;
printf("%d",z);

//ouptut: 1


//here the == operator has higher precedence than the &
// so it will check y==2 which is true
//then it will do 1 & 1...which is 1..therefore 'z' is 1 


int x=1,y=2;
        int z= (x&y) == 2;
        printf("%d\n",z);
//output: 0
=================================================================

        int x=3, y=2;
        int z=x /= y %=2;
        printf("%d\n",z); 

//error:Floating point exception (core dumped)
//do 'GDB' and break main, watch x,y,z, step

//first y%=2 will execute... which will become 0
//and then x/=0 .... this will generate floating point execption

=================================================================


        int x=3, y=2;
        int z= x << ( 1 > 5) ;
        printf("%d\n",z);
//output: 3

        int x=3, y=2;
        int z= x << ( 7 > 5) ;
        printf("%d\n",z);
//output: 6


=================================================================

        int x=2,y=0;
        int z= x && y = 1 ;

        printf("%d\n",z);

xyz.c:11:16: error: lvalue required as left operand of assignment
  int z= x && y = 1 ;
                 ^

================================================================

double b=3 && 5 & 4 % 3;
        printf("%lf",b);

//output: 1.000000
%>&>&& precedence

=================================================================

double b=4*6 + 3*4  <3?4:3;
        printf("%lf",b);
//3.000000

*+/ have higher priority with L->R
less than '<' with L->R
ternery with R->L


=================================================================

 double b=3%0*1-4/2;
        printf("%lf",b);

//floating pint exception due to 0
=================================================================

        int a=1, b=2, c=3, d=4, e;
        e = c+d = b*a;
        printf("%d, %d\n",e,d);

xyz.c:11:10: error: lvalue required as left operand of assignment
  e = c+d = b*a;
          ^
=================================================================

int p=10, q=20,r;
        if(r= p =5 || q > 20)
                printf("%d",r);
        else
                printf("Nooo\n");

//output: 1
> has higher precedence
=================================================================
        int x=5;
        if(x<1);
        printf("hello");

//output: hello

=================================================================

int main()
{
        float x=3.0f;

        switch(x)
        {


        }

}

xyz.c: In function ‘main’:
xyz.c:11:9: error: switch quantity not an integer
  switch(x)
         ^
xyz.c:9:8: warning: variable ‘x’ set but not used [-Wunused-but-set-variable]
  float x=3.0f;
         ^
=================================================================

int main()
{
        int x=3;
        switch(x)
        {


        }

}

//compile properly

=================================================================

 
int f(int);
int (*fp)(int)=f;
int f(int var)
{
        printf("---var:%d\n",var);
        return ++var;
}
int main()
{

        f=fp;
        int var=3;
        var=(*fp)(var);
        printf("---var:%d\n",var);
        return 0;
}

// here , remember 
//f=*fp; f=&fp; f=fp;  all will work 
//but they must be kept inside a function
//
//because they are statements ..u cant keep them in data segment 
//only data(variables/defination/declaration/initialization) 
//can be kept inside it
//
//if u do int x; or int x=5; in global
//it works
//
//but x=5; is not allowed... no storage class found error.

=================================================================
int x=1;
if(x>0)
    printf("++++++");
else if(x>0)
    printf("------");
return 0;

//output:+++++++
//it runs perfectly fine 

=================================================================

int x=0;

        if(x == 0)
                printf("true");
        else if(x=10)
                printf("false");

        printf("%d\n",x);

        return 0;
//output: true0


=================================================================

                printf(" %d true\n",1);

=================================================================

case labels cant be outside switch
and switch takes int

u cant have duplicate cases



=================================================================
int main()
{
        int x=97;
        switch(x);
        {
                case 'a':
                        printf("yes");
                        break;

                case 97: printf("no\n");
                         break;
        }

        printf(" %d true\n",1);
        return 0;
}

xyz.c: In function ‘main’:
xyz.c:13:3: error: case label not within a switch statement
   case 'a':
   ^~~~
xyz.c:15:4: error: break statement not within loop or switch
    break;
    ^~~~~
xyz.c:17:3: error: case label not within a switch statement
   case 97: printf("no\n");
   ^~~~
xyz.c:18:5: error: break statement not within loop or switch
     break;
     ^~~~~
=================================================================

int main()
{
        int x=97;
        switch(x)
        {
                case 'a':
                        printf("yes");
                        break;

                case 97: printf("no\n");
                         break;
        }

        printf(" %d true\n",1);
        return 0;
}



xyz.c: In function ‘main’:
xyz.c:17:3: error: duplicate case value
   case 97: printf("no\n");
   ^~~~
xyz.c:13:3: note: previously used here
   case 'a':
   ^~~~

=================================================================

u can print anything using printf without semicolon

by putting it in if(), while(), switch(), 
because it return no of charaters printed.....which is integer.

another way::

#define PRINT
printf("hello")
int main()
{
if(PRINT)
}


=================================================================


comma operator is used to seprate variable declarations,function,arguments,expressions
and also as, the elements for the statement.

=================================================================

i=(j++,k++);
//the i will receive the rightmost value always


while(i=rand()%100, i==50)
//here the while statement uses the comman operator 
//to assignn the value of i and then test it.

===============================================================
loops are controlled by the variables 
so we can check them and see if the loop worked fine or terminated prematuraly

=================================================================
goto: it make u do a local jump

but, longjump() and setjmp() make u jum across functions



when our program calls setjump() the current state of your program is saved in a structure of type jmp_buf. later, your program can call the longjmp().

but DRAWBACK, when restored to previous saved state , it will loose its refrences to allocated memory between the longjmp() and setjmp(). there any malloc between them is a waste


=================================================================

xyz.c: In function ‘main’:
xyz.c:13:2: warning: statement with no effect [-Wunused-value]
  for(k)
  ^~~
xyz.c:13:7: error: expected ‘;’ before ‘)’ token
  for(k)
       ^
xyz.c:13:7: error: expected expression before ‘)’ token
xyz.c:14:3: warning: implicit declaration of function ‘pritf’; did you mean ‘printf’? [-Wimplicit-function-declaration]
   pritf("hello\n");
   ^~~~~
=================================================================

        int k=0;
        for(;;;)
                printf("hello\n");

xyz.c: In function ‘main’:
xyz.c:13:8: error: expected expression before ‘;’ token
  for(;;;)
        ^

=================================================================
//an infifnite loop....... but how

char *str="";
        printf("%d,%s,%c\n",*str,str,*str);
        do
        {
                int x=9;
        }while(str);

[root@localhost rawat]# ./a.out 
0,,
^C      
[root@localhost rawat]# vim xyz.c 

===============================================================

The two declarations are not the same.

char ptr[] = "string"; declares a char array of size 7 and initializes it with the characters
s ,t,r,i,n,g and \0. You are allowed to modify the contents of this array.

char *ptr = "string"; declares ptr as a char pointer and initializes it with address of string literal "string" which is read-only. Modifying a string literal is an undefined behavior. What you saw(seg fault) is one manifestation of the undefined behavior

=================================================================
This is very straight forward if you understand C syntax. Just break it down... the functions each take one parameter. Each of the parameters is a different type...

char *str - This is a single value which is a pointer to a character. When used as a string in C it is implied that in subsequent memory addresses are subsequent charcters in the string, until the end of the string which is marked with a NULL (ascii 0)

char *str[] is an array of many values, each value in the array is a char *str, as above. So, it is an array of null-terminated C strings.

char str[] is an array of characters. It is similar to char *str except that there is no requirement that the last character in the array be null

================================================================
//to break from both loops

int main()
{
        for(int i=0; i<5; i++)
        {
                for(int j=0; j<5; j++)
                {
                        if (i==3 && j==3)
                        {
                                printf("breaking IN %d %d\n",i,j);
                                break;
                        }

                }
                if (i==3 && j==3)
                {
                        printf("breaking IN %d %d\n",i,j);
                        break;
                }
        }
}
//the outer loop will say j undefined


=================================================================


int i,j;
        for(i=0; i<5; i++)
        {
                for(j=0; j<5; j++)
                {
                        if (i==3 && j==3)
                        {
                                printf("breaking IN %d %d\n",i,j);
                                break;
                        }

                }
                if (i==3 && j==3)
                {
                        printf("breaking IN %d %d\n",i,j);
                        break;
                }
        }





//this will break....
// as j is defined outside the loops...so it will be visible to booth loops
//but earlier u declared j in the scope of inner for loop
===============================================================






we cant use sizeof operator to be used to tell the size of an array passed to a function.
passing an array to a function is exactly the saem as passing a pointer to the first element.

so u can pass the size as argument,

compiler can genrate good code for pointers than for subscripts.

===============================================================

memcpy(dest,source, MAX);

===============================================================
void func(char *str[])
{
	while (*str)
		printf("%c",*str++);
	
}
like this u can check the end of string (NUL whose ascii is 0)

===============================================================
arrName : it is the pointer to the first element in the array;
	  &arr[0]

&arrName : it is the pointer to the array as whole;
	   
===============================================================

char arr[ (sizeof( struct A))* MAX];

===============================================================

c strings always end with NUL

char a[]="hello";
it is char array not string...therefore no NUL characters

===============================================================
strcpy() works with srirngs and stops when the terminating null character has been moved . so it include null.

memcpy() is designed for any data type. since all data type does not end with string so we must specify the no of bytes. u can use it with structures.

===============================================================
if u want to remove spaces at the end of string ...u will move till the last charcter and when u first encounter the blank space " " u will put NUL \0  at that position

no if the there are leading spaces..so u will first reverse string and do same as above and then again reverse.


===============================================================
c library have (int float long)format  to string conversion. and vice versa

itoa(), ltoa(), ultoa()...but these are not ANSI compatible ..and another way is sprintf(), fcvt():float to string , ecvt(),gcvt().

atoi(), atof(), atol(), 

strtod(), strtoul() 

===============================================================

strcmp(), strncmp() strnicmp() stricmp() strcmpi()

printf can be used to print the part of the string with help of 
width option in printf(%format)  %widthprecissinlengthflagFormat

===============================================================

char *str="hello, world";
        char *str1="hello, world";
        if(strcmp(str,str1))
                printf("equal\n");
        else
                printf("unequal\n");

//output: unequal

bassically it strings are same ...but strcmp when equal gives zero
and if(0) means execute the else part

===============================================================
 char *str="hello";
        char *str1[5];
        strcpy(str,str1);
        printf("%s\n",str1);

//segmentation fault


xyz.c: In function ‘main’:
xyz.c:13:13: warning: passing argument 2 of ‘strcpy’ from incompatible pointer type [-Wincompatible-pointer-types]
  strcpy(str,str1);
             ^~~~
In file included from xyz.c:6:0:
/usr/include/string.h:121:14: note: expected ‘const char * restrict’ but argument is of type ‘char **’
 extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
              ^~~~~~
xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘char **’ [-Wformat=]
  printf("%s\n",str1);
          ~^    ~~~~


===============================================================

       char *str     ="hello, world";
       char str1[15] ="hello wo 9";

       strcpy(str, str1);

       printf("%s", str1);

// it compile all fine
// but gives segmentation fault

===============================================================

if u remeber 13 memory issue project 303

when u print a string it will keep priting till it see the nul \0 character. 

===============================================================

int main()
{
        char *str ="hello, world";
        char str1[9];
        strncpy(str1,str,9);
        printf("%s %ld\n",str1,strlen(str1));
}

//output: hello, wo`@ 12
it is undefined

so we could say these copy between *str and str1[] are undefined.
===============================================================
	
char *str ="hello, world\n";
      char str1[]="hello, world\n";
      printf("%ld %ld\n", strlen(str), strlen(str1) );

//output: 13 13


===============================================================

        char *str ="hello, world\n";
        char str1[]="hello, world\n";
        printf("%ld %ld\n", strlen(str), strlen(str1) );
        printf("%ld %ld\n", sizeof(str), sizeof(str1) );
//output:
13 13
8 14
  
===============================================================

        char *str ="hello, world";
        char str1[]="hello, world";
        printf("%ld %ld\n", strlen(str), strlen(str1) );
        printf("%ld %ld\n", sizeof(str), sizeof(str1) );
//output:
12 12
8 13

===============================================================

        char str[]="hello";
        char *str1 ="world";
        strcat(str,str1);
        printf("%s %d",str,str[10]);

//output: helloworld 0

===============================================================

char str[5]="hello";
        char *str1 ="world";
        strcat(str,str1);
        printf("%s %d",str,str[10]);
//output:hello@world 114
undefined behaviour.

===============================================================
 char str[10]="hello";
 printf(":%s:\n%d",str,str[10]);

//output:

:hello:
-80

===============================================================

        char str[10]="hello";
        char *str1 ="world";
        strncat(str,str1,2);
        printf(":%s:\n",str);

//output
:hellowo:
===============================================================

        char str[10]="hello";
        char *str1 ="world";
        strncat(str,str1,15);
        printf(":%s:\n",str);

//output
:helloworld:
---

strncat(str,str1,5);
:helloworld:

strncat(str,str1,9);
:helloworld:



===============================================================

strcat(), strcmp(), strcpy(), strlen() rely on presence of NULL character

       strchr, strrchr, strchrnul - locate character in string
       strcasecmp, strncasecmp - compare two strings ignoring case
       strstr, strcasestr - locate a substring
       memchr, memrchr, rawmemchr - scan memory for a character

//look in mapages for more functions
===============================================================

int var=strcmp("Hello", "World");

var will be -1(negative)
check man page
===============================================================

The  strchr()  function  returns  a  pointer to the first
       occurrence of the character c in the string s.

The strrchr() function returns  a  pointer  to  the  last
       occurrence of the character c in the string s.

The  strchrnul() function is like strchr() except that if
       c is not found in s, then it returns  a  pointer  to  the
       null byte at the end of s, rather than NULL.

===============================================================

#include<ctype.h>
int main()
{
        char i=9;
        char i1='9';
        int j=9;
        int j1='9';

        if(isdigit(i))
                printf("--- i\n");

        if(isdigit(i1))
                printf("--- i1\n");

        if(isdigit(j))
                printf("--- j\n");

        if(isdigit(j1))
                printf("--- j1\n");

}

--- i1
--- j1

===============================================================

 if(isspace('\n'))
                printf("+++++ space \\n \n");
//output:
+++++ space \n 

===============================================================

if(isspace(' '))
                printf("+++++ space ' ' \n");


//output:
+++++ space ' ' 

===============================================================

if(isspace('\t'))
                printf("+++++ space \\t \n");

//output:
+++++ space \t 

//similarly \v,\r

//but not \b,\a
===============================================================

fgetc, fgets, getc, getchar, ungetc - input of characters and strings

       int ungetc(int c, FILE *stream);
 ungetc() pushes c back to stream, cast to unsigned char, where it is available for subsequent read operations.   Pushed-back
       characters will be returned in reverse order; only one pushback is guaranteed.

===============================================================
       fgetwc, getwc - read a wide character from a FILE stream
===============================================================

u do scanf a integer ,then do ungetc, then scanf ,then printf

so it will print the integer u typed first time.

=============================================================

using static  before function restricts its access to the file where they are declared .

static functions  should be decclared and definedd in the same file.

===============================================================
prototype helps compiler in ensuring the correct argument type

===============================================================
int x[10];//array

funcall(x)//passing address of array

funcallreceived(int i[])//as they array is passed by value an exact copy of the array is made and placed on the stack. the the fucntion receives copy of this array. modifing the int i[] will have no effect on the int x[]....since it is the copy of the array.

//this is inefficient ...as it copies and take time and memory

//therefore insted of passing arraya by value
we should pass by refrence.

to do so ... declare pointer to the data type in the functions prototype


function(cont int *)

int x[10];
funccall(x);//now it receives the array by refrence 


//adn it receive it as const ..therefore no change
//and inside the functionreceived(const int *i) 
// you can traverse it by *(i+ index_var);


===============================================================

atexit - register a function to be called at normal process termination

       #include <stdlib.h>

       int atexit(void (*function)(void));


so if u want to execute the code when program exits u can....cleanup code ..and they functions are executed in LIFO manner if u have called atexit(func1) ...atexit(func2)...multiple time


===============================================================
generaly fucntion parameters are passed right to left...but in PASCAL convetion it is from left ot right..

it means in the stack the rightmost is stored in first for C language.


the functions using PASCAL convention are more efficient than regular C functions.
int PASCAL func();
===============================================================

return ; it goes back to the calling function

exit ; program is closed and control goes back to OS

===============================================================
int main()
{
        void foo(),f();
        f();

}

void foo()
{
        printf("2");
}

void f()
{
        printf("1");
        foo();
}

//output: 1 2

===============================================================

int main()
{
        void foo();
        void f()
        {
                printf("1");
                foo();
        }
        f();
}

void foo()
{
        printf("2");
}
//output: 1 2
it could be language and comiler dependent

===============================================================
u can write prototype multiple time anywhere 
but only one defination.

no multiple defination is allowed ...even though they are exact saem defination.

===============================================================

        void foo();
        void foo(int);
int main()
{


        foo(5);
}

void foo(int i)
{
        printf("222222 %d",i);
}

//output: 222222 5

// in c function overloading is not allowed ...
//only one prototype ..no multiple prototype
//no multiple defiantion

but u can have a an empty argument prototype adn as well as a prototype with some arguments.
===============================================================

void foo(void);
void foo(int);
int main()
{


        foo(5);
}

void foo(int i)
{
        printf("222222 %d",i);
}


xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo(int i)
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
      ^~~


//so u can only have a empty prototype
===============================================================

        void foo(void);
        void foo(int);
int main()
{


        foo(5);
}

void foo()
{
        printf("222222 ");
}




xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo()
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~

===============================================================

void foo(void);
        void foo(int);
int main()
{


        foo();
}

void foo()
{
        printf("222222 ");
}


xyz.c:9:7: error: conflicting types for ‘foo’
  void foo(int);
       ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~
xyz.c: In function ‘main’:
xyz.c:14:2: error: too few arguments to function ‘foo’
  foo();
  ^~~
xyz.c:9:7: note: declared here
  void foo(int);
       ^~~
xyz.c: At top level:
xyz.c:17:6: error: conflicting types for ‘foo’
 void foo()
      ^~~
xyz.c:8:7: note: previous declaration of ‘foo’ was here
  void foo(void);
       ^~~


===============================================================

 sqrt, sqrtf, sqrtl - square root function

       #include <math.h>

       double sqrt(double x);
       float sqrtf(float x);
       long double sqrtl(long double x);

       Link with -lm.

============================================================

       csqrt, csqrtf, csqrtl - complex square root

       #include <complex.h>

       double complex csqrt(double complex z);
       float complex csqrtf(float complex z);
       long double complex csqrtl(long double complex z);

       Link with -lm.
===============================================================

void foo(void);

int main()
{
        int k= foo();
        printf("%d\n",k);
}

void foo()
{
        printf("1234567890");
}


xyz.c: In function ‘main’:
xyz.c:11:9: error: void value not ignored as it ought to be
  int k= foo();
         ^~~
===============================================================


int foo(void);
int main()
{
        int k= foo();
        printf("%d\n",k);
}
int foo()
{
      printf("1234567890");
}

xyz.c: In function ‘foo’:
xyz.c:18:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
===============================================================

int* foo()
{
        int *p=5;

        return p;

}

int main()
{
        int *k= foo();
        printf("%d\n",k);
}

//output:5




xyz.c: In function ‘foo’:
xyz.c:10:9: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  int *p=5;
         ^
xyz.c: In function ‘main’:
xyz.c:19:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘int *’ [-Wformat=]
  printf("%d\n",k);
          ~^
          %ls


The %ls format specifier represents a wide string

===============================================================

int* foo()
{
        int arr[]={5,8};
        return arr;

}
int main()
{
        int *k= foo();
        printf("%d\n",k[0]);
}
//output: segmentation fault

xyz.c: In function ‘foo’:
xyz.c:11:9: warning: function returns address of local variable [-Wreturn-local-addr]
  return arr;
        ^~~
===============================================================

int foo()
{
        int arr[]={5,8};
        return arr[1];

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}
//output: 8

===============================================================

int * foo()
{
        int arr[]={5,8};
        return arr;

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}

// output: 0(but i can varry)

xyz.c: In function ‘foo’:
xyz.c:12:9: warning: function returns address of local variable [-Wreturn-local-addr]
  return arr;
         ^~~
xyz.c: In function ‘main’:
xyz.c:17:9: warning: initialization makes integer from pointer without a cast [-Wint-conversion]
  int k= foo();
         ^~~

===============================================================

foo()
{
        return 'A';

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}
//output: 65 

xyz.c:9:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 foo()
 ^~~

===============================================================

double foo();

foo()
{
        return 2;

}
int main()
{
        int k= foo();
        printf("%d\n",k);
}



xyz.c:10:1: warning: return type defaults to ‘int’ [-Wimplicit-int]
 foo()
 ^~~
xyz.c:10:1: error: conflicting types for ‘foo’
xyz.c:8:8: note: previous declaration of ‘foo’ was here
 double foo();
        ^~~


===============================================================

enum m{ A , B , C , D};

enum m  foo();

int foo()
{
        return D;

}

int main()
{
        enum m i = foo();
        printf("%d\n",i);
}



xyz.c:12:5: error: conflicting types for ‘foo’
 int foo()
     ^~~
xyz.c:10:9: note: previous declaration of ‘foo’ was here
 enum m  foo();
         ^~~

===============================================================


enum m{ A , B , C , D};

enum m  foo();

enum m foo()
{
        return D;

}

int main()
{
        enum m i = foo();
        printf("%d\n",i);
}

//output: 3

it works..fine....

===============================================================


enum m{ A , B , C , D};

enum m  foo();

enum m foo()
{
        return D;

}

int main()
{
        enum m = foo();
        printf("%d\n",m);
}


xyz.c: In function ‘main’:
xyz.c:20:9: error: expected identifier or ‘(’ before ‘=’ token
  enum m = foo();
         ^
xyz.c:21:16: error: ‘m’ undeclared (first use in this function)
  printf("%d\n",m);
                ^
xyz.c:21:16: note: each undeclared identifier is reported only once for each function it appears in

===============================================================


       stdarg, va_start, va_arg, va_end, va_copy - variable argument lists


       #include <stdarg.h>

       void va_start(va_list ap, last);
       type va_arg(va_list ap, type);
       void va_end(va_list ap);
       void va_copy(va_list dest, va_list src);

===============================================================

int x[5]={1,2,3,4,5};

int y[5];
y=x; // it is wrong..  we cant treat arrar as lvalue 
//because it consist of many elements... and x does not mean anuthing ...its array element which means.

but,
if u want to copy the elements at once..
memcpy(x,y,5);


but, 
if u have struture u can treat it a Lvalue,
ie....you can assign the variables
struct_var1=struct_var2;

===============================================================
Lvalues are on left and Rvalues are on right of the assignment

Rvalue is mostly a expression, or a constant

x=1; 
//x is lvalue
// 1 is rvalue (constant)

a assignment statement must have L and R values.

int x;
x=void_returning_func();
//if the function call had returned something ...it would have been ok
//but here r value misssing;

Rvalue evaluates into something that can be put into Lvalue.

===============================================================

int *p;

'p' can be used as lvalue since it can be indirected to store

but a pointer to the constant is not a lvalue because to the point which it is point to is constan.

==============================================================

NULL is macro in <stddef.h>

NULL is literal zero cast to void* or char* , but int* might not work . so we need something that points to zero after conversion

NULL pointers are also used as errors.
NULL pointers are also used to stop imdirection (like in link list)
NULL pointers are also used as sentinel value( as last value for variable arguments.... execl)


===============================================================
void pointer... the compiler has no idea to which kind of object it points.
for int* pointer ...compiler knows it will point to an integer type.

void is used when working for raw data or an unspecified type.

valaue of NULL pointer is equall to zero, but it is not stored as same as zero.
(cast NULL to other types ..and print it. you can also use debugger to see the value.)

===============================================================

qsort()
void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(const void *, const void *));



===============================================================
compilers for PC compatibiles uses two kind of pointer.

near pointer: 16 bit long..and can address a 64KB range.
far pointers: are 32 bit long and can address a 1MB

near pointers operate within a 64KB segment. far pointers have 16 bit base and a 16 bit offset.

before we compile our code , you must tell the compilers which memeory model to use. far pointers are little slower

sometimes things which do not fit into data segment and code segments..then u use far pointers


===============================================================

int main()
{
        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fprintf(stderr,":%d + %d:",95,95);
        fprintf(fp,":%d - %d:",45,45);

        return 0;
}

//output: :95 + 95::45 - 45::45 - 45:


===============================================================

int main()
{
        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:\n",45,45);
        fprintf(stderr,":%d + %d:\n",95,95);
        fprintf(fp,":%d - %d:\n",45,45);

        return 0;
}

//output:
:45 - 45:
:95 + 95:
:45 - 45:

===============================================================

FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fflush(stdout);
        fprintf(stderr,":%d + %d:",95,95);
        fprintf(fp,":%d - %d:",45,45);

        return 0;

//output:
:45 - 45::95 + 95::45 - 45:

===============================================================

        FILE  *fp=stdout;
        fprintf(fp,":%d - %d:",45,45);
        fflush(stdout);
        fprintf(fp,":%d - %d:",45,45);
        fprintf(stderr,":%d + %d:",95,95);

        return 0;
//output:
:45 - 45::95 + 95::45 - 45:

===============================================================


errno is a global variable . mostly used by c libraries to store the error value of the functions failed but many times it is not updated by the functions .

so it is not a good idea to use it, insted use the value returned from the fucntion to check for errors.

===============================================================

stream is the continous series of bytes.... that flows in or out of our program. 

input and output from the devices are handled as streams....ie byte by byte. streams appears as logical files(not physically).

stdin - keyboard
stdout - screen
stderr - screen
 

stdout stream can be redirected to file in disk.
stdin can be redirected to the file in disk.

to redirect stream in your program use freopen()
u can use fdopen() and dup() // see man page 

===============================================================
streams can be text stream or byte stream. 
===============================================================
use low level IO fnctions when accessing shared files.

but when accessing non shared files use the buffered stream functions (fopen(), fread(), fwrite()....) 

===============================================================

char *envPathString;

envPathString=getenv("PATH");
if(envPathString != NULL)
printf("path:=%s",envPathString);

===============================================================

sopen(), u can open file in shared mode andd expilicitly deny reading and writing permissions to any other programs but yours (SH_DENYWR flag).

===============================================================

bit feilds are not portable. because the number of bits in a machine word is different on different machine, a particular program using bit feilds might not even compile on a particular machine

int a:30;
int b:2;
this will work for machine having integer value in 32 bits 

but if we go to an architecture that uses 16 bits to store integer vlaue it will not even compile..it will result in error.

===============================================================

u may do bit shift or do multiplication by 2
it doesnt matter..it works same inside....

so it is advised to use technique ...where it is more readable.
===============================================================

bit masking means which bit you want to SET and which bit you want to CLEAR

to __examine__ some bits of a byte, 

the byte is bitwised 'ANDed' with a mask that is a number consisting only of those bits of interests:  " num & 1" will be used to examin the rightmost digit .if it is high(1) the resultant will be oen. similarly u want to check/examine the 3rd last digit of a number 'num': " num & (1<<3) " OR " num & 8" ..if u get resultant as 8, it means it is set.

 

to __SET__ a bit
 set the rightmost bit :num | 1
 set 3rd last bit : " num | (1<<3) " or " num | 8 "


to __CLEAR__ a bit

bitwise AND the number with the one's complement of the bit mask.
clearing the last bit(rightmost): num = num & ~1
clearing the 3rd last bit from right : "num & ~8 " or " num & ~(1<<3) "


===============================================================
the array in the second argument of command line argumnts is the' int **argv'....ie jagged array or array of array.

A jagged array is an array whose elements are arrays. The elements of a jagged array can be of different dimensions and sizes. A jagged array is sometimes called an "array of arrays."
===============================================================

printf(" %s\n", argv[argc]);
notice the subscript operator argv[argc].

it will print null, because array index start from zero

===============================================================

xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
  printf("%s\n",argc);
          ~^
          %d
===============================================================

        printf("%d\n",argc);

//output:
[root@localhost rawat]# ./a.out hello hi 5 10 bye
6


[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL \0
8
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0'
8
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0' (void*)0
-bash: syntax error near unexpected token `('
[root@localhost rawat]# ./a.out hello hi 5 10 bye NULL '\0' "(void*)0"
9
[root@localhost rawat]# 

===============================================================

        printf("-----------------\n");

        printf("%c \n",*(*(argv+0)+0) );
        printf("%c \n",*(*(argv+0)+1) );
        printf("%c \n",*(*(argv+0)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+1)+0) );
        printf("%c \n",*(*(argv+1)+1) );
        printf("%c \n",*(*(argv+1)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+2)+0) );
        printf("%c \n",*(*(argv+2)+1) );
        printf("%c \n",*(*(argv+2)+2) );
        printf("-----------------\n\n");

        printf("%c \n",*(*(argv+3)+0) );
        printf("%c \n",*(*(argv+3)+1) );
        printf("%c \n",*(*(argv+3)+2) );


[root@localhost rawat]# ./a.out ABCDEF abcdef 12345 UVWXYZ uvwxyz
-----------------
. 
/ 
a 
-----------------

A 
B 
C 
-----------------

a 
b 
c 
-----------------

1 
2 
3 
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# ./a.out ABCDEF uv
-----------------
. 
/ 
a 
-----------------

A 
B 
C 
-----------------

u 
v 
 
-----------------

Segmentation fault (core dumped)
[root@localhost rawat]# vim xyz.c 

[root@localhost rawat]# ./a.out 12345 UVWXYZ uvwxyz
-----------------
. 
/ 
a 
-----------------

1 
2 
3 
-----------------

U 
V 
W 
-----------------

u 
v 
w 
[root@localhost rawat]# 




===============================================================

        printf("%s\n",argv[0]);
        printf("%s\n",argv[1]);
        printf("%s\n",argv[2]);
        printf("%s\n",argv[3]);
        printf("%s\n",argv[4]);

[root@localhost rawat]# ./a.out 4 hi bye 5 
./a.out
4
hi
bye
5
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 4 hi bye 5 hello ok
./a.out
4
hi
bye
5
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 4 hi 
./a.out
4
hi
Segmentation fault (core dumped)
[root@localhost rawat]# 
===============================================================



        printf("%c\n",argv[0][0]);
        printf("%c\n",argv[1][0]);
        printf("%c\n",argv[2][0]);
        printf("%c\n",argv[3][0]);
        printf("%c\n",argv[4][0]);



[root@localhost rawat]# ./a.out 65 hi zz abc xyz
.
6
h
z
a
[root@localhost rawat]# 



===============================================================
  printf("%s\n",*argv+1);
        printf("%s\n",*argv+2);
        printf("%s\n",*argv+3);


[root@localhost rawat]# ./a.out 65 hi zz abc xyz
/a.out
a.out
.out
[root@localhost rawat]# 


===============================================================
        printf("%s\n",*(argv));
        printf("%s\n",*(argv+1));
        printf("%s\n",*(argv+2));
        printf("%s\n",*(argv+3));

[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
./a.out
p65
hi99
z8z
[root@localhost rawat]# 



===============================================================


        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));
        printf("%s\n",*(argv++));

[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
./a.out
p65
hi99
z8z
[root@localhost rawat]# 



===============================================================
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));
        printf("%c\n",**(argv++));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
.
p
h
z
[root@localhost rawat]# 


===============================================================

        printf("%c\n",**(argv+0));
        printf("%c\n",**(argv+1));
        printf("%c\n",**(argv+2));
        printf("%c\n",**(argv+3));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
.
p
h
z
[root@localhost rawat]# 


===============================================================

        printf("%s\n",((*argv)+1));
        printf("%s\n",((*argv)+2));
        printf("%s\n",((*argv)+3));

OR

        printf("%s\n",(*(argv)+1));
        printf("%s\n",(*(argv)+2));
        printf("%s\n",(*(argv)+3));


[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
/a.out
a.out
.out
[root@localhost rawat]# 



===============================================================


        printf("%s\n",*(argv+1)+0);
        printf("%s\n",*(argv+2)+0);



[root@localhost rawat]# ./a.out p65 hi99 z8z ab10c xyz
p65
hi99
[root@localhost rawat]# 


===============================================================
        printf("%s\n", *((argv+1)+2) );
        printf("%s\n", *((argv+2)+2));

[root@localhost rawat]# ./a.out p656p hi9ih z8z ab10c xyz
z8z
ab10c
[root@localhost rawat]#


===============================================================

===============================================================
===============================================================

        printf("%s\n",argv[1][0]);

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g
xyz.c: In function ‘main’:
xyz.c:14:11: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
  printf("%s\n",argv[1][0]);
          ~^    ~~~~~~~~~~
          %d


===============================================================
        printf("%d\n",argv[1][0]);

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)

===============================================================

        printf("%d\n",argv[0][0]);
        printf("%d\n",argv[0][1]);
        printf("%d\n",argv[0][2]);
        printf("%d\n",argv[0][3]);
        printf("%d\n",argv[0][4]);
        printf("%d\n",argv[1][0]);



[root@localhost rawat]# ./a.out hello 5 hi 
46
47
97
46
111
104




===============================================================

        printf("%d\n",argv[0]);

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g
xyz.c: In function ‘main’:
xyz.c:14:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[0]);
          ~^    ~~~~~~~
          %s
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[1]);
          ~^    ~~~~~~~
          %s
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[2]);
          ~^    ~~~~~~~
          %s
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[3]);
          ~^    ~~~~~~~
          %s
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%d\n",argv[4]);
          ~^    ~~~~~~~
          %s



===============================================================
======	new concepts in char **argv	=======================


int main(  int argc, char **argv)
{

        while(*argv++ != NULL)
                printf("%s\n",*argv);

        return 0;
}

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)


[root@localhost rawat]# ./a.out hii
hii
Segmentation fault (core dumped)
[root@localhost rawat]# ./a.out hii byee
hii
byee
Segmentation fault (core dumped)
[root@localhost rawat]# ./a.out hii byee but-why
hii
byee
but-why
Segmentation fault (core dumped)
[root@localhost rawat]# 

===============================================================

int main(  int argc, char **argv)
{

        while(*++argv != NULL)
                printf("%s\n",*argv);

        return 0;
}


[root@localhost rawat]# ./a.out 
[root@localhost rawat]# ./a.out hii byee
hii
byee
[root@localhost rawat]# 

===============================================================
while(*argv != NULL)
                printf("%s\n",*argv++);

[root@localhost rawat]# ./a.out 
./a.out
[root@localhost rawat]# ./a.out  helllo 0
./a.out
helllo
0
[root@localhost rawat]# 




===============================================================

while(*argv != NULL)
        {
                printf("%s\n",*(argv++));
        }


[root@localhost rawat]# ./a.out  helllo 0
./a.out
helllo
0
[root@localhost rawat]# 



===============================================================

 while(*argv != NULL)
        {
                printf("%s\n",(*argv)++);
                sleep(2);
        }



[root@localhost rawat]# ./a.out
./a.out
/a.out
a.out
.out
out
ut
t

LS_COLORS=rs=0:di=38;5;33:ln=38;5;51:mh=00:pi=40;38;5;11:so=38;5;13:do=38;5;5:bd=48;5;232;38;5;11:cd=48;5;232;38;5;3:or=48;5;232;38;5;9:mi=01;05;37;41:su=48;5;196;38;5;15:sg=48;5;11;38;5;16:ca=48;5;196;38;5;226:tw=48;5;10;38;5;16:ow=48;5;10;38;5;21:st=48;5;21;38;5;15:ex=38;5;40:*.tar=38;5;9:*.tgz=38;5;9:*.arc=38;5;9:*.arj=38;5;9:*.taz=38;5;9:*.lha=38;5;9:*.lz4=38;5;9:*.lzh=38;5;9:*.lzma=38;5;9:*.tlz=38;5;9:*.txz=38;5;9:*.tzo=38;5;9:*.t7z=38;5;9:*.zip=38;5;9:*.z=38;5;9:*.Z=38;5;9:*.dz=38;5;9:*.gz=3
_____SEGFAULT______

===============================================================




===============================================================




===============================================================

Originally Answered: Why are one's complement and two's complement systems used in computer systems?
Ones’ complement is simply the value obtained by inverting all of the bits in a binary number (swapping 1’s and 0’s).

So 1 in binary (using 8-bit numbers) is 00000001, or 0x01 in hexadecimal, and the ones’ complement, or -1, would be 11111110, 0r 0xFE.

When adding two numbers, if a carry results then it must be added back in (known as an end around carry). This happens for example in the following example where a negative number is added to a positive one (subtraction):

example: 33 - 7:

  00100001  or 0x21 (33) 
  11111000  or 0xF9 (two’s complement of 7) 
  ======== 
1 00011001 
         1  add end-around carry 
  ======== 
  00011010 or 0x1A (26) 
The main disadvantage of ones’ complement, is that there are two valid representations for 0: all 0’s, and all 1’s.

This is 0: 00000000 and so is this: 11111111.

When in grad school, we did all of our assignments on a large mainframe called the Univac 1108, which used ones’ complement arithmetic, and had to deal with the two kinds of zero when programming in assembly language.

Two’s complement, on the other hand, is defined as the one’s complement of a number, plus one (unsigned). So again 1 is 00000001, 0x01, and the two’s complement, or -1, would be 11111110 + 1, or 11111111, or 0xFF.

Even though it takes an extra step to form the two’s complement of a number, two’s complement is pretty much universally used in today’s computer systems. It makes addition of a positive and negative number (i.e. subtraction) simpler: just add them as if they were both unsigned:

example: 33 - 7:

  00100001  or 0x21 (33) 
  11111001  or 0xFA (two’s complement of 7) 
  ======== 
  00011010  or 0x1A (26) 
The carry is ignored.


===============================================================

Ones and two complements have two very useful property :

You can store a one or two’s complement of a value in memory without needing extra flags etc.
if you want to say do a-b, then if you convert b to it’s complement version - call it b’ , you can do a + b’ and still get the right answer. Since you already have a twos complement converter in your CPU (so that you can store negative numbers), you now also only need an adder circuit to do both addition and subtraction.

===============================================================

The primary advantage of two's complement over one's complement is that two's complement only has one value for zero.

One's complement has a "positive" zero and a "negative" zero, thereby increasing memory usage.

our main theme is we have to use less memory and should get most affective output

hence we get more effective output in 2’s complement


===============================================================

when you press the key 'A', your keyboard sends a combination of 1s and 0s through a bundle of 7 wires.

Okay now what actually happens when you press the key 'A' ?
Our computer has a standard code for each character, like 'A', so when you press the key 'A', its standard code '1000001' is sent to the computer by your keyboard(send electrical current). There are Seven wires for your keyboard. The standard code of 'A' is '1000001'. Your keyboard sends an electrical current through the first wire(that represents 1), then no current at all through the second, third, fourth, fifth and sixth wire (which represents 0) and then, an electrical current again through the seventh wire.

Now the question is how does your computer understand the code you just sent?


As I said earlier, computer has many many circuits built inside it, when you send the electrical signals, they are directed to these circuits. Computer can not understand us but, they can understand that 'so-in-so' circuit has current passing through it. So when your keyboard sends the electrical signals, at that time, computer does not get the code. Your computer says, "Okay, circuit number one received an electrical current, so that means one. Circuit Number two did not receive any current therefore, it must be zero........and circuit number seven received an electrical current so that means 1. Now, its 1, 0, 0, 0, 0, 0, 1. That means the user is trying to send me this code.

Hope you understood practically how computer work also.

===============================================================

2's Complement - Only applicable for binary representation.

Step 1. Convert into Binary
Step 2. Take 2's Complement

Binary Conversion
Step 1a. 45 = 101101
45/2 = 22 R -> 1
22/2 = 11 R -> 0
11/2 = 05 R -> 1
05/2 = 02 R -> 1
02/2 = 01 R -> 0
01/02= 00 R -> 1
reading upwards 101101

Step 1b. 0.75 = 0.11
0.75x2 = 1.50 C -> 1
0.50x2 = 1.00 C -> 1
reading downwards 0.11

45.75 = 101101.11

2's Complement (we need to know how many bits are used for representing the number)
For positive numbers, 2's complement is the same.
For negative numbers reverse all digits and add 1.
+45.75 = 0000101101.11 (12 bits for mantisa and 4 bits for exponent - just assuming !)
-45.75 = 1111010010.01


===============================================================

With 2's complement, only one set of instructions is needed to perform both signed and unsigned arithmetic.

For example, if you add 1011 to 0111, you'll get 0010 whether the numbers are interpreted as signed numbers (–5 plus 7) or unsigned (11 plus 7 is 18 with overflow).

If you use a sign-bit representation, that's –3 plus 7, and you'll need a different instruction to add them to get the right answer 4.

With 1's complement, a representation that was once used in some computers, only one set of instructions was needed, but there were two different representations of 0: positive 0 was all 0's, negative 0 was all 1's. That could be seen as a minor inconvenience although in some circumstances it can be a minor advantage.



Because it allows the same methods for performing addition, subtraction and multiplication for signed numbers as for unsigned numbers (and also the same circuitry? The same adder in the ALU can do both addition and subtraction) . If you use the sign-magnitude representation for representing signed numbers, you will need different set of rules for the basic arithmetic operations for signed numbers and also specialized circuitry.

===============================================================

Storing it as 2's compliment has many advantages.

If you use the same bit sequence with a prefixed sign bit, there will be 2 representations for zero : 00000000 and 10000000 (assuming integer is 8 bit).

Now that wastes 2 representations for the same value and you can store only (127x2 + 1 = ) 255 values.

But if you use 2's complement method, the same 8 bit integer can represent numbers from -128 to +127 which makes 256 possible values.

===============================================================
Advantages of Two’s Complement number system

Negative integers : 2's complement makes sense to be used for negative integers. 1's complement is just a computation technique which might be helpful to evaluate 2's complement. The real (defeated) rival of 2's complement was the sign-magnitude representation for negative integers.

No overflow : 1's complement has no special usage for negative integers. 2's complement makes sense because it can be used in natural addition and subtraction arithmetic without any need to change the bits. Providing that no overflow occurs, the sign bit of the result is just the right value. The bit number promotion in this notation is straight forward, for example, to promote an 8-bit signed integer to 16, we could simply repeat the sign bit of integer value in the high byte of it.

Sign magnitude : On the contrary, the sign-magnitude notation is just the way that human uses to represent negative integers. The bit number promotion and addition subtraction arithmetic is a bit mess with this notation.

The primary advantage of two's complement over one's complement is that two's complement only has one value for zero. One's complement has a "positive" zero and a "negative" zero.
Next, to add numbers using one's complement you have to first do binary addition, then add in an end-around carry value.
Two's complement has only one value for zero, and doesn't require carry values.



===============================================================
No, sign-magnitude is a way of representing a signed binary number with the use of its first (most significant) bit. Sign-magnitude has the problem of having both a positive and negative zero


===============================================================

The CPU “knows” you’re using a specific negative integer representation because that “knowledge” is built into the instructions that deal with these values (i.e., the add instructions, the subtract instructions, etc.). More specifically, it’s built into the hardware (or in some cases, it’s built into the microcode) that implements the specific instructions that might have to deal with negative integers.

Most modern mainstream CPUs are designed to use two’s complement representation for negative integer values, but during my lengthy career, I have run into a few CPUs and I/O devices that have used one’s complement (along with 6-bit bytes, 60-bit words, and other things now considered oddities). In a microcoded CPU, where sets of very low-level microinstructions implement the CPU instructions that developers would see, it’s possible to configure the CPU instructions to use a different negative representation (e.g., one’s complement) by changing the microcode.

The compiler and/or assembler you’re using needs to have the knowledge of the negative integer representation used in the target CPU, so that when you use a constant such as -42, the correct representation of that negative value is encoded properly.

For floating-point values, if you have an FPU (floating-point unit), the fact that you’re using IEEE 754 representation or some other representation is also built into the hardware’s floating-point instructions (or into the microcode that implements those instructions). If you don’t have an FPU (e.g., back in the days of the Intel i386, in a modern micrcontroller that has no hardware floating-point support, etc.), and floating point is completely implemented in software, then any representation might be chosen, theoretically.



===============================================================

The nice thing about this is if adding a normal integer to a 1’s or 2’s complement of another turns it into a subtraction instead. Thus there’s no extra hardware needed to make a subtraction, the normal addition can be used with just a toggling circuit to turn one of the numbers into a 1’s or 2’s complement.


===============================================================
A callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time 

In simple language, If a reference of a function is passed to another function as an argument to call it, then it will be called as a Callback function.

In C, a callback function is a function that is called through a function pointer.


// A simple C program to demonstrate callback 
#include<stdio.h> 
  
void A() 
{ 
    printf("I am function A\n"); 
} 
  
// callback function 
void B(void (*ptr)()) 
{ 
    (*ptr) (); // callback to A 
} 
  
int main() 
{ 
    void (*ptr)() = &A; 
      
    // calling function B and passing 
    // address of the function A as argument 
    B(ptr); 
  
   return 0; 
}



There is no "callback" in C - not more than any other generic programming concept.

They're implemented using function pointers. Here's an example:

void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}

int getNextRandomValue(void)
{
    return rand();
}

int main(void)
{
    int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);
    ...
}

Following are some interesting facts about function pointers.

 
1) Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code.
2) Unlike normal pointers, we do not allocate de-allocate memory using function pointers.
3) A function’s name can also be used to get functions’ address. 


For example, in the below program, we have removed address operator ‘&’ in assignment. We have also changed function call by removing *, the program still works.

#include <stdio.h> 
// A normal function with an int parameter 
// and void return type 
void fun(int a) 
{ 
    printf("Value of a is %d\n", a); 
} 
  
int main() 
{  
    void (*fun_ptr)(int) = fun;  // & removed 
  
    fun_ptr(10);  // * removed 
  
    return 0; 
}


4) Like normal pointers, we can have an array of function pointers. Below example in point 5 shows syntax for array of pointers.

 
5) Function pointer can be used in place of switch case. For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.

#include <stdio.h> 
void add(int a, int b) 
{ 
    printf("Addition is %d\n", a+b); 
} 
void subtract(int a, int b) 
{ 
    printf("Subtraction is %d\n", a-b); 
} 
void multiply(int a, int b) 
{ 
    printf("Multiplication is %d\n", a*b); 
} 
  
int main() 
{ 
    // fun_ptr_arr is an array of function pointers 
    void (*fun_ptr_arr[])(int, int) = {add, subtract, multiply}; 
    unsigned int ch, a = 15, b = 10; 
  
    printf("Enter Choice: 0 for add, 1 for subtract and 2 "
            "for multiply\n"); 
    scanf("%d", &ch); 
  
    if (ch > 2) return 0; 
  
    (*fun_ptr_arr[ch])(a, b); 
  
    return 0; 
} 
Enter Choice: 0 for add, 1 for subtract and 2 for multiply
2
Multiplication is 150 


6) Like normal data pointers, a function pointer can be passed as an argument and can also be returned from a function.
For example, consider the following C program where wrapper() receives a void fun() as parameter and calls the passed function.

// A simple C program to show function pointers as parameter 
#include <stdio.h> 
  
// Two simple functions 
void fun1() { printf("Fun1\n"); } 
void fun2() { printf("Fun2\n"); } 
  
// A function that receives a simple function 
// as parameter and calls the function 
void wrapper(void (*fun)()) 
{ 
    fun(); 
} 
  
int main() 
{ 
    wrapper(fun1); 
    wrapper(fun2); 
    return 0; 
}
This point in particular is very useful in C. In C, we can use function pointers to avoid code redundancy. 
===============================================================
Q. Where are enum members stored in memory? How does the compiler generate code for enumerations? —  Ashwin Karanth

Enumerations are just named constants. For this reason, the initialisation value of enumerations should be “constant expressions”. A C/C++ compiler replaces them with their equivalent values during compilation. So enumerations don’t have any role to play when the program executes.

===============================================================

In your machine, maybe the sizes of int and long are the same. That need not be the case for all machines. Having two types, int and long, becomes very useful when these sizes are different.

===============================================================
The format %X is for printing an unsigned integer value in hexadecimal format. So, it should not be used for floating point values. We cannot predict the behaviour of the program if we do so. When I tried printf("%X", 1.1f);, the program received signal 8; the signal name is SIGFPE, which stands for
signal — floating point exception”.

===============================================================

In older versions of C, there was no ‘double’ — it was just ‘long float’ type — and that is the reason why it has the format specifier ‘%lf‘ (‘%d‘ was already in use to indicate signed decimal values). Later, double type was added to indicate that the floating point type might be of ‘double precision’ (IEEE format, 64-bit value). So a format specifier for long float and double was kept the same.

===============================================================

For example, in (a && b == c && d), == has higher precedence than &&. So it is interpreted as, (a && (b == c) && d)

===============================================================

The a.out stands for ‘assembler.output’ file

===============================================================

The network layer is where the term packet is used for the first time. Common protocols at this layer are IP (Internet Protocol), ICMP (Internet Control Message Protocol), IGMP (Internet Group Management Protocol) and IPsec (a protocol suite for securing IP). The transport layer’s protocols include TCP (Transmission Control Protocol), a connection-oriented protocol; UDP (User Datagram Protocol), a connection-less protocol; and SCTP (Stream Control Transmission Protocol), which has features of both TCP and UDP. The application layer has many protocols that are commonly used, like HTTP, FTP, IMAP, SMTP and more.


===============================================================

 int i = 90;
        printf("%f\n",sin(i));

[root@localhost rawat]# gcc -Wall -Wextra -O0 xyz.c -g -lm
[root@localhost rawat]# ./a.out 
0.893997
[root@localhost rawat]#

//here 90 is taken in radians not in degree
===============================================================
#include <stdlib.h>

       int rand(void);

       int rand_r(unsigned int *seedp);

       void srand(unsigned int seed);
The rand() function returns a pseudo-random integer in the  range
       0   to   RAND_MAX   inclusive   (i.e.,   the  mathematical  range
       [0, RAND_MAX]).

       The srand() function sets its argument as  the  seed  for  a  new
       sequence  of  pseudo-random  integers  to  be returned by rand().
       These sequences are repeatable by calling srand() with  the  same
       seed value.

       If  no  seed  value is provided, the rand() function is automati‐
       cally seeded with a value of 1.



#include <stdlib.h>

       long int random(void);

       void srandom(unsigned int seed);

       char *initstate(unsigned int seed, char *state, size_t n);
       char *setstate(char *state);



===============================================================
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:16:12: warning: format ‘%lu’ expects argument of type ‘long unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
          ~~^
xyz.c:16:15: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 3 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
              ~^
xyz.c:16:19: warning: format ‘%lf’ expects argument of type ‘double’, but argument 4 has type ‘double *’ [-Wformat=]
  printf("%lu %u %lf",ptr,ptr,ptr);
                 ~~^

===============================================================
xyz.c:17:17: warning: format ‘%d’ expects argument of type ‘int’, but argument 4 has type ‘double’ [-Wformat=]
  printf("%u %p %d\n",ptr,ptr,*ptr);
                ~^            ~~~~
                %f
===============================================================
xyz.c:17:12: warning: format ‘%lf’ expects argument of type ‘double’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%lf %p %f\n",ptr,ptr,*ptr);
          ~~^
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%x’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%x %p %f\n",ptr,ptr,*ptr);
          ~^
===============================================================
int main()
{

        double *ptr =(double*)100;
        printf("%p %f\n",ptr,*ptr);
        ptr=ptr+2;
        printf("%p %f\n",ptr,*ptr);

        return 0;
}

[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 

===============================================================

        double *ptr =(double*)100;
        printf("%p \n",ptr);
        ptr=ptr+2;
        printf("%p \n",ptr);

[root@localhost rawat]# ./a.out 
0x64 
0x74 
[root@localhost rawat]# 

===============================================================

        double *ptr =(double*)100;
        printf("%u \n",ptr);
        ptr=ptr+2;
        printf("%u \n",ptr);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%u \n",ptr);
          ~^
xyz.c:17:11: warning: format ‘%u’ expects argument of type ‘unsigned int’, but argument 2 has type ‘double *’ [-Wformat=]
  printf("%u \n",ptr);
          ~^
[root@localhost rawat]# ./a.out 
100 
116 
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)3;
        int x;

        x= (a != b );
        x= (a & b);
        x= (a | b);

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:19:8: error: invalid operands to binary & (have ‘int *’ and ‘int *’)
  x= (a & b);
        ^
xyz.c:20:8: error: invalid operands to binary | (have ‘int *’ and ‘int *’)
  x= (a | b);
        ^
xyz.c:17:6: warning: variable ‘x’ set but not used [-Wunused-but-set-variable]
  int x;
      ^
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)3;

        int x;

        x= (a != b );
        printf("%d\n",x);
        return 0;


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================

        int *a=(int*)2;
        int *b=(int*)2;

        int x;

        x= (a != b );
        printf("%d\n",x);
        return 0;


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
0
[root@localhost rawat]# 


===============================================================

        char *s ="hello";
        char *p=s;

        printf("%c\t%c\t%c\n",*(p+1),*p+1,s[1]);


[root@localhost rawat]# ./a.out 
e	i	e
[root@localhost rawat]# 


===============================================================

        char *s ="hello";
        char *p=s+2;
        printf("%c\t%c\n",*p,s[1]);

[root@localhost rawat]# ./a.out 
l	e
[root@localhost rawat]# vim xyz.c 

===============================================================


        void *p;
        int a[4]={1,2,3,8};
        p = &a[3];

        int *ptr=&a[2];
        int n= p - ptr;

        printf("%d\n",n);


xyz.c: In function ‘main’:
xyz.c:18:11: error: invalid operands to binary - (have ‘void *’ and ‘int *’)
  int n= p - ptr;
           ^
===============================================================

        void *p;
        int a[4]={1,2,3,8};
        p = &a[3];

        int *ptr=&a[2];
        int n= p - ptr;

        printf("%d\n",n);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================

        int a[4]={1,2,3,8};
        int b[4]={1,2,3,8};

        int n=&b[3] - &a[2];

        printf("%d\n",n);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
-3
[root@localhost rawat]# 

//- indicate stack growing downwards...
//but why it gives 3 ...it has  4 integer elements in between.
// do analysis..

===============================================================

void foo(int *);
int main()
{
        int i=10;
        foo((&i)++);
}
void foo(int *p)
{
        printf("%d\n",*p);
}

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:10: error: lvalue required as increment operand
  foo((&i)++);
          ^~


===============================================================
void foo(int);
int main()
{
        int i=10;
        foo(i++);       
}
void foo(int p)
{
        printf("%d\n",p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
10


===============================================================


void foo(float *);
int main()
{
        int i=10, *p=&i;
        foo(&i);
}
void foo(float *p)
{
        printf("%f\n",*p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:6: warning: passing argument 1 of ‘foo’ from incompatible pointer type [-Wincompatible-pointer-types]
  foo(&i);
      ^
xyz.c:11:6: note: expected ‘float *’ but argument is of type ‘int *’
 void foo(float *);
      ^~~
xyz.c:14:13: warning: unused variable ‘p’ [-Wunused-variable]
  int i=10, *p=&i;
             ^
[root@localhost rawat]# ./a.out 
0.000000
[root@localhost rawat]# 

//here it is showing zero because the binary representation of integer 10 had different meaning for a float value...as float value are represented in binary by their own rule(mantissa part. exponential part) 


===============================================================


void foo(int**);
int main()
{
        int i=97, *p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int **p)
{
        int j=2;
        *p=&j;

        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
[root@localhost rawat]# 


===============================================================

void foo(int*const*);
int main()
{
        int i=11, *p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int *const*p)
{
        int j=10;
        *p=&j;
        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘foo’:
xyz.c:21:4: error: assignment of read-only location ‘*p’
  *p=&j;
    ^
[root@localhost rawat]# 

===============================================================


void foo(int**const);

int main()
{
        int i=10, *p=&i;
        foo(&p);
        printf("%d\n",*p);
        printf("%d\n",*p);
}

void foo(int **const p)
{
        int j=11;
        *p=&j;
        printf("%d\n",**p);
}


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
11
11
11

===============================================================

void foo(int**);
int main()
{
        int i=10, *const p=&i;
        foo(&p);
        printf("%d\n",*p);
}
void foo(int **p)
{
        int j=11;
        *p=&j;
        printf("%d\n",**p);
}


xyz.c: In function ‘main’:
xyz.c:15:6: warning: passing argument 1 of ‘foo’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
  foo(&p);
      ^
xyz.c:11:6: note: expected ‘int **’ but argument is of type ‘int * const*’
 void foo(int**);
      ^~~
[root@localhost rawat]# ./a.out 
11
11
[root@localhost rawat]# 

===============================================================

//cross check it
structures and variables can be sent by call-by-value?
but not arrays

==============================================================

        const int ary[4]={1,2,3,4};
        int *p;
        p=ary+3;
        *p=5;
        printf("%d\n",ary[3]);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:3: warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
  p=ary+3;
   ^
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# ./a.out 
5
[root@localhost rawat]# 


===============================================================

int a[10]={};

//all elements are initialized to zero

===============================================================

        int s=5;
        int a[s]={1,2,3};

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:14:2: error: variable-sized object may not be initialized
  int a[s]={1,2,3};
  ^~~
xyz.c:14:12: warning: excess elements in array initializer
  int a[s]={1,2,3};
            ^
xyz.c:14:12: note: (near initialization for ‘a’)
xyz.c:14:14: warning: excess elements in array initializer
  int a[s]={1,2,3};
              ^
xyz.c:14:14: note: (near initialization for ‘a’)
xyz.c:14:16: warning: excess elements in array initializer
  int a[s]={1,2,3};
                ^
xyz.c:14:16: note: (near initialization for ‘a’)
xyz.c:14:6: warning: unused variable ‘a’ [-Wunused-variable]
  int a[s]={1,2,3};
      ^
[root@localhost rawat]# 


===============================================================

int *a1[8];
int *(a2[8]);

both are the array of pointers

==============================================================

we can declare a 3D array using pointer like this : char *a[][];

but declarations like ***ptr is a triple pointer..u cant say a 3D array (we know internally 3D array is implemented as ***ptr).

or declaration like **a[]..this is double pointer to an 1D array.

===============================================================

char *a={"p","r","o","g","r","a","m"};
printf("%s\n",a);

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={"p","r","o","g","r","a","m"};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 
p
[root@localhost rawat]# 




===============================================================

        char *a={'p','r','o','g','r','a','m'};
        printf("%s\n",a);

see the warning ...and then at last output.

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:11: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  char *a={'p','r','o','g','r','a','m'};
           ^~~
xyz.c:13:11: note: (near initialization for ‘a’)
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
[root@localhost rawat]# 



[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 









===============================================================

char *a={'p','r','o','g','r','a','m'};
        printf("%c\n",a);

but we write %c : then it will give warning as %s expected
but it runs....

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:13:11: warning: initialization makes pointer from integer without a cast [-Wint-conversion]
  char *a={'p','r','o','g','r','a','m'};
           ^~~
xyz.c:13:11: note: (near initialization for ‘a’)
xyz.c:13:15: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
               ^~~
xyz.c:13:15: note: (near initialization for ‘a’)
xyz.c:13:19: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                   ^~~
xyz.c:13:19: note: (near initialization for ‘a’)
xyz.c:13:23: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                       ^~~
xyz.c:13:23: note: (near initialization for ‘a’)
xyz.c:13:27: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                           ^~~
xyz.c:13:27: note: (near initialization for ‘a’)
xyz.c:13:31: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                               ^~~
xyz.c:13:31: note: (near initialization for ‘a’)
xyz.c:13:35: warning: excess elements in scalar initializer
  char *a={'p','r','o','g','r','a','m'};
                                   ^~~
xyz.c:13:35: note: (near initialization for ‘a’)
xyz.c:14:11: warning: format ‘%c’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("%c\n",a);
          ~^
          %s




[root@localhost rawat]# ./a.out 
p
[root@localhost rawat]# 


===============================================================


char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *(a[i]) );
        }



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:17:12: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
   printf("%s\n", *(a[i]) );
           ~^     ~~~~~~~
           %d
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================

        char *a[10]={"hi", "Hello", "wow"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%c\n", *(a[i]) );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
h
H
w
Segmentation fault (core dumped)
[root@localhost rawat]# 






[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:17:12: warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [-Wformat=]
   printf("%s\n", (*a)[i] );
           ~^     ~~~~~~~
           %d
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


===============================================================

char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *a+i );
        }



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hi
i

hello
ello
llo
lo
o

how
[root@localhost rawat]# 



===============================================================


 char *a[10]={"hi", "hello", "how"};
        int i=0;
        for(i=0;i<10;i++)
        {
                printf("%s\n", *(a+i) );
        }




[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hi
hello
how
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================


        char *a[10]={"hi", "Hello", "wow"};
        a[0]="bae";

        int i=0;
        for(i=0 ;i<10 ;i++)
        {
                printf("%s\n", a[i] );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
bae
Hello
wow
Segmentation fault (core dumped)
[root@localhost rawat]# 





        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        int i=0;
        for( i=0; i<10; i++)
        {
                printf("%s", a[i] );
        }

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
hiHellooooooooooooooowow(null)(null)(null)(null)(null)(null)(null)[root@localhost rawat]# 








        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        int i=0;
        for( i=0; i<10; i++)
        {
                printf("%s\n", a[i] );
        }



[root@localhost rawat]# ./a.out 
hi
Hellooooooooooooooo
wow
Segmentation fault (core dumped)
[root@localhost rawat]# 




===============================================================


        char *a[10]={"hi", "Hello", "wow"};
        a[0]="bae";

        int i=0;
        for(i=0 ;i<10 ;i++)
        {
                printf("%s\n", *a+i );
        }


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
bae
ae
e




;0
;0
;0
[root@localhost rawat]#

===============================================================

        char *a[10]={"hi", "Hello", "wow"};
        printf("%d\n", sizeof(a) );



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
80
[root@localhost rawat]# 


here 10 elements of pointer type ...so it is 8*10=80
===============================================================
	
	
	char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        printf("%d\n", sizeof(a[0]) );
        printf("%d\n", sizeof(a[2]) );
        printf("%d\n", sizeof(a[4]) );
        printf("%d\n", sizeof(a[9]) );
 
	
	
	

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[0]) );
          ~^
          %ld
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[2]) );
          ~^
          %ld
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[4]) );
          ~^
          %ld
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[9]) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
8
8
8
8
[root@localhost rawat]# 



===============================================================



        char *a[10]={"hi", "Hellooooooooooooooo", "wow"};
        printf("%d\n", sizeof(a[01]) );
        printf("%d\n", sizeof(a[20]) );
        printf("%d\n", sizeof(a[40]) );
        printf("%d\n", sizeof(a[111]) );


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:15:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[01]) );
          ~^
          %ld
xyz.c:16:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[20]) );
          ~^
          %ld
xyz.c:17:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[40]) );
          ~^
          %ld
xyz.c:18:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d\n", sizeof(a[111]) );
          ~^
          %ld
[root@localhost rawat]# ./a.out 
8
8
8
8
[root@localhost rawat]# 





===============================================================


        int i=2, j=9;
        int *a[]={&i, &j};

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
[root@localhost rawat]# 




===============================================================

        int i=2, j=9;
        int *a[]={&i, &j};

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);

        printf("------------------\n");

        printf("%d\n", *a[1]);
        printf("%d\n", (*a)[1]);



[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
2
2
------------------
9
4195776
[root@localhost rawat]# 



===============================================================
%d expects int.
%x expects unsigned int
%ls expects int*



===============================================================

        int i=2, j=9, k=7;
        int *a[]={&i, &j, &k};

        printf("%p\t%p\t%p\n",&i,&j,&k);
        //printf("%ls\t%ls\t%ls\n",&i,&j,&k);//it is not printing
        printf("%d\t%d\t%d\n",&i,&j,&k);
        printf("------------------\n");

        printf("%d\n", *a[0]);
        printf("%d\n", (*a)[0]);

        printf("------------------\n");

        printf("%d\n", *a[1]);
        printf("%d\n", (*a)[1]);

        printf("------------------\n");

        printf("%d\n", *a[2]);
        printf("%d\n", (*a)[2]);

[root@localhost rawat]# ./a.out 
0x7ffd515bf86c	0x7ffd515bf868	0x7ffd515bf864
1364981868	1364981864	1364981860
------------------
2
2
------------------
9
4195920
------------------
7
0
[root@localhost rawat]# 



===============================================================


int a[10][20];

"20*row + column" is the formula


===============================================================
char a[10][5] = { "hi","hello"," fellows"};
printf("%s",a[2]);


output: fello
===============================================================



        char a[10][7]={ "hi", "hello", "fellows"};
        printf("%ld \n",sizeof(a[1]));
        printf("%ld \n",sizeof(a));
        printf("%ld \n",sizeof(a[5]));
        printf("%ld \n",sizeof(a[6][1]));
        printf("%ld \n",sizeof(a[6]));




[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
7 
70 
7 
1 
7 
[root@localhost rawat]# 


===============================================================

        char a[1][5]={"hello"};
        printf("%s\n",a[0]);
        printf("%s",a[0]);
output will be hello+garbage ...because printf %s prints till null character

but if u make char a[1][6]... the 6th character will be \0...therefore it will print only hello   with out any garbage

===============================================================


        char a[2][5]={"hello","bye"};
        printf("%s\n", *a+1);
        printf("%s", *a+1);
[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
ellobye
ellobye[root@localhost rawat]# 



===============================================================
        char a[2][6]={"hello","bye"};
        printf("%s\n", *a+1);
        printf("%s", *a+1);


[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
[root@localhost rawat]# ./a.out 
ello
ello[root@localhost rawat]# 




===============================================================


char *a[2]={"hello", "hi"};
printf("%s",*(a+1));


output: hi


===============================================================

int *a[]={{1,2,3},{4,5,6}};

this declaration will give warning ...extra elements

===============================================================

u can compare the function pointer 
u can return it also


===============================================================

use of FUNCTION POINTER: to call a function defined at runtime

===============================================================

int (*(*y)())[2];
y is pointer to a function which returns pointer to integer array

===============================================================

macros provide mechanism for token replacement

createdd with help of #define

they make program readable 

no overhead or jump in macrco asa it becomes part of your code

no type checking


#define CUBE (x) (x*x*x)
there must be space between macroName and arguments..also enclose macro in parenthesis

===============================================================

stringizing operator#
concatenation operator##


===============================================================

        union n
        {
                int a;
                float b;
                char c;
        };
        union n var={31999 , 45.95f , 'a'};

        printf("%d\n",var.a);
        printf("%f\n",var.b);
        printf("%c\n",var.c);

        return 0;

[root@localhost rawat]# gcc -g -Wall -Wextra -O0 xyz.c 
xyz.c: In function ‘main’:
xyz.c:19:23: warning: excess elements in union initializer
  union n var={31999 , 45.95f , 'a'};
                       ^~~~~~
xyz.c:19:23: note: (near initialization for ‘var’)
xyz.c:19:32: warning: excess elements in union initializer
  union n var={31999 , 45.95f , 'a'};
                                ^~~
xyz.c:19:32: note: (near initialization for ‘var’)
[root@localhost rawat]# ./a.out 
31999
0.000000
�

// if u change value ,output will change behaviour..ie undefined

===============================================================

void (*(f)())(int, float);
typedef void (*(*x)())(int, float);

void foo(int i, float f);

int main()
{
        x=f;
        x();
}
void (*(f)())(int,float)
{
        return foo;
}

void foo(int i, float f)
{
        printf("%d %f\n",i,f);
}


xyz.c: In function ‘main’:
xyz.c:18:3: error: expected identifier or ‘(’ before ‘=’ token
  x=f;
   ^
xyz.c:19:4: error: expected identifier or ‘(’ before ‘)’ token
  x();
    ^

===============================================================

void (*(f)())(int, float);
typedef void (*(*x)())(int, float);

void foo(int i, float f);

int main()
{
        x p =f;
        p();
}
void (*(f)())(int,float)
{
        return foo;
}

void foo(int i, float f)
{
        printf("%d %f\n",i,f);
}


[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
[root@localhost rawat]# 

//no output, but it runs fine

===============================================================

int *(*ptr[3])();
ptr is array with 3 elements of pointer to function returning pointer of int

===============================================================

int* ((*x)())[2];

===============================================================
sizeof('a');
// it will be 4bytes because the a is a character but it is stored as an integer ascii value.

===============================================================
int a[10];
sizeof(a); 

//it will give size of aaray of 10 integers....40bytes


===============================================================
sizeof(void);
// on 32 bit machine it is 1byte

===============================================================

sizeof() return unsigned int values

we can use functions,pointers, macros inside the sizeof()...the result will depend upon thier return alue to sizeof().
===============================================================

#define PI 3.184
#define PIF 3.184f
#define PII 3
int main()
{
        printf("PI :%ld\n",sizeof(PI));
        printf("PI float:%ld\n",sizeof(PIF));
        printf("PI integer :%ld\n",sizeof(PII));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
PI :8
PI float:4
PI integer :4
[root@localhost rawat]# 


===============================================================

conditional compilation is the preprocessor facility to produce different executables codes for different platforms

===============================================================
preprocessors have compiler specific features...for ex: #pragma

===============================================================

#define foo(m,n) m * n = 10
so, u can write anything in #define preprocessor.
because preprocessor just replaces whatever is given compiler then checks for error at the replaced part of the code...
but if dont use that macro...so nothing will happen...

and it compiles fine...as preprocessor did nothing in the code.


===============================================================


#pragma exit is used for running a function upon exitting the program.

===============================================================

u must include #include<stdio.h> before the use of printf/scanf other wise it will give warning

but using it before main gives readability


===============================================================
<> angular brackets search file on standard paths and then current directory
it first look into C:compiler include , then in S:source headers, then in Current Directory where the program is saved

//confirm it once before speaking

===============================================================
#define foo(m,n) "m ## n"

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
m ## n



===============================================================

#define foo(m,n) m ## n

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:14:20: error: ‘kl’ undeclared (first use in this function)
  printf("%s\n",foo(k,l));
                    ^
xyz.c:9:18: note: in definition of macro ‘foo’
 #define foo(m,n) m ## n
                  ^
xyz.c:14:20: note: each undeclared identifier is reported only once for each function it appears in
  printf("%s\n",foo(k,l));
                    ^
xyz.c:9:18: note: in definition of macro ‘foo’
 #define foo(m,n) m ## n
                  ^
[root@localhost rawat]# 

===============================================================

#define foo(m,n) #m #n

#include <stdio.h>
int main()
{
        printf("%s\n",foo(k,l));
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
kl
[root@localhost rawat]#

===============================================================


# define max 
#include <stdio.h>
int main()
{
        max;

        printf("hii\n");
        printf("%d\n",max);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:17:19: error: expected expression before ‘)’ token
  printf("%d\n",max);
                   ^
[root@localhost rawat]# 


===============================================================

# define max 
#include <stdio.h>
int main()
{
        max;

        printf("hii\n");
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii
[root@localhost rawat]# 

===============================================================

# define  A 1 + 2
# define  B 3 + 4

#include <stdio.h>

int main()
{


        printf("hii: %d\n" , (A*B) );
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii: 11
[root@localhost rawat]# vim xyz.c 



===============================================================

u cant #define a preprocessor

#define A #define
A VAL 30

// check it and confirm it....

===============================================================


#define max 30);
#include <stdio.h>

int main()
{


        printf("hii: %d\n" , max
}

//this works fine.....
===============================================================


#define max 30);
#include <stdio.h>

int main()
{
        printf("hii: %d\n" , max);
}
//it will be ERROR....

===============================================================

you cannot use the pointer to #define...

#define can  not be made externally available

they dont obey scope rules

===============================================================

function definations can be present in hearder files

===============================================================

#define max(m,n) m ## n
#include <stdio.h>

int main()
{


        printf("hii: %d\n" , max(2,3));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii: 23
[root@localhost rawat]# vim xyz.c 


===============================================================


#define max(m,n) "  m ## n "
#include <stdio.h>

int main()
{


        printf("hii: %s\n" , max(2,3));
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:17:16: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘char *’ [-Wformat=]
  printf("hii: %d\n" , max(2,3));
               ~^
               %s
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hii:   m ## n 
[root@localhost rawat]# 


===============================================================

#define IO_HEADER
#include IO_HEADER

these two lines are equivalent to : #include 
since IO_HEADER is replaced by   (nothing , empty)


===============================================================

#define c
#include <stdio.h>
int main()
{
        int a=2;

#ifdef c
        a=1;

        printf("%d",c);
}

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:19:15: error: expected expression before ‘)’ token
  printf("%d",c);
               ^
xyz.c:14:6: warning: variable ‘a’ set but not used [-Wunused-but-set-variable]
  int a=2;
      ^
xyz.c: At top level:
xyz.c:16:0: error: unterminated #ifdef
 #ifdef c
 
[root@localhost rawat]# 


===============================================================

#define c
#include <stdio.h>
int main()
{
        int a=2;

#ifdef c
        printf("COLD\t");
#undef c
#endif

#ifdef c
        printf("HOT\t");
#endif
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:14:6: warning: unused variable ‘a’ [-Wunused-variable]
  int a=2;
      ^
[root@localhost rawat]# ./a.out 
COLD	[root@localhost rawat]# 




===============================================================
u cant do consecutive
#if
#if
//try before u speak


===============================================================


#include <stdio.h>

#define MIN 0
#if defined(MIN) + define(MAX)
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:26: error: missing binary operator before token "("
 #if defined(MIN) + define(MAX)
                          ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in
[root@localhost rawat]# 


===============================================================

#include <stdio.h>

#define MIN 0
#if defined(MIN) - (!define(MAX))
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:28: error: missing binary operator before token "("
 #if defined(MIN) - (!define(MAX))
                            ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in

===============================================================

#include <stdio.h>

#define MIN 0
#ifdef(MIN)
#define MAX 10
#endif

int main()
{
printf("%d %d\n",MAX,MIN);
return 0;

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:13:7: error: macro names must be identifiers
 #ifdef(MIN)
       ^
xyz.c: In function ‘main’:
xyz.c:19:18: error: ‘MAX’ undeclared (first use in this function)
 printf("%d %d\n",MAX,MIN);
                  ^~~
xyz.c:19:18: note: each undeclared identifier is reported only once for each function it appears in


===============================================================

struct temp s;
struct temp{};
#include <stdio.h>

int main()
{
return 0;

}

..u can write structure variable before struture defination 


===============================================================

#include <stdio.h>
struct temp
{

        int no;
        char name[20];

};



int main()
{
        struct temp s;
        s.no=8;
        printf("hello\n");
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:21:1: error: expected ‘;’, identifier or ‘(’ before ‘int’
 int main()
 ^~~
xyz.c: In function ‘main’:
xyz.c:23:14: warning: variable ‘s’ set but not used [-Wunused-but-set-variable]
  struct temp s;
              ^

// structure declaration must end with semicolon(;)

===============================================================

#include <stdio.h>
struct temp
{

        int no;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        s.no=8;
        printf("hello %d %d\n",s.no,temp);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hello 8 99





===============================================================



#include <stdio.h>
struct temp
{

        int no;
        int age;
        float height;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
return 0;

}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %s %d\n",s.no,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:26:46: warning: ‘s.height’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
                                             ~^~~~~~~
xyz.c:26:2: warning: ‘s.age’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
xyz.c:26:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
[root@localhost rawat]# ./a.out 
hello 4195616 0 0.000000  99
[root@localhost rawat]# 


//so its warning to use uninitialized struture. and the character array is showing nothing.



#include <stdio.h>
struct temp
{

        int no;
        int age;
        float height;
        char name[20];

};

int temp=99;

int main()
{
        struct temp s;
        s.name[0]='s';
        printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
return 0;

}

[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:27:46: warning: ‘s.height’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
                                             ~^~~~~~~
xyz.c:27:2: warning: ‘s.age’ is used uninitialized in this function [-Wuninitialized]
  printf("hello %d %d %f %s %d\n",s.no,s.age,s.height,s.name,temp);
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
xyz.c:27:2: warning: ‘s.no’ is used uninitialized in this function [-Wuninitialized]
[root@localhost rawat]# ./a.out 
hello 4195616 0 0.000000 s 99

===============================================================

#include <stdio.h>
struct temp
{
        char name[20];
};

int temp=99;

int main()
{
        struct temp s;
        s.name="hello";
        printf("hello %s %d\n",s.name,temp);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:26:8: error: assignment to expression with array type
  s.name="hello";
        ^

===============================================================



#include <stdio.h>
struct temp t;
struct temp
{
        char *name;
};
struct temp func(void)
{
        t.name = "newton";
        printf("%s\n",t.name);
        t.name = "alan";
        return t;
}
/*
struct temp
{
        char *name;
};
*/
// if u will not put structure defination before its use so in above function it will show undefined data type t
int temp=99;

//struct temp t;
//if u will declare it here ..it will be error ,as this t will be undeclared in func()

int main()
{
        struct temp q=func();

        printf("%s\n",q.name);
        q.name = "turing";

        printf("%s\n",t.name);
return 0;

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
newton
alan
alan
[root@localhost rawat]# 

// so assigning one structure variable to another will make a seprate copy
// a seprate copy ... and changing one variavble will not effect other...as both have their own memeory

===============================================================

#include <stdio.h>
struct temp
{
        int a;
}s;
void func(struct temp)
{
        s.a=10;
        printf("%d \t",s.a);
}
int main()
{
        func(s);
        printf("%d\t",s.a);
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘func’:
xyz.c:15:18: error: parameter name omitted
 void func(struct temp)
                  ^~~~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>
struct temp
{
        int a;
}s;
void func(struct temp zz)
{
        s.a=10;
        printf("%d \t",s.a);
}
int main()
{
        func(s);
        printf("%d\t",s.a);
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘func’:
xyz.c:15:23: warning: unused parameter ‘zz’ [-Wunused-parameter]
 void func(struct temp zz)
                       ^~
[root@localhost rawat]# ./a.out 
10 	10	[root@localhost rawat]# 

===============================================================

xyz.c: In function ‘main’:
xyz.c:24:4: error: incompatible types when assigning to type ‘struct temp’ from type ‘struct temp *’
  s1=&s2;
    ^
===============================================================

#include <stdio.h>

struct temp
{
        char *a;
};

struct temp func(void)
{
        struct temp s;
        s.a="alan";
        return s;
}

int main()
{
        struct temp s1=func();
        s.a="turing";

        printf("%s\t",s1.a);

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:27:2: error: ‘s’ undeclared (first use in this function); did you mean ‘s1’?
  s.a="turing";
  ^
  s1
xyz.c:27:2: note: each undeclared identifier is reported only once for each function it appears in
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        int i;
        int j;
};

int main()
{
        struct temp t1={1};
        struct temp t2={1};
        if(t1==t2)
                printf("equal\n");
        else
                printf("not equal\n");

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘j’ of ‘struct temp’ [-Wmissing-field-initializers]
  struct temp t1={1};
         ^~~~
xyz.c:15:6: note: ‘j’ declared here
  int j;
      ^
xyz.c:21:9: warning: missing initializer for field ‘j’ of ‘struct temp’ [-Wmissing-field-initializers]
  struct temp t2={1};
         ^~~~
xyz.c:15:6: note: ‘j’ declared here
  int j;
      ^
xyz.c:22:7: error: invalid operands to binary == (have ‘struct temp’ and ‘struct temp’)
  if(t1==t2)
       ^~
[root@localhost rawat]# 


===============================================================

u cant assign one structure variable to different structure variable.
even though they have same kind of members

===============================================================


#include <stdio.h>
struct zemp
{
        int k;
        int d;
};

void foo(struct zemp*);

int main()
{
        struct zemp t2={1,5};
        foo(&t2);
        return 0;
}


void foo(struct zemp *p)
{
        printf("%d\n",*p.x++);
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:29:18: error: ‘p’ is a pointer; did you mean to use ‘->’?
  printf("%d\n",*p.x++);
                  ^
                  ->
xyz.c:27:23: warning: parameter ‘p’ set but not used [-Wunused-but-set-parameter]
 void foo(struct zemp *p)
                       ^
[root@localhost rawat]# 


===============================================================



#include <stdio.h>
struct student fun(void)
{
        struct student
        {
                char *name;
        };
        struct student s;
        s.name = "alan";
        return s;
}
int main()
{
        struct student m=fun();
        printf("%s",m.name);
returni 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:11:16: error: return type is an incomplete type
 struct student fun(void)
                ^~~
xyz.c: In function ‘fun’:
xyz.c:19:9: warning: ‘return’ with a value, in function returning void
  return s;
         ^
xyz.c:11:16: note: declared here
 struct student fun(void)
                ^~~
xyz.c: In function ‘main’:
xyz.c:23:9: error: variable ‘m’ has initializer but incomplete type
  struct student m=fun();
         ^~~~~~~
xyz.c:23:17: error: storage size of ‘m’ isn’t known
  struct student m=fun();
                 ^
xyz.c:25:1: error: ‘returni’ undeclared (first use in this function)
 returni 0;
 ^~~~~~~
xyz.c:25:1: note: each undeclared identifier is reported only once for each function it appears in
xyz.c:25:9: error: expected ‘;’ before numeric constant
 returni 0;
         ^
xyz.c:23:17: warning: unused variable ‘m’ [-Wunused-variable]
  struct student m=fun();
                 ^
[root@localhost rawat]# 


===============================================================

to receive array of strutures
void foo(struct *arr);


===============================================================


#include <stdio.h>
        struct student
        {
                char *name;
        };

struct student s[2], r[2];

int main()
{
        s[0].name="alan";
        s[1]=s[0];
        r=s;

        printf("%s %s",r[0].name,r[1].name);
return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:3: error: assignment to expression with array type
  r=s;
   ^
[root@localhost rawat]# 


===============================================================


#include <stdio.h>
        struct student
        {
                char *name;
        };

struct student s[2], r[2];

int main()
{
        s[1]=s[0]="alan";

        printf("%s %s",s[0].name,s[1].name);
return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:11: error: incompatible types when assigning to type ‘struct student’ from type ‘char *’
  s[1]=s[0]="alan";
           ^
[root@localhost rawat]# 


===============================================================

#include <stdio.h>
        struct student
        {
        };


int main()
{
        struct student s[2];
        struct student *sp;

        printf("sizeof(sp): %ld\n",sizeof(sp));
        printf("sizeof(s): %ld\n",sizeof(s));
        printf("sizeof(s[1]): %ld\n",sizeof(s[1]));

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
sizeof(sp): 8
sizeof(s): 0
sizeof(s[1]): 0
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        //struct point p1[]={1,2,3,4};//this is warning;see below
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d \n",p[1].x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:21:20: warning: missing braces around initializer [-Wmissing-braces]
  struct point p1[]={1,2,3,4};
                    ^
                     {  }{  }
[root@localhost rawat]# vim xyz.c 
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
3 
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d \n",p->x);

}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 



===============================================================

#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{1,2},{3,4}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",p->x,++p->x);

}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:24: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",p->x,++p->x);
                        ^~~~~~
[root@localhost rawat]# ./a.out 
2 2
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",++p->x,p->x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:19: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",++p->x,p->x);
                   ^~~~~~
[root@localhost rawat]# ./a.out 
101 100
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};

void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d\n",p->x,++p->x);

}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘foo’:
xyz.c:26:24: warning: operation on ‘p->x’ may be undefined [-Wsequence-point]
  printf("%d %d\n",p->x,++p->x);
                        ^~~~~~
[root@localhost rawat]# ./a.out 
101 101
[root@localhost rawat]# 



===============================================================
the .dot hashigher precedence then ->
and the -> operator has higher precedence then ++

//check the operator precedence
===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
}p[]={{100,200},{300,400}};

void foo(struct point*);
int main()
{
        foo(p);
}
void foo(struct point p[])
{
        printf("%d %d %d %d\n",p->x,p[0].y,p[2].x,p[2].y);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
100 200 0 0
[root@localhost rawat]#



===============================================================



#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d %d\n",p->x, p[2].x, p[2].y, p[3].y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# 

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# 


[root@localhost rawat]# ./a.out 
100 500 0 0
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
xyz.c: In function ‘foo’:
xyz.c:25:35: error: ‘p + 16’ is a pointer; did you mean to use ‘->’?
  printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
                                   ^
                                   ->
xyz.c:25:45: error: ‘p + 16’ is a pointer; did you mean to use ‘->’?
  printf("%d %d %d\n", p->x , (p+2).x , (p+2).y);
                                             ^
                                             ->
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , (p+2)->x , (p+2)->y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# ./a.out 
100 500 0
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct point
{
        int x;
        int y;
};
void foo(struct point*);
int main()
{
        struct point p1[]={{100,200},{300,400},{500,}};
        foo(p1);
}
void foo(struct point p[])
{
        printf("%d %d %d\n", p->x , ++(p+2)->x , ++(p+2)->y);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:9: warning: missing initializer for field ‘y’ of ‘struct point’ [-Wmissing-field-initializers]
  struct point p1[]={{100,200},{300,400},{500,}};
         ^~~~~
xyz.c:15:6: note: ‘y’ declared here
  int y;
      ^
[root@localhost rawat]# ./a.out 
100 501 1
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct point
{
        char *c;
};
int main()
{
        struct point p1[2];
        printf("%ld",sizeof(p1));
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct point
{
        char *c;
};
int main()
{
        struct point p1[2];
        printf("%ld\n",sizeof(p1));
        printf("%ld\n",sizeof(p1[0]));
        printf("%ld\n",sizeof(p1+1));
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16
8
8
[root@localhost rawat]# 



===============================================================

xyz.c: In function ‘main’:
xyz.c:20:9: warning: excess elements in array initializer
  struct p p1[2]={1,92,3,94,5,96};
         ^
xyz.c:20:9: note: (near initialization for ‘p1’)
xyz.c:20:17: warning: missing braces around initializer [-Wmissing-braces]
  struct p p1[2]={1,92,3,94,5,96};
                 ^
                  {   }{   }{   }
[root@localhost rawat]# 



===============================================================



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:35: warning: excess elements in array initializer
  struct p p1[2]={{1,92} ,{3,94} , {5,96}};
                                   ^
xyz.c:20:35: note: (near initialization for ‘p1’)


===============================================================


#include <stdio.h>
struct p
{
        int x;
        char y;
};
typedef struct p*  q;
int main()
{
        struct p p1[]={{1,92} ,{3,94} , {5,96}};
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 


===============================================================
[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:17:21: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘*’ token
 typedef struct p*  q*;
                     ^
xyz.c: In function ‘main’:
xyz.c:21:2: error: unknown type name ‘q’
  q* ptr1 = p1;
  ^
xyz.c:21:12: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  q* ptr1 = p1;
            ^~
xyz.c:22:20: error: request for member ‘x’ in something not a structure or union
  printf("%d\n",ptr1->x);
                    ^~
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct p
{
        int x;
        char y;
};
void foo(struct p*);

int main()
{
        typedef struct p*  q;

        struct p p1[]={{1,92} ,{3,94} , {5,96}};

        foo(p1);

}

void foo(struct p* p1)
{
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:21:21: warning: typedef ‘q’ locally defined but not used [-Wunused-local-typedefs]
  typedef struct p*  q;
                     ^
xyz.c: In function ‘foo’:
xyz.c:31:2: error: unknown type name ‘q’
  q ptr1 = p1;
  ^
xyz.c:31:11: warning: initialization makes integer from pointer without a cast [-Wint-conversion]
  q ptr1 = p1;
           ^~
xyz.c:32:20: error: invalid type argument of ‘->’ (have ‘int’)
  printf("%d\n",ptr1->x);
                    ^~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

typedef struct p*  q;

struct p
{
        int x;
        char y;
};
void foo(struct p*);

int main()
{

        struct p p1[]={{1,92} ,{3,94} , {5,96}};

        foo(p1);

}

void foo(struct p* p1)
{
        q ptr1 = p1;
        printf("%d\n",ptr1->x);
}


[root@localhost rawat]# ./a.out 
1
[root@localhost rawat]# 




===============================================================

pointer to structure
struct temp
{
	int b;
}*my_struct;

these way u can access
(*my_struct).b=10;
my_struct->b=10;

but not this way: *my_struct.b=10;

===============================================================

func(&s.a);
func(&(s).a);
func(&(s.a));
are the correct way to for pass by reference a member of a structure in a function

===============================================================


#include <stdio.h>

struct temp
{
        int a;
}s;

void change(struct temp);

int main()
{
        s.a=10;
        change(s);
        printf("%d\n",s.a);
}

void change(struct temp s)
{
        s.a=1;
}

[root@localhost rawat]# ./a.out 
10



===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{

        struct temp *s;
        s->c="hello";

        printf("%s\n",s->c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: warning: ‘s’ is used uninitialized in this function [-Wuninitialized]
  s->c="hello";
  ~~~~^~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *(s).c="hello";

        printf("%s\n",m.c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *(s).c="hello";
      ^
      ->
xyz.c:21:15: warning: variable ‘s’ set but not used [-Wunused-but-set-variable]
  struct temp *s=&m;
               ^


===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *s->c="hello";
        printf("%s\n",m.c);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:7: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *s->c="hello";
       ^
[root@localhost rawat]# ./a.out 
�
[root@localhost rawat]# 


===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        s->c="hello";
        printf("%s\n",m.c);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
hello
[root@localhost rawat]# 

===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        (*s).c="hello";
        printf("%p %p\n",s,&m);
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
0x7fff77303750 
0x7fff77303750 
[root@localhost rawat]# 



===============================================================


#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *s.c="hello";
        printf("%p \n%p \n",s,&m);
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:4: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *s.c="hello";
    ^
    ->
[root@localhost rawat]# 


===============================================================



#include <stdio.h>

struct temp
{
        char *c;
};


int main()
{
        struct temp m;
        struct temp *s=&m;
        *(s).c="hello";
        printf("%p \n%p \n",s,&m);
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:6: error: ‘s’ is a pointer; did you mean to use ‘->’?
  *(s).c="hello";
      ^
      ->
[root@localhost rawat]# 


===============================================================


#include <stdio.h>
struct temp
{
        char *c;
        struct temp t;
};
int main()
{
        struct temp m1,m2;
        struct temp *s=&m1;

        struct temp *s2=m2;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:15:14: error: field ‘t’ has incomplete type
  struct temp t;
              ^
xyz.c: In function ‘main’:
xyz.c:24:18: error: incompatible types when initializing type ‘struct temp *’ using type ‘struct temp’
  struct temp *s2=m2;
                  ^~
xyz.c:24:15: warning: unused variable ‘s2’ [-Wunused-variable]
  struct temp *s2=m2;
               ^~
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
[root@localhost rawat]# 


===============================================================

self referencial struture are those who have pointer to itself as its member

but if u have a normal variable inside the structure of the same structure type ...it will be error....as shown above.



===============================================================


struct temp
{
        char *c;
        struct temp *t;
};


int main()
{
        struct temp m1;
        struct temp *s=&m1;

        printf("%ld\n",sizeof(temp));
}




[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:24: error: ‘temp’ undeclared (first use in this function)
  printf("%ld\n",sizeof(temp));
                        ^~~~
xyz.c:24:24: note: each undeclared identifier is reported only once for each function it appears in
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
===============================================================



#include <stdio.h>

struct temp
{
        char *c;
        struct temp *t;
};


int main()
{
        struct temp m1;
        struct temp *s=&m1;

        printf("%ld\n",sizeof(struct temp));
        //printf("%ld\n",sizeof(temp));
        printf("%ld\n",sizeof(m1));
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:15: warning: unused variable ‘s’ [-Wunused-variable]
  struct temp *s=&m1;
               ^
[root@localhost rawat]# ./a.out 
16
16
[root@localhost rawat]# 



===============================================================

#include <stdio.h>

struct p
{
        int x;
        char y;
        struct p *ptr;
};

int main()
{
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->x);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 
[root@localhost rawat]# 



===============================================================



#include <stdio.h>
typedef struct p *q;
int main()
{
        struct p
        {
                int x;
                char y;
                q ptr;
        };
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:24:18: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  struct p p={1,2,&p};
                  ^
xyz.c:24:18: note: (near initialization for ‘p.ptr’)
xyz.c:25:22: error: dereferencing pointer to incomplete type ‘struct p’
  printf("%d \n",p.ptr->x);
                      ^~
[root@localhost rawat]# 



===============================================================


#include <stdio.h>
typedef struct p *q;
        struct p
        {
                int x;
                char y;
                q ptr;
        };
int main()
{
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
1 
[root@localhost rawat]# 


===============================================================

#include <stdio.h>
typedef struct p *q;
int main()
{
        struct p
        {
                int x;
                char y;
                q ptr;
        };
        struct p p={1,2,&p};
        printf("%d \n",p.ptr->ptr->x);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:20:18: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  struct p p={1,2,&p};
                  ^
xyz.c:20:18: note: (near initialization for ‘p.ptr’)
xyz.c:21:22: error: dereferencing pointer to incomplete type ‘struct p’
  printf("%d \n",p.ptr->ptr->x);
                      ^~
[root@localhost rawat]# 

===============================================================


#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p;
        p->name = "xyz";
        p->next = NULL;
        ptrary[0] = &p;

        printf("%s \n",p->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:22:3: error: invalid type argument of ‘->’ (have ‘struct p’)
  p->name = "xyz";
   ^~
xyz.c:23:3: error: invalid type argument of ‘->’ (have ‘struct p’)
  p->next = NULL;
   ^~
xyz.c:26:18: error: invalid type argument of ‘->’ (have ‘struct p’)
  printf("%s \n",p->name);
                  ^~
[root@localhost rawat]# 


===============================================================



#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p;
        p.name = "xyz";
        p.next = NULL;
        ptrary[0] = &p;

        printf("%s \n",p.name);
        printf("%s \n",ptrary[0]->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
xyz 
xyz 
[root@localhost rawat]# 



===============================================================

#include <string.h>
#include <stdio.h>
        struct p
        {
                char *name;
                struct p *next;
        };

struct p *ptrary[10];

int main()
{
        struct p p,q;

        p.name = "xyz";
        p.next = NULL;

        ptrary[0] = &p;

        strcpy(q.name,p.name);

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->name);

        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:28:2: warning: ‘q.name’ is used uninitialized in this function [-Wuninitialized]
  strcpy(q.name,p.name);
  ^~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 


//segfault inside strcpy();

===============================================================

#include <string.h>
#include <stdio.h>

int main()
{
        struct p
        {
                char *name;
                struct p *next;
        };

        struct p *ptrary[10];

        struct p p,q;

        p.name = "xyz";
        p.next = NULL;

        ptrary[0] = &p;

        strcpy(q.name,p.name);

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->name);

        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c: In function ‘main’:
xyz.c:30:2: warning: ‘q.name’ is used uninitialized in this function [-Wuninitialized]
  strcpy(q.name,p.name);
  ^~~~~~~~~~~~~~~~~~~~~
[root@localhost rawat]# ./a.out 
Segmentation fault (core dumped)
[root@localhost rawat]# 



===============================================================


#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main()
{
        struct p
        {
                char *name;
                struct p *next;
        };

        struct p *ptrary[10];

        struct p p,q;

        p.name = "xyz";
        p.next = NULL;


        ptrary[0] = &p;

        q.name=(char*)malloc(sizeof(char)*3);

        strcpy(q.name,p.name);

        q.next=&q;

        ptrary[1]=&q;

        printf("%s \n",ptrary[1]->next->next->name);

        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
xyz 
[root@localhost rawat]# 

===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        char a[];
}

int main()
{
        struct student s;
        printf("%d \n",sizeof(struct student));
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:15:7: error: flexible array member in a struct with no named members
  char a[];
       ^
xyz.c:18:1: error: expected ‘;’, identifier or ‘(’ before ‘int’
 int main()
 ^~~
xyz.c: In function ‘main’:
xyz.c:21:11: warning: format ‘%d’ expects argument of type ‘int’, but argument 2 has type ‘long unsigned int’ [-Wformat=]
  printf("%d \n",sizeof(struct student));
          ~^
          %ld
xyz.c:20:17: warning: unused variable ‘s’ [-Wunused-variable]
  struct student s;
                 ^
[root@localhost rawat]# 


===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
struct student
{
        int i;
        char a[];

};
int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}

[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
4 
[root@localhost rawat]# 

===============================================================

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        int i;
        char b[10];
        char a[];

};

int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}



[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
[root@localhost rawat]# ./a.out 
16 
[root@localhost rawat]# 

===============================================================


#include <stdlib.h>
#include <string.h>
#include <stdio.h>

struct student
{
        int i;
        char a[];
        char b[10];

};

int main()
{
        printf("%ld \n",sizeof(struct student));
        return 0;
}


[root@localhost rawat]# gcc -ggdb -gdwarf-4 -Wall -Wextra -g xyz.c
xyz.c:16:7: error: flexible array member not at end of struct
  char a[];
       ^
[root@localhost rawat]# 




===============================================================

typedef int (*PFI)(char *, char *)

type PFI , for pointer to funciton of two char* arguments returning int


===============================================================

-)
deletion and insertion are difficult and need movemnts in array 
but in liked list no movement of nodes is required

-)
in array space is wasted upon deletion but not in linked list

-)
array cant be reduced and extended as per conditions but linked list can be.

-)
in array to avail each element same amount of time is required
but in linkd list, to avail each element differnet amount of time is required.

-)
in consequtive memory locations elements are stored in array
but in linked list , elements may or may not be stored in consequitive memory locations

-)
we can access element directly in array,but to reach a particular node we have to traverse every node.

-)
array need to know size in advance but not in LL

===============================================================
application of LL
used to implement queues, stack, graphs,
you dont need to know the size of LL


===============================================================
if it is circular link list so
move a pointer by 1 position
and another pointer by 2 positions
....so after a time both will meet...(not necessarily in one time..but after looping again and again.)

===============================================================
finding mid of LL

method 1 : traverse to end and count...and then count/2
method 2 : move a slow pointer by 1 position and a fast pointer by 2 positions. so when fast reaches end(NULL), the slow will be at mid.


===============================================================
we can flatten a LL
and LL should be the linked list of linked list
ie... every linked list nodes pointing to other linked list

so we can flatten them into a single linked list as per some given condition ...ascending/descending order



===============================================================
find Nth node from the end

-)
(len -Nth +1) will tell you how many postions to move from head

-)
take two pointer "ref" and "main" pointing to head initially

first, move ref pointer to the 'n' nodes from head
now, move both pointers till ref pointer reaches the end.

Now, the main pointer will point to the Nth node from end

===============================================================
display/read LL in reverse(from end)

-)
use recursion and then go end and then display

===============================================================
to count the number of occurences 

-)
traverse LL and if the node is the key , increment the count


===============================================================
to find duplicate

-)
move one pinter one by one
but make other pointer to move whole linked list while first moves by one node
and keep matching if any other node is found 

 (so the second pointer traverse LL from position of first pointer  till the duplicate is found. if not found increment the first pointer ...and second pointer will traverse from position pointed b first pointer till the duplicate if found...this goes so on...till the dupilcate is found ot the first pointer reaches end)

===============================================================
reverse a linked list

void rev(struct node **head)
{
	struct node *p,*q,*r;
	p=q=r=*head;
	p=p->next->next;
	
	q=q->next;
	r->next=NULL;
	q->next=r;

	while(p!=NULL)
	{
		r=q;
		q=p;
		p=p->next;
		q->next=r;
	}
	
	*head=q;
}

basically we chanegd the starting as it would have been if it was the end
and in loop we made the pointer point to previous node 
===============================================================
interchanging two adjacent nodes in circular linked list
===============================================================
palindrome

to check if LL is palindrome
bring one pointer at mid and keep one pointer at begin
now loop till size/2
increase the front pointer and the mid pointer...and check


===============================================================

doubly linked list 
 each node have two links to next nad previous
 and the begin/end nodes pointer previous/next  have null ...since it is linear


===============================================================
doubly LL using Single LL

make a singly LL . now use two pointers current and begin
 to go forward move the current ahead..to go backward bring begin one previous to current pointer

( so a single LL with two pointers one moving forward and other at/moving one previous to the current ...so that u can go to any direction ) 


===============================================================
implementing Stack using LL

look the concept is to create LL and perform operations
as per stack.

( so if u want to delete ... make a hard code that when use r ask to delete ...a functions is called and delete will happen only at the end of LL
similalry if user wants to insert ..make it hard coded that insert will happen in the end only )

===============================================================
implement queue using LL

make the hardcode that insert will happen at the last node
and deleteion from head node


===============================================================

binary tree using linked list

binary search tree is a binary tree in which each internal node x stores an element such that the element stored in the left subtree of x are less than or equal to x and elements stored in the right subtree of x are greater than or equal to x. this is called binary search tree property

===============================================================



